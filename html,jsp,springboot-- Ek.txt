Web architecture--
www--
web design provides user interface.
Web is a collection of resources which
contains text,images,audio any data composed as HTML doc.
Resources in the HTML doc are hosted on the server.
The resources on the server can be accesed by entering 
a url (uiform resource locator) in the browser.

browser is the client.

client sends req to server
and server sends response to client.

req is url, resp is web page.

Web application tools--
browser, code-editor, servers- Wamp,lamp,mamp,xampp
wamp-- window apache mysql(maria db),php
LAMP- linux apache mysql(maria db),php
MAMP- macintosh apache mysql(maria db),php
XAMPP - cross platform apache mysql(maria db),php

Developer tools in browser--
view page source, inspect

HTML - gives structure
css gives style to make it attractive or presentation.

xampp->htdocs-->create web_design7 folder 
use notepad++

title is the title of web page.
title is displayed on the tab of the url.
rest all is body section.

<html>
	<head>
		<title>HTML</title>
	</head>
	<body>
		<h1>
			This is heading 1
		</h1>
	</body>
	
</html>

first.html

xampp-->htdocs--->webdesign_7-->first.html

now xampp-htdocs is localhost.
So start xampp apache--

go to browser and write
http://localhost/webdesign_7/first.html

Html is a tagging language. The texts written in tags are 
outputted accordingly.

There r 2 types of tags, Semantic tags and non sementic tgas.
Semantic tags have more importance then non-semantic tags.
emphasize tag and strong tags are semantic tags.
<em><strong>

Inspect element-->elements
all the headers are occuping entire width of 
browser. is block level element
the paragraph occupies entire width
So we have 2 types of contents. 
Blocklevel and inline.
And the elements which occupy width of the 
browser as per its content length, is inline element.

<html>
	<head>
		<title>HTML</title>
	</head>
	<body>
		<h1>This is heading 1</h1>
		<h2>This is heading 2</h2>
		<h3>This is heading 2</h3>
		<h4>This is heading 2</h4>
		<h5>This is heading 2</h5>
		<h6>This is heading 2</h6>
		<p>
		give
		some
		lorem
		ipsum
		</p>
		<!-- Bold and italic comment -->
		<!--
		multi 
		line
		comment
		-->
		<b>This is bold tag</b><br/>
		<strong>strong tag</strong><br/>
		<i>This is italic tag</i><br/>
		<em>Emphasize tag</em><br/>
		<u>underline</u>
		<del>delete tag</del>
		<p>H<sub>2</sub>O
		<p>x<sup>2</sup>+4x+6</p>
		<div>Division tag</div>
		<span>Span Tag</Span>
		<hr>
		
	</body>
	
</html>

--
div tag-- this is a non-formatting tag which is used
for creating some blocks or some seperate sections
to put elements properly.

span tag-- again for formattting.

d/b span and div is--
Do inspect -- in span there is no margin or nothing in orange color
but in case of div-- it is occupying entire
width of browser.
So div is block level.
span tag is inline level.
Both are used for code maintainablity.

<hr>-- horizontal line.
no need of closing <hr>
same with <br> 

---

Now anchor tag--
Anchor tag is used for creating link between 2 pages.
Adding hyperlink is added by anchor tag so that user can navigate to various 
pages.
<a href="" target="">contact us</a>
in the href u give path of the file

_blank is used for opening a file in new tab. 

<a href="../abc/first.html" target="_blank">contact us</a>-- if u want to go 1 step back and enter into some folder.

-- anchortag.html--

<html>
	<head>
		<title>Anchor Tag</title>
	</head>
	<body>
		<!--<a href="../abc/first.html" target="_blank">contact us</a>-->
		<a href="def/first.html" target="_blank">contact us</a>
	</body>
</html>

---imagetag.html---

<img src="path of image" alt="" width="npx"
height="npx" />

alt is alternate image name,
height and width can be in pxs or %.

<html>
	<head>
		<title>HTML</title>
	</head>
	<body>
	<!----
	<img src="path of image" alt="" width="npx" height="npx" />
	---->
	<img src="th.jpg" title=" lovely nature" alt="Nature" width="400px" height="300px" />	
	</body>
	
</html>

--

list_tag.html--
unordererd list
ordered list
definition list

in o/p we r getting bullets bcoz its unordreed.

type attribute helps with bullets--
3 types-- disc,circle,square
disc is a black circle.
by default its disc.

<html>
	<head>
		<title>HTML</title>
	</head>
	<body>
	<!-- Unordered list -->
	<strong> Fruits : </strong>
	<ul type="circle">
		<li>Mango</li>
		<li>Apple</li>
		<li>Orange</li>
		<li>Kiwi</li>
	  </ul>
	  <!-- ordereed list -->
	  <hr>
	  <strong> Fruits : </strong>
	  <ol type="i"> <!-- type = 1/A/a/I/i -->
		<li>Mango</li>
		<li>Apple</li>
		<li>Orange</li>
		<li>Kiwi</li>
	  </ol>
	  <hr>
	  <!-- definition list -->
	  <dl>
		<dt>HTML</dt>
		<dd>HTML is a tagging language</dd>
		<dt>CSS</dt>
		<dd>Used for presentation</dd>
		<dt>JS</dt>
		<dd>Makes web page dynamic</dd>
	  </dl>
	</body>
	
</html>

<dl>-- def list
<dt>-- data term
<dd>-- data definition

--
table tag--
Rno.  name  per
---------------
1      A     93.5
2      B     98.7

<table> - table tag
<th>- table heading
<tr> - table row
<td>- table data col wise.

table's border we can give using border=1
dont give any other value.
self spacing-- spacing between 2 values
self padding-- internal space of values.

<html>
	<head>
		<title>Table Tag</title>
	</head>
	<body>
		<table border="1" align="center">
			<tr>
				<td>Rno</td>
				<td>Name</td>
				<td>Percentage</td>
			</tr>
			<tr>
				<td>1</td>
				<td>ABC</td>
				<td>98.6</td>
			</tr>
			<tr>
				<td>2</td>
				<td>PQR</td>
				<td>99.6</td>
			</tr>
	</body>
</html> 

tr always consider max no. of cols.
so if i want to give student information 
heading above my table--
it will take that as 1 col content and keep 
all the other rows blank.
So, we will use colspan="3" in our case.

lly there is rowspan 


---

3- rowspan colspan form elements

https://drive.google.com/drive/folders/1alUjkh8ug9eQ6SBbSOJyOMkXTgZ52DhH

search on browser== maps.google.com
In the search bar of google maps , search -- itvedant andheri
Now on the left 3 bars are there,

click share or embedd-- clcik on embedd a map-- copy html tag.
just paste it inside body tag.
this will embedd the code.

<html>
	<head>
		<title>Google tab</title>
	</head>
	<body>
	<iframe src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3769.7096425279824!2d72.84785857337002!3d19.12038975058107!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x3be7c984163a9269%3A0x6d6da73fe2055ccf!2sItvedant%20Education%20Pvt.%20Ltd%20-%20Andheri!5e0!3m2!1sen!2sin!4v1713796768092!5m2!1sen!2sin" width="600" height="450" style="border:0;" allowfullscreen="" loading="lazy" referrerpolicy="no-referrer-when-downgrade"></iframe>
	</body>
</html>
	

save the file.

http://localhost/webdesign/map_try.html ------ browser

lly, for youtube video, right click on video, embedd code, and import iframe.

<html>
	<head>
		<title>Iframe tag - youtube video</title>
	</head>
	<body>
	<iframe width="661" height="372" src="https://www.youtube.com/embed/-BjZmE2gtdo" title="Taylor Swift - Lover (Official Music Video)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
	</body>
</html>
	

http://localhost/webdesign/iframe_tag.html-----

now form tag---

form is used to take user input.
2 attributes of form tag are-- method and action attribute.
method attr can take get/post method.
action --
enctype is another attr.

input tag has attr type which takes datatype values.
text for characters
name attribute can have any name. Name attr is used to access the value. This comes handy when form is submitted.
there are attr also but we will see that with css.

then submit button. The value of submit can be anything.

type-- text---------

<html>
	<head>
		<title>Iframe tag - youtube video</title>
	</head>
	<body>
	<form method="Get">
		Name:<input type="text" name="sname" /> <br/>
		<input type="submit" name="send" value="submit" />
	
	</form>
	
	</body>
</html>

now why we have given sname to input?--Because it helps in getting the attribute in backend.

See the url, once we enter the name and submit-- see the url change.

now instead of get if we will write post-- the form data will not be visible.

get method send data in the form of key-value pair.
in post data is sent in encrypted format.

now adding action attr for redirection,

<form method="post" action="first.html"> ----------------------------
		Name:<input type="text" name="sname" /> <br/>

try with get too.

write get and post in capital only.

type--  number----------

<html>
	<head>
		<title>Iframe tag - youtube video</title>
	</head>
	<body>
	<form method="get" action="first.html">
		Name:<input type="text" name="sname" /> <br/>
		Roll No : <input type="number" name="rno" /><br>
		<input type="submit" name="send" value="submit" />
		
	
	</form>
	
	</body>
</html>

for proper alignment we can insert form in a table.

if u want border then simply put border="1"

<html>
	<head>
		<title>Iframe tag - youtube video</title>
	</head>
	<body>
	<!--<form method="get" action="first.html">
		Name:<input type="text" name="sname" /> <br/>
		Roll No : <input type="number" name="rno" /><br>
		<input type="submit" name="send" value="submit" />
		
	
	</form>-->
	<form method="GET" action="first.html">
		<table border="1" align="center">
			<tr>
				<td>Name : </td>
				<td><input type="text" name="sname" /></td>
			</tr>
			<tr>
				<td>Roll No : </td>
				<td><input type="number" name="rno" /></td>
			</tr>
			<tr>
				<td colspan="2" align="center"><input type="submit" name="send" value="submit" /></td>
				
			</tr>
			
		</table>
	</form>
	
	</body>
</html>

date type-------- gives calendar-- u can select from calendar or do manually.

email type--

password type---

how to add/upload file-- now when we upload file, enctype is very imp in the form tag.
na d enctype has a default value-- "multipart/form-data"-- this helps u to uplaoad the file.
u can click on it and upload it.

the choose file option allows us to upload only 1 file.
For uploading multiple files-- while choosing files , press contrl and then select.

Next is dropdown list-- for this we have select tag. in the backend 2 means second, 3 means third.

now to select multiple values from dropdown-- by using multiple attr. -- for selecting multiple use ctrl.

then read only and hidden--
with the help of vakue attr , we can show some value and change that value,
but when value is made readonly, it only shows the value, and not change it.

textarea---

cols="25" -- that many alphabets horizontally, rows="5" rows

required-- to make its input mandatory.But we generally donot write require,
bcoz from inspect element, we can double click on required and remove from there and submit form.

<html>
	<head>
		<title>Iframe tag - youtube video</title>
	</head>
	<body>
	<!--<form method="get" action="first.html">
		Name:<input type="text" name="sname" /> <br/>
		Roll No : <input type="number" name="rno" /><br>
		<input type="submit" name="send" value="submit" />
		
	
	</form>-->
	<form method="GET" action="first.html" enctype="multipart/form-data">
		<table align="center">
			<tr>
				<td>Name : </td>
				<td><input type="text" name="sname" /></td>
			</tr>
			<tr>
				<td>Roll No : </td>
				<td><input type="number" name="rno" /></td>
			</tr>
			<tr>
				<td>Date</td>
				<td><input type="date" name="dt" /></td>
			</tr>
			<tr>
				<td>Email</td>
				<td><input type="email" name="email" /></td>
			</tr>
			<tr>
				<td>password</td>
				<td><input type="password" name="spass" /></td>
			</tr>
			<tr>
				<td>upload file</td>
				<td><input type="file" name="file1" /></td>
			</tr>
			<tr>
				<td>upload multiple files</td>
				<td><input type="file" name="file2" multiple /></td>
			</tr>
			<tr>
				<td>select year</td>
				<td>
					<select name="yea">
						<option value="1">First</option>
						<option value="2">Second</option>
						<option value="3">Third</option>
						<option value="4">Fourth</option>
					</select>
				</td>
			</tr>
			<tr>
				<td>select year</td>
				<td>
					<select name="courc" multiple >
						<option value="1">HTML</option>
						<option value="2">CSS</option>
						<option value="3">JS</option>
						<option value="4">Bootstrap</option>
					</select>
				</td>
			</tr>
			<tr>
				<td>Select Gender : </td>
				<td>
					<input type="radio" name="gender" value="Female" >Female
					<input type="radio" name="gender" value="Male" >Male
				</td>
			</tr>
			<tr>
				<td>Select course : </td>
				<td>
					<input type="checkbox" name="course" value="html">HTML
					<input type="checkbox" name="course" value="python">python
					<input type="checkbox" name="course" value="css">CSS
				</td>
			</tr>
			<tr>
				<td>UserId:</td>
				<td><input type="text" name="uid" value="20" readonly />
			</tr>
			<tr>
				<td>UserId:</td>
				<td><input type="hidden" name="hi" value="20" />
			</tr>
			<tr>
				<td>Address</td>
				<td><textarea name="al" cols="25" rows="5"></textarea></td>
			</tr>
			<tr>
				<td colspan="2" align="center"><input type="submit" name="send" value="submit" /></td>
				
			</tr>
			
		</table>
	</form>
	
	</body>
</html>

Now, how to add audios and videos in our web page--
<body>
<audio controls>
<source src="path of audio" type="audio/mp3/mpeg/wav"
</audio>
</body>

i.e.

<html>
	<head>
		<title>HTML</title>
	</head>
	<body>
	   <audio controls>
			<source src="audio1.mpeg" type="audio/mpeg" >
	   </audio>
	</body>
	
</html>

entity-- entities are some reserved characters.
syntax--
&entityname;
&#entitynumber;

google-- entity list-- mdn documnetation list

https://drive.google.com/drive/folders/1alUjkh8ug9eQ6SBbSOJyOMkXTgZ52DhH

4 1:29

	</video>
	   <p> this is &nbsp; &nbsp; &nbsp; paragraph , Rs. 1000 &copy; &lt; &gt; &alt; </p>
	</body>

Now CSS--

inline_css.html

here html is for the structure of the web page
css is for presentation.

types of css--
inline css,
internal css,
external css

inline means u r applying style in the same line of the element.

<html>
	<head>
		<title>HTML</title>
	</head>
	<body>
	  <h1>Headin 1</h1>
	  <p>This is paragraph.</p>	
	  <!-- i want to give red color to h1 tag.
			So property is color and value can be anything, lets
			say red -->
	  <!--- So inline css syntax is- 
	  <open tag style="property:value;">content</closetag> -->
	  <h1 style="color:red;">Heading 1 </h1>
	  <p style="color:green;"> This is paragraph </p>
	</body>
	
</html>

internal css--
In inine css , if we want same property to some code,
then again and again we will write that code.

eg.

 <html>
	<head>
		<title>HTML</title>
	</head>
	<body>
	  <h1>Headin 1</h1>
	  <p>This is paragraph.</p>	
	  <!-- i want to give red color to h1 tag.
			So property is color and value can be anything, lets
			say red -->
	  <!--- So inline css syntax is- 
	  <open tag style="property:value;">content</closetag> -->
	  <h1 style="color:red;">Heading 1 </h1>
	  <p style="color:green;"> This is paragraph </p>
	  <h1 style="color:red;">Heading 2 </h1>
	  <p style="color:green;"> This is paragraph 2 </p>
	  <h1 style="color:red;">Heading 3 </h1>
	  <p style="color:green;"> This is paragraph 3</p>
	  
	  <
	</body>
	
</html>

so, instead of inline css, we will use internal css.

syntax--
add style tag in head section only.
<style>
	selector{
		property1:value;
		property2:value;
		property3:value;
	}
</style>

the selectors can be of different types.
1. tag selector.
If u want to link multiple files,
then in that case, select multiple files, and in that file,
select properties and link this file to other files.

external css--- the file name genrally used is style.css--
here we will style.

.css only means u r applying properties here.


we will apply .css properties on external_css.html

<link rel="stylesheet" href="path of file" >
rel - relation stylesheet is a default value.

so, in style.css--

h1{
color:red;
}

external_css.html--

<html>
	<head>
		<title>Internal CSS</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
	  <h1>Headin 1</h1>
	  <p>This is paragraph.</p>	
	  <h1>Headin 2</h1>
	  <p>This is paragraph 2.</p>	
	  <h1>Headin 3</h1>
	  <p>This is paragraph 3.</p>	
	</body>
	
</html>

--

id selector--

earlier, when we gave style to tag h1,
wherever i used h1, i got red color.

But, if i want different colors for diff headings,
then, u can use id selector as id is unique.

5 43:39

for commenting css /* */

id selector--

#idname{
	property:value;
}


/*
h1{
color:red;
}
*/

#head1{
	color:blue;
}
#head2{
	color:yellow;
}

now head1 and head 2 are id selectors.
h1 is our same element with different properties,
head1 and head2.

<html>
	<head>
		<title>Id Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<h1 id="head1"> id selector </h1>
		<p> We are learning id selector</p>
		
		<h1 id="head2">id selector</h1>
		<p> we are learning id selector</p>
	</body>
	
</html>

now if i want to use blue color for para,
i cant use it bcoz this is for this is for h1.

so, class selector---
now if i want to give same color to my heading and paragraph.
then we will use class selector.
class name will be same in any property.

class selector- diff tag and same property

.classname{
	property:value;
}

Combinators--

1.descendent selector--
div p{
	prpoerty:value;
}

all <p> tags inside div

2. child selector--
only child gets properties.

div>p{
	property:value;
}

3. adjacent sibling-- first para outside div
div+p{
	property:value
}

so, style.css--

/*
h1{
color:red;
}
*/
/*
#head1{
	color:blue;
}
#head2{
	color:yellow;
}
*/

.c1{
	color:pink;
}


.c2{
	background-color:green;
	color:white;
}
/*
div p{
	color:red;
}
*/
/*
div>p{
	color: green;
}
*/
/*
div+p{
	color:pink
}
*/
div~p{
	color:blue
}


combinator_tag.html

<html>
	<head>
		<title>Id Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<div>
			<p> this is 1st para</p>
			<p> this is 2nd para</p>
			<section>
				<p>This is inside parag section</p>
			</section>
			<p> this is 3rd para</p>
			<p> this is 4th para</p>
		</div>
		<p> this is 5th para</p>
		<p> this is 6th para</p>
	</body>
	
</html>

pseudo class selector---
when we hover or click on something , the properties change.

<html>
	<head>
		<title>Pseudo Class Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<div>
			<a href="home.html">Home</a><br>
			<a href="product.html">Product</a><br>
			<a href="about.html">About us</a><br>
			<a href="contact.html">Contact us</a><br>
		</div>
	</body>
	
</html>

lets say when I hover on diff tags , I change the color.

style.css--

pseudo-class{
	prop:val
}

hover property is generally apploied on button.

style.css-

div{
	background-color:black;
}
a:link{
	color:red;
}
#btn{
	background-color:red;
	color:white;
	border:0;
}
#btn:hover{
	background-color:green;
}

Pseudo_class.html--

<html>
	<head>
		<title>Pseudo Class Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<div>
			<a href="home.html">Home</a> &nbsp;&nbsp;&nbsp;
			<a href="product.html">Product</a> &nbsp;&nbsp;&nbsp;
			<a href="about.html">About us</a> &nbsp;&nbsp;&nbsp;
			<a href="contact.html">Contact us</a> <br>
			
		</div>
		<br>
		<button id="btn">click me</button>
	</body>
	
</html>

4. all paragraphs outside div
div~p{

}

-- Universal Selector--

*{
	font-style:italic;
}

<html>
	<head>
		<title>Universal Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<div>
			<p>US</p>
			<p>US</p>
			<p>US</p>
			<p>US</p>
		</div>
		<br>
		<button id="btn">click me</button>
	</body>
	
</html>

-- group selector--


h1,p{
	color:blue;
}

<html>
	<head>
		<title>Group Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<h1>this is heading </h1>
		<p>US</p>
		<p>US</p>
		<h2>group selector</h2>
		<p>US</p>
		<p>US</p>
	</body>
	
</html>

Next is attribute selector--

[type]{
	background-color:yellow;
	color:red;
	
}

<html>
	<head>
		<title>Group Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<h1>this is heading </h1>
		<p>US</p>
		<p>US</p>
		<h2>group selector</h2>
		<p>US</p>
		<p>US</p>
		<form method="POST">
			Enter Name: <input type="text" name="n" /><br>
			<input type="submit" name="send" />
		</form>
	</body>
	
</html>

so weherever we have type attr-- we r getting yellow color.

but if we want to apply to only type text,
then,

[type]{
	background-color:yellow;
	color:red;
	
}

for particular attr color only--

[type="text"]{
	background-color:yellow;
}

Next is color-- u can search for html color codes in google.

p{
	/*color:red;*/
	/*color:rgb(255,255,255);*/
	/*color:rgb(0,0,0);*/
	/*color:rgb(206,206,206);*/
	color:#CE3EE0;
}

h1{
	color:red;
}

<html>
	<head>
		<title>Group Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<h1>Color Try</h1>
		<p>This is colored parag.</p>
	</body>
	
</html>

text property-- 
text-align: left/right/justify/center
text:decoration- underline/ line-through/overline/none

to remove underline from anchor tag--
for the anchor tag a we can write text deco none.


h1{
	text-align:center;
}
p{
	/*text-align:center;*/
	/*text-align:left;*/
	/*text-align:right;*/
	text-align:justify;
	text-decoration:overline;
	text-transform:lowercase;/*uppercase/capitalize*/
	text-indent:100px;
	line-height:25px;
	word-spacing:10px;
	letter-spacing:3px;
	font-weight:normal;/*normal/bold*/
	font-style:italic;/*italic/normal*/
	
}


<html>
	<head>
		<title>Group Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<h1>Color Try</h1>
		<p>This is colored parag.</p>
		
	</body>
	
</html>

now layout -- width and height in % or px.

% is a dynamic layout.
px is static layout.

p{
	width:50%;
	height:500px;
}

<html>
	<head>
		<title>Group Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<h1>Color Try</h1>
		<p>This is colored parag.</p>
		
	</body>
	
</html>

now, border properties--


p{
	width:50%;
	height:20px;
	/*border-style:solid; /*solid/dotted/dashed/ridge*/
	border-color:#cc99ff;
	border-width:4px;
	/*border-radius:15px;*/
	border-bottom-style:solid;
	border-right-style:dashed;
	border-bottom-right-radius:20px;
	
	
 } 
 
 <html>
	<head>
		<title>Group Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>
		<h1>Color Try</h1>
		<p>This is colored parag.</p>
		<p>thidfnm ijdfnm </p>
		
	</body>
	
</html>

style.css--

/*
h1{
color:red;
}
*/
/*
#head1{
	color:blue;
}
#head2{
	color:yellow;
}
*/

.c1{
	color:pink;
}


.c2{
	background-color:green;
	color:white;
}
/*
div p{
	color:red;
}
*/
/*
div>p{
	color: green;
}
*/
/*
div+p{
	color:pink
}
*/
/*
div~p{
	color:blue
}
*/
/*
a:hover{
	color:red;
}
*/
/*
div{
	background-color:black;
}
a:link{
	color:red;
}
#btn{
	background-color:red;
	color:white;
	border:0;
}
#btn:hover{
	background-color:green;
}
*/
/*
*{
	font-style:italic;
}
*/
/*
h1,p{
	color:blue;
}
*/
/* attribute select */


/*
[type]{
	background-color:yellow;
	color:red;
	
}
*/
/*
[type="text"]{
	background-color:yellow;
}
*/
/*
[type="submit"]{
	background-color:yellow;
}

*/
/*
p{
	/*color:red;*/
	/*color:rgb(255,255,255);*/
	/*color:rgb(0,0,0);*/
	/*color:rgb(206,206,206);*/
	/*color:#CE3EE0;
}
h1{
	color:red;
}
body{
	background-color:rgb(123,45,45);
}

*/
/*
h1{
	text-align:center;
}
p{
	/*text-align:center;*/
	/*text-align:left;*/
	/*text-align:right;*//*
	text-align:justify;
	text-decoration:overline;
	text-transform:lowercase;/*uppercase/capitalize*/
	/*text-indent:100px;
	line-height:25px;
	word-spacing:10px;
	letter-spacing:3px;
	font-weight:normal;/*normal/bold*/
	/*font-style:italic;/*italic/normal*/
/*	
}
*/

p{
	width:400px;
	height:300px;
	border-style:ridge; /*solid/dotted/dashed/ridge*/
	border-color:#cc99ff;
	border-width:5px;
	/*border-radius:15px;*/
	/* border-bottom-style:solid; */
	/* border-right-style:dashed; */
	/* border-bottom-right-radius:20px; */
	/*padding:10px;*/
	border-style:ridge;
	border-color:#cc99ff;
	/*box-sizing:border-box;*/
	/*padding : 5px 10px 5px 10px; /*top right bottom left*/
	/*padding : 10px 20px; /* similar to 10px 20px 10px 20 px*/
	/*padding : 10px 15px 20px; /*top {left=right} bottom */
	/*margin:15px;*/
	margin-top:20px;
	
 } 
 
 border_properties.html--

<html>
	<head>
		<title>Group Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>

		<p>This is colored parag.</p>
		
		
	</body>
	
</html>

--

Now I want to add header

Display property--
h1 is a block level element.
block level is an element which blocks
entire width of the browser irrespective of
its content length.

so, display_property.html--

h1{
	 display:inline;
 }
 i{
	 display:block;
 }
 

<html>
	<head>
		<title>Group Selector</title>
		<link rel="stylesheet" href="style.css" >
	</head>
	<body>

		<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, 
		sed do eiusmod tempor incididunt ut labore et dolore magna 
		aliqua. Ut enim ad minim veniam, quis nostrud exercitation 
		ullamco laboris nisi ut aliquip ex ea commodo consequat. 
		Duis aute irure dolor in reprehenderit in voluptate velit 
		esse cillum dolore eu fugiat nulla pariatur. Excepteur sint 
		occaecat cupidatat non proident, sunt in culpa qui officia
		deserunt mollit anim id est laborum.</p>
		
		<h1>Display property</h1>
		<p>This property is used to convert block level
		element to inline level element and
		inline level element to block level.</p>
		<i>italic tag</i>
		<b>this is a bold tag</b>
		
		
	</body>
	
</html>

--

 h1{
	 display:inline-block;
	 border-style:solid;
	 width:700px
 }

now when we write inline, we r unable to change 
width, but when we write inline-block, we can 
change width of block.

ctrl k is the shortcut for commenting everything.

--
Shadow property--

box- shadow- 
10 px -- from the x-axis there wil be shadow upto the area
10pxs.
10 px same from y-axis. +ve y-axis move downwards
5px - blurness i want.
10 px - how much u want to spread ur shadow.
which color u want , from w3 school from color picker

_shadow{
	 width:200px;
	 height:150px;
	 border-style:solid;
	 margin:200px auto; /*from the top bottom 200, and left right auto to bring at center*/
	 text-align:center;
	 padding-top:50px;/*applying padding increase box height so giving box-sizing*/
	 box-sizing:border-box;
	 background-color:black;
	 color:white;/*text- color*/
	 /* now we will apply shadow to this box--*/
	 box-shadow:10px 10px 5px 10px #33adff;
 }
 

          <b>this is a bold tag</b>
		<div class="box_shadow">
			Shadow property
		</div>
		
	</body> 

now transform property---
translate-- 

.box_shadow{
	 width:200px;
	 height:150px;
	 border-style:solid;
	 margin:200px auto; /*from the top bottom 200, and left right auto to bring at center*/
	 text-align:center;
	 padding-top:50px;/*applying padding increase box height so giving box-sizing*/
	 box-sizing:border-box;
	 background-color:black;
	 color:white;/*text- color*/
	 /* now we will apply shadow to this box--*/
	 box-shadow:10px 10px 5px 10px #33adff;
 }
 .box_shadow:hover{
	 transform:translateX(200px);
	 transform:translateY(-200px);
	 transform:translate(200px,200px);
 }

sclae property-- 
scaleX()
scaleY()

 .box_shadow:hover{
	 /* transform:translateX(200px); */
	 /* transform:translateY(-200px); */
	 /* transform:translate(200px,200px); */
	 transform:scaleX(1.5);
	 transform:sclaeY(1.5);
	 transform:scale(2);
 


	 transform:rotate(45deg);
	 transition-property:transform;
	 transition-duration:2s;
	 transition-delay:2s;
 }

h1{
	 font-size:100px;
	 text-shadow:10px 10px 8px #33adff;
 }

---- image


 body{
	 background-image:url('headphone.jpg');
	 background-repeat:no-repeat;
	 background-size:100%;
	 background-attachment:fixed; /*scroll/fixed*/
	 
 }

-- position property to adjust position of element on browser.

selector{
	position:static/fixed/relative/absolute
	top:npx;
	right:npx;
	bottom:npx;
	left:npx;
}

-------------

javascript--
makes web page dynamic,
it is an object oriented programming lang
it is light weighted
it can be executed through browser.
it helps usre to interact with web application
without reloading web page.
with javascript u can do following manipulations--html manipulation, css manipulation, value manipulation,attr manipulation- html manip means dynamic chnage
in html element.

2 types of JS-- internal and external

internal JS-- js is written in the head tag enclosed in script tag.
<script>
	js code
</script>

external js, means we will create external js file and we will link that js file 
to ur file.

9 var dt---

<html>
	<head>
		<title> Internal JS </title>
		<script>
			document.write("Hello World !!");
		</script>
	</head>
	<body>
	</body>
</html>

--
external_js.html--

<html>
	<head>
		<title> External JS </title>
		<script src="main.js" ></script>
	</head>
	<body>
	</body>
</html>

in main.js file--

document.write("Hello World from external js file!!");

Now, normally we create a folder asset in which we move js folder.

now we are at external.js-->which contains asset folder-->
 js folder-->inside which there is main folder.

<script src="asset/js/main.js" ></script>

say no while saving. 
and save both the files again.
--
variables.html

<html>
	<head>
		<title> Variables </title>
		<script >
			var x;
			x=10;
			document.write(x);
		</script>
	</head>
	<body>
	</body>
</html>



--

<html>
	<head>
		<title> Variables </title>
		<script >
			var x;
			x=10;
			y="Eclass";
			document.write(x + "<br>");
			//document.write("x");
			/* variable datatypes--
			1> number  - integer, float number
			2> string
			typeof() returns datatype of variable.
			*/
			document.write("<h1>Datatype of x var is </h1>"+typeof(x));
			document.write("<br>"+y+"<br>");
			document.write("Datatype of x var is "+typeof(y));
			var x,y,add;
			x=11;
			y=2;
			add=x+y;
			document.write("<br>Addition : "+add+"<br>");
			sub=x-y;
			document.write("<br>Subtraction : "+sub+"<br>");
			mod=x%y;
			document.write("<br>Subtraction : "+mod+"<br>");
			exp=x**y;
			document.write("<br>Subtraction : "+exp+"<br>");
			var x,y,z;
			x=prompt("<br>Enter 1st input : ");
			y=prompt("<br>Enter 2nd input : ");
			document.write(x+"<br>");
			//document.write(x);
			document.write("<br>Datatype of x var is "+typeof(x));
			document.write("<br>"+y+"<br>");
			//document.write(x);
			document.write("<br>Datatype of x var is "+typeof(x));
			// prompt func takes input as string.
			// so , string -> int--> parseInt()
			// string -> float--> parseFloat()
			x=parseInt(x);
			y=parseFloat(y);
			z=x+y;
			document.write("<br>"+z+" Addition <br>");
			var x,rem;
			x=parseInt(prompt("Enter any number : "));
			rem=x%2
			if(rem==0){
				document.write(x+" is Even no. ");
			}
			else{
				document.write(x+" is Odd no. ");
			}
		</script>
	</head>
	<body>
	</body>
</html>

9 variable-type 1:27:31

https://drive.google.com/drive/folders/1alUjkh8ug9eQ6SBbSOJyOMkXTgZ52DhH 


<html>
	<head>
		<title> Nested if-else </title>
		<script >
			/*var x,y,z;
			x=60;
			y=40;
			z=20;
			if(x>y){
				if(x>z){
				document.write(x+" is greater");
				}
				else{
				document.write(z+" is greater");
				}
			}
			else{
				if(y>z){
				document.write(y+" is greater");
				}
				else{
				document.write(z+" is greater");
				}
			}
			var x,y,z;
			x=parseInt(prompt("Enter 1st number : "));
			y=parseInt(prompt("Enter 1st number : "));
			z=parseInt(prompt("Enter 1st number : "));
			if(x>y && x>z){
				document.write(x+" is greater")
			}
			if(y>z && y>z){
				document.write(y+" is greater")
			}
			if(z>x && z>y){
				document.write(z+" is greater")
			}
			
			var i;
			i=1;
			while(i<=5){
				document.write("Hello World ! <br>");
				i++;
			}
			
			for(i=1;i<=6;i++){
				document.write("Hello World ! <br>");
			}
			*/
			i=1;
			do{
				r=2*i;
				document.write(r+"<br>");
				i++;
			}while(i<=10);
		</script>
	</head>
	<body>
	</body>
</html>

fuctions in js--

<html>
	<head>
		<title> Nested if-else </title>
		<script >
		function greet(){
			document.write("Hello world !! Good Evening !!");
		}
		greet();
		function addition(x,y){
			z=x+y;
			document.write("Addition is : "+z+"<br>");
		}
		addition(10,20);
		addition(15,3);
		function totalMarks(m1,m2,m3){
			t=m1+m2+m3;
			return t;
		}
		r=totalMarks(80,98,67);
		per=r/3;
		document.write("Percentage: "+per);
		
		</script>
	</head>
	<body>
	</body>
</html>

anonymous func--

<html>
	<head>
		<title> Anonymous func </title>
		<script >
			x=function(a,b){
			c=a+b;
			document.write("Anonymous func addition : "+c);
			}
			x(50,60);
		
		</script>
	</head>
	<body>
	</body>
</html>

--

consuming API:--
fetch()
device a currency converter--

API-- Application Programming Interface--
It refers to some functionality devised over web
and we can use it across cross platform.
fetch API- allows web browsers to make
HTTP req to web server.

fetch(): it is used to req data from server.
This req can be any API , return some data
in either json/xml format,
- this method takes 1 parameter 
i.e. url req and returns a promise

where, 

promise is a mechanism to handle
asynchronous operations in js.
it is async because we donot know how much
time it will take to reply, secs or hrs..

let or var kyword is to define the variable.
result is just a var name.
fetch()-- we pass url to this methiod.
result.then(res=>res.json())-- this is used to
access json format data.
then(d=> in this d we will get everything.
console.log(d)-- bcoz we r going to get the data
in console only. 
or if u want to write in the web page, then
document.write(d+"<br>") -- but this will be in the 
form of the object, so data will not be visible to u.



https://jsonplaceholder.typicode.com/todos/1-- readymade data
is available in this url, which we will fetch.

<html>
	<head>
		<title> Fetch func </title>
		<script>
		let=result=fetch("https://jsonplaceholder.typicode.com/todos/1");
		result.then(res=>res.json()).then(d=>{
		console.log(d);
		document.write(d+"<br>");
		})
		</script>
		
	</head>
	<body>
	</body>
</html>

now http://localhost/webdesign_7/fetch_demo.html--
im getting object object as o/p.
So, right click-->inspect-->console-->
click on object and u can see the fetched data.

Then there is todos/2 also.  i.e.

https://jsonplaceholder.typicode.com/todos/2

and see--

10 functions--2:18 

currency_converter.html--
for,js code--
to fetch all the values from html doc, we use
document.getElementbyId
we can use const, var and even let to declare variable.
to, from etc are all objects.

Then we will add addevent listener. i.e. when the
button will be clicked, then we will call the function--

convert.addEventListner where convert is the button id.
 inside func-- we r fetrching values from from , to,convert etc objects.

in the fetch() ' or " quotes r not there, instead ` symbol is there.

fetch(`https://api.exchangerate-api.com/v4/latest/${fromcurrency}`)
				.then(res=>{return res.json();
				})
from cuurency - whatever currency u have selected, inr, usd, etc.

10 functions 2:41:09



<html>
	<head>
		<title>Currency converter</title>
	</head>
	<body>	
		<h1>My currency converter</h1>
		<form>
		
		<label for="from" >From:</label>
		<select id="from">
			<option value="USD">USD</option>
			<option value="INR">INR</option>
			<option value="EUR">EUR</option>
		
		</select>
		<label for="to" >To:</label>
		<select id="to">
			<option value="USD">USD</option>
			<option value="INR">INR</option>
			<option value="EUR">EUR</option>
		
		</select>
		<br><br>
		
		<label for="amount">Amount to convert:</label>
		<input type="text" id="amount" /> <br>
		<button type="button" id="convert">Convert</button>		
		</form>
		<p id="result"></p>
	
	<script>
		const from=document.getElementById("from");
		const to=document.getElementById("to");
		const amount=document.getElementById("amount");
		const convert=document.getElementById("convert");
		const result=document.getElementById("result");
		
		convert.addEventListener("click",function(){
				let fromcurrency=from.value;   //objectname.value
				let tocurrency=to.value;
				let amt=amount.value;   //1000
				
				fetch(`https://api.exchangerate-api.com/v4/latest/${fromcurrency}`)
				.then(res=>{return res.json();
				}).then(data=>{
					let rate=data.rates[tocurrency];
					let total=rate*amt;					
					result.innerHTML="Total is:"+total;
				})
		});
		
	</script>
	
	</body>
</html>


again repeating the logic of currency converter


currency Converter--

In script tag-- to get all the elements from the form,
we use getElementByID(),
for defining variables we can use var, let, const.

By writing const from=document.getElementById("from");
we r not only creating var, but the object of getElementID().
with the help of this, we can change any html content.

Then we created 1 event listener function,
when we click on convert button,
it will call the func.
inside this func, with the help of object
from keyword, to keyword,
we will fetch the value by using value().
we will fetch from value , to value and amount value.

The api is already writeen we will use it.
Use ` instead of ' or ".

let rate=data.rates[tocurrency]; // -------it will give rate of 1 currency
so multiply by amt.

result.innerHTML="Total is:"+total; //--------- since we r going to print it in our paragraph with id = result, 
so we r going to change content of the result. 1st its a blank content in the paragraph, then we r going to put some value in the paragraph, using id result.

Now in js, if u want to check error, right click-->inspect--> in console we get error.

<html>
	<head>
		<title>Currency converter</title>
	</head>
	<body>	
		<h1>My currency converter</h1>
		<form>
		
		<label for="from" >From:</label>
		<select id="from">
			<option value="USD">USD</option>
			<option value="INR">INR</option>
			<option value="EUR">EUR</option>
		
		</select>
		<label for="to" >To:</label>
		<select id="to">
			<option value="USD">USD</option>
			<option value="INR">INR</option>
			<option value="EUR">EUR</option>
		
		</select>
		<br><br>
		
		<label for="amount">Amount to convert:</label>
		<input type="text" id="amount" /> <br>
		<button type="button" id="convert">Convert</button>		
		</form>
		<p id="result"></p>
	
	<script>
		const from=document.getElementById("from");
		const to=document.getElementById("to");
		const amount=document.getElementById("amount");
		const convert=document.getElementById("convert");
		const result=document.getElementById("result");
		
		convert.addEventListener("click",function(){
				let fromcurrency=from.value;   //objectname.value
				let tocurrency=to.value;
				let amt=amount.value;   //1000
				
				fetch(`https://api.exchangerate-api.com/v4/latest/${fromcurrency}`)
				.then(res=>{return res.json();
				}).then(data=>{
					let rate=data.rates[tocurrency]; 
					let total=rate*amt;				
					result.innerHTML="Total is:"+total; 
				})
		});
		
	</script>
	
	</body>
</html>

-- Manipulations--

there are 4 types of manipulations.
1. html manipulation
css manipulation
value manipulation
attr manipulation.
In order to do any manipulation
on an HTML element, we need to access that element
in javascript by creating its object in javascript.
following r the functs or methods with
the help of which we can create object of that element.
1. document.getElementByID('idname');
2. document.getElementByTagname('tagname'); 
3. document.getElementByClassName('classname');

onclick="" is the event handler.
i.e. user activity on the browser.
We have different event handlers like on double click,
on mouse hover etc.

So what will happen onclick-- a func html_mani()
will be called.
Now this func we will create in script tag.

<html>
	<head>
		<title>Manipulations</title>
		<script>
			function html_mani(){
				alert("Hello");
		}
		</script>
	</head>
	<body>
		<h1>HTML manipulation</h1>
		<button id="btn" onclick="html_mani()">click me</button>
	</body>
</html>

event-- user activity
event-- eventhandlers
click-- onclick
double click-- ondbclick
hover-- onmousehover

by x=document.getElementById('hid');-- we got the object.
But what we want is whats inside object.
so to get the element--> objectname.innerHTML

<html>
	<head>
		<title>Manipulations</title>
		<script>
			function html_mani(){
				//alert("Hello");
				var x;
				x=document.getElementById('hid');
				//document.write(typeof(x));
				alert(x.innerHTML);
		}
		</script>
	</head>
	<body>
		<h1 id="hid">HTML manipulation</h1>
		<button id="btn" onclick="html_mani()">click me</button>
	</body>
</html>

So we r able to access the content of hid .
which is HTML manipulations.
And once we can access the content, u can change that content also.

So, we did getElement now we want to do 
set Element.
set element====>objectname.innerHTML="new content"

<html>
	<head>
		<title>Manipulations</title>
		<script>
			function html_mani(){
				//alert("Hello");
				var x;
				x=document.getElementById('hid');
				//document.write(typeof(x));
				//alert(x.innerHTML);
				x.innerHTML="new location";
		}
		</script>
	</head>
	<body>
		<h1 id="hid">HTML manipulation</h1>
		<button id="btn" onclick="html_mani()">click me</button>
	</body>
</html>

this is dynamic manipulation.

now-- css manipulation--

in css manipulation we try to 
change the style. i.e. how to get and set the properties.
Now their are many properties so take
help from documentation.

to get and set the css property--
object.style.property_name

<html>
	<head>
		<title>CSS Manipulations</title>
		<script>
			function css_mani(){
				//alert("Hello");
				var x;
				x=document.getElementById("hid");
				//alert(x.style.color+" "+x.style.backgroundColor);
				x.style.color="yellow";
				x.style.backgroundColor="red";
				}
			
		</script>
	</head>
	<body>
		<h1 id="hid" style="color:red; background-color:green">CSS manipulation</h1>
		<button id="btn" onclick="css_mani()">click me</button>
	</body>
</html>

value manipulation--
here, to get the value-- objectname.value
to set the value-- objectname.value="new value";

<html>
	<head>
		<title>Value Manipulations</title>
		<script>
				function value_mani(){
					//alert("hello");
					var x=document.getElementById('cadd');
					alert(x.value);
				}
		</script>
	</head>
	<body>
		Enter address:<textarea name="cadd" id="cadd"></textarea>
		<br>
		<input type="checkbox" onclick="value_mani()" />
		click this box if above addrr is same as residential addr.<br>
		Residential address:<textarea naem="radd" id="radd"></textarea>
	</body>
</html>

now in the browser-- refresh and put some value
in text area of addr , click check box,
u will get alert.

so finally to get addr into residential addr--

<html>
	<head>
		<title>Value Manipulations</title>
		<script>
				function value_mani(){
					//alert("hello");
					var x=document.getElementById('cadd');
					//alert(x.value);
					var x=document.getElementById('cadd');
					var y=document.getElementById('radd');
					y.value=x.value;
				}
		</script>
	</head>
	<body>
		Enter address:<textarea name="cadd" id="cadd"></textarea>
		<br>
		<input type="checkbox" onclick="value_mani()" />
		click this box if above addrr is same as residential addr.<br>
		Residential address:<textarea naem="radd" id="radd"></textarea>
	</body>
</html>

Next attr manipulation---

<html>
	<head>
		<title>Attribute Manipulations</title>
		<script>
				function hideshow(){
					alert("hello");
				}
		</script>
	</head>
	<body>
		enter password:<input type="password" id="passid" name="upass"/>
		<button id="btn" onclick="hideshow()">show</button>
		
	</body>
</html>

now currently the type attr of passid is password.
thats why its not visible.
if i will make it to text , then it will be visible.

to get attr---> objname.getAttribute('type'); 
where type is the attribute .

var x=document.getElementById("passid");
var y=x.getAttribute('type');

next we will create attr of this button too,
bcoz once the pwd is shown, lets say i want to change the button name to hide--

<html>
	<head>
		<title>Attribute Manipulations</title>
		<script>
				function hideshow(){
					//alert("hello");
					var x=document.getElementById("passid");
					var y=x.getAttribute('type');
					if(y=='password'){
						x.setAttribute('type','text');
					}
					else{
						x.setAttribute('type','password');
					}
				}
		</script>
	</head>
	<body>
		enter password:<input type="password" id="passid" name="upass"/>
		<button id="btn" onclick="hideshow()">show</button>
		
	</body>
</html>

same prog with button name change--

<html>
	<head>
		<title>Attribute Manipulations</title>
		<script>
				function hideshow(){
					//alert("hello");
					var x=document.getElementById("passid");
					var y=x.getAttribute('type');
					var z=document.getElementById('btn');
					
					if(y=='password'){
						x.setAttribute('type','text');
						z.innerHTML="hide";
					}
					else{
						x.setAttribute('type','password');
						z.innerHTML="show";
					}
				}
		</script>
	</head>
	<body>
		enter password:<input type="password" id="passid" name="upass"/>
		<button id="btn" onclick="hideshow()">show</button>
		
	</body>
</html>

Now to set aatr--> objectname.setAttribute('attributename',value);

now in a new file--
here we will need 2 images for eye open and eye close images.

search-- eye open image to show and hide

Now instead of the button , i want to click on the image.

for alignment and everythoing u will need css.

<html>
	<head>
		<title>Attribute Manipulations</title>
		<script>
				function hideshow(){
					//alert("hello");
					var x=document.getElementById("passid");
					var y=x.getAttribute('type');
					var z=document.getElementById('imgid');
					
					if(y=='password'){
						x.setAttribute('type','text');
						z.setAttribute('src','asset/images/eye_close.jpg');
					}
					else{
						x.setAttribute('type','password');
						z.setAttribute('src','asset/images/eye_open.jpg');
					}
				}
		</script>
	</head>
	<body>
		enter password:<input type="password" id="passid" name="upass"/>
		<img src="asset/images/eye_open.jpg" onclick="hideshow()" id="imgid" alt="" width="20px" height="20px" />
		
	</body>
</html>

---
BK sir--

size:
static and dynamic

heading tag is static <h1> to <h6>

static--
<h1 align="center/right/left">

font tag--
<h1><font>Font Tag</font></h1>

text formatting tags--
<b>
<i>
<u>
<p>
<br>-- break -- non closable tag
<hr>-- horizontal row -- non closable tag
<del>
<mark>-- for highlighting
<sub>
<sup>

<hr color="red" size="5"><hr>-- size is in pixels.

&nbsp;-- no break space
&emsp;-- 3 spaces - emphasis space

<img src="nat.jpg" height="50" width="50"></img>
-- here height and width are in pxs. for % we will have 
to write 50%.

so,
<body bgcolor="blue">
<img src="nat.jpg" height="50%" width="49%" alt="Img not found"></img> -- if image is not found then alt msg will be given.
<img src="nat.jpg" height="50%" width="49%" hspace="11"></img>
<img src="nat.jpg" height="50%" width="49%" vspace="11"></img>
<img src="nat.jpg" height="50" width="50" hspace="11" vspace="11"></img>

comments
<!--
-->

links--
<a href="">
a - anchor
href - hyper link ref

<a href="https://www.facebook.com">Facebook</a>

table design--
<table border="" height="" width="" cellspacing="" cellpading="">
<tr>-- table row
for col-- 
<th> table heading is bold
<td rowspan="" colspan=""> - table data not bold


https://drive.google.com/drive/folders/1lTYca8Y6SsDT8gd3Ima-feIvMQqMpZEL
frameset design


Jquery---

url jquery download.- click download the compressed production
and press ctrl A ctrl C and paste in a notepad++ file with extension jq.js

Now in the same folder where jq.js is saved--

jqtest.html---

<head>
	<script src="jq.js"></script>
	<script>
		$(document).ready(function()
		{ 
			$('#hide').click(function()
			{
				$('#mydiv1').hide(4000);
			});
			$('#show').click(function()
			{
				$('#mydiv1').show(4000);
			});
			$('#toggle').mouseover(function()
			{
				$('#mydiv1').toggle(4000);
			});
			$('#mydiv2').mouseover(function()
			{
				$('#mydiv2').css('background','black');
			});
			$('#mydiv2').mouseout(function()
			{
				$('#mydiv2').css('background','orange');
			});
			$('#btn').click(function(){
				var b=$('#btn');
				var pass=$('#pwd');
				var ptype=pass.attr('type');
				if(ptype=='password')
				{ pass.attr('type','text');
				b.attr('value','Hide');
				}
				else
				{ pass.attr('type','password');
				  b.attr('value','Show');
				}
			});
		});
	</script>
</head>
<input type="submit" value="Show" id="show">
<input type="submit" value="Hide" id="hide">
<input type="submit" value="Toggle" id="toggle">

<div id="mydiv1" style="height:100;width:100;background:red;"></div>

<div id="mydiv2" style="height:100;width:100;background:green;"></div>

<input type="password" id="pwd">
<input type="submit" id="btn" value="Show">

write this file

PhP---

<form method="post">
Enter Age<input type="text" name="age">
<input type="submit" value="Show">
<form>

<?php
$age=@$_POST['age'];
if($age>=18)
{
	echo "Eligible";
}
else
{
	echo "Not eligible";
}
?>

--

<form method="post">
1st No. <input type="text" name="n1"><br><br>
2nd No. <input type="text" name="n2"><br><br>
Choice
<select name="choice">
	<option>+</option>
	<option>-</option>
	<option>*</option>
	<option>/</option>
</select><br><br>

<input type="submit" value="Show Result"><br><br>
Answer<input type="text">
</form>

<?php
$a=@$_POST['n1'];
$b=@$_POST['n2'];

$choice=$_POST['choice'];
if($choice=="+")
{
	$c=$a+$b;
}
else if($choice=="-"){
	$c=$a-$b;
	
}
else if($choice=="*"){
	$c=$a*$b;
}
else
{
	$c=$a/$b;
}
echo $c;
?>

45:00
https://drive.google.com/drive/folders/1lh1ZZr4FnuROABSGNl6pBOUW_sG2BAXD


-------------

Login with session----

PHP Project--

save_enquiry.php


to connect DB with PHP----

1. Connection--
$conn=mysqli_connect('host','username','password','db')

#---------------------------------------------------------
==========================================================

Web sites were static files,html pages, grphics and various other files.
A web app it is dynamic.
When a web appl prog runs on a server, it might not be containing proper html page.
that page might be a java apli, it might be a python appli,
So these applications are executed in the server and in the response,
these pages are going to generate your html page,
and this html page will be sent back to ur client.

Ur client, that is ur browser in response,
is always going to get an html page only.

Sometimes, when we r sending a req from client to server, we
might also send some data, so server will also read the data 
and tries to figure out reponse based on given data.

In web applications -- client sends a req,
req is handed to a web server.
Inside a web server there is an application which is always running.
the name of this appli  is web container.
This web container contains objects of all the servlets
that we are going to create which the user will be requesting.

That is the user req servelet, the servelet generates reponse,

Now every req that comes to a web container
is treated as a thread. So the amount of load coming on the processor reduces,
And its not going to create a thread because it has a thread pool,

Servlets--
it runs within web container. In our case it is,
Java Platform Enterprise Edition.
The web container implements Application Programming Interface.

Everything related to servelet is controlled by a web container.
i.e. creating objects of the servelet,calling method on the servelet,
giving back the response from the servelet,
everything is done by a web container.

So we as a programmer will only create a servelt.
We will not create new instance of servelet,
we will not call any method of the servelet,
So web container performs initial processing,
and selects the intended servelet to handle the req.
It controls the entire lifecycle of servelet.
browser send http request to ur web server,
web server gives it to web container,
Now based on the url, web container search for the
servelet that u r trying to req,
if it finds that servelt,
it tries to process that servelet,
handover the ersponse back, the response mostly will be html page.
which web container hands over to web server and which gives response to a client.



Based on the url,web con







requirement--
tomcat server installation -- donot install native one-- Tomcat 9.0.87 Released-- download-- binary distribution-- for core-- zip file-- extract-
-- start eclipse ide-- select workspace-- now first we need to add tomcat server and keep it ready--
so, windows-->show view-->servers--> close welcome window--->in the below part where output comes--> u can see servers
now click on the link no servers are available. Click this link to creATE new server--> in the dialog box click on apache server-->
--> the version that we r working is 9-->next-->
path where apache is installed, select that folder
i.e. D:\learning\apache-tomcat-9.0.87

now to start the server-- right click on Tomcat v9.0 Server at localhost[Stopped, Republish]-- start

server is active now, and within server web container is also active.

Now to test if we can reach our server , we will do little test--
now we r performing this activity on localhost only.
apache tomcat listens on server 8080--

So on the browser , write http://localhost:8080/

we r getting error page sent by apache tomcat.

error is ther becoz it doesnt know what to do on /.

now, going back to ide, double click on link--
and overview page will open related to server--

in that u have server location-- > click on use tomcat installation
--> press ctrl+s-- i.e. save it--> and restart server

now refresh http://localhost:8080/-- entire homepage is set.

now, creating 1st project-- file-->new-->dynamic web project-->
project name-- FirstApp-->finish

if u will expand this folder u will get required libraries.

for us the most important is firstapp->java resources-> src/main/java
All my servelet files will be inside it.
the same path we have in firstapp->src->main->java-- all the java files
will be part of this folder, all html files will be
part of webapp.

In order to run this application-->right click on FirstApp-->
-->run as server becoz i dont want to run this application
as standalone. I want to run it on the server.-->dialogue box-->
choose an existing server--see localhost written there--->tomcat v9.0-- started
-- click always use this server -->finish-->restart now-->ok

so we uploaded our entire project on server now.
see the url--

http://localhost:8080/FirstApp/


Now u can goto preferences--->u can even change browser-->
just search web browser--> use external web browser--> chrome
-->apply and close-->now run firstapp-> it will open on the chrome browser

Now we will design homepage--

homepage is page for url /

now see deployment descriptor firstapp-->
welcome pages-->
now the entire lifecycle of web server, we r not going to 
control it. So we need to provide some settings to my
web container that are related to application so that 
it knows what is to be done with this project.

for eg our home page if we r giving as /,
so which page is to be opened under which servlet,
that complete mapping we will be doing under
deployment descriptor, everything which data will go.

This deployment descriptor file is an xml file.
The name of this file is web.xml

Deployment Descriptor is XML file used by web container to define servlets match up with which URLs. It will also specify the landing page for the root of the application

Now to add the deployment descriptor file--
right click on first app-->java ee tools-->generate deployment descrptor stub--see under wen-inf folder

this is the xml file we need.

Now when u open this web.xml file-- below there are 2 tabs--
design and source

now right click web.xml-->open with generic text editor

Any 1 of the files present here can be your homepage.

So lets say index.html--
so how to add html file within ur project--

right click on project-->new html file--> Name it index.html

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
<h3>Welcome to first web application</h3>
</body>
</html>

save it and now run ur project

--
now lets say if I delete index.html file
right click on source to create new html file,
name it default.html

this is also my welcome file,

I can even create my own html welcome file.

from web.xml u can delete <welcome-file> part
and write--

home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
</body>
</html>


web.xml is like--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>FirstApp</display-name>
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
</web-app>


now those who have installed eclipse java ee they donot need to do this otherwise-- search eclipse java ee on browser-- and install windowsx86

Tomserver is an application server.




Now in eclipse create a new workspace-- aj_try-- once it is launched u will see welcome msg with eclipse ide for enterprise java and web developers

---

now understanding http --

goto browser-->wikipedia india-->search-->right click inspect-->network-->name---> see request url--> request method is get-->
scroll down and see the response, accept (in accept it tells what all pages it can accept, so it can accept https)

now going to response-- the entire html page is sent back as response.

so while sending a request we follow a http protocol which we can see under headers, also remote addr-- addr of the m/c is going to server m/c



---

Deployment Descriptor is XML file used by web container to define servlets match up with which URLs. It will also specify the landing page for the root of the application

javax.servlet ===> package that contains the interfaces and the classes required for implementing the Servlet

javax.servlet.http ===> package that contains interfaces and the class required to handle the HTTP request and response

Ways to Create a Servlet:
Create a normal java, and then:

1. implements Servlet interface: parent interface of any Servlet class

2. extends GenericServlet class: abstract class that implements the Servlet interface. Only one method is declared abstract in this class and that is service() method

3. extends HttpServlet class



So now, come back on FirstApp-->right click-->new--->normal java class


package com.itvedant;

class name-- FirstServlet

it will not contain main method.

package com.itvedant;

import javax.servlet.Servlet;

public class FirstServlet implements Servlet{
 
}

now we r getting error becoz Servlet is an interface, we need to override methods.
So, right click on the error and override all the methods.

package com.itvedant;

import java.io.IOException;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class FirstServlet implements Servlet{

	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ServletConfig getServletConfig() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void init(ServletConfig arg0) throws ServletException {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {
		// TODO Auto-generated method stub
		
	}
 
}

Now along with this we will understand lifecycle of servlet

------------------------------------------------
Life Cycle of the Servlet -- the compilation of the code is done by in-built jdk compiler only.
So this step creates .class file and then lifecycle starts-- i.e.


1. Load servlet class ===> load the class file of the servlet in the web container
2. Create Servlet class instance ===> Web container will create the instance/object of the servlet class, only one object of the servlet will be created
3. Call init() method ===> web container will call the init() method defined in the servlet class, this method is called only once.
4. Call service() method ===> web container will call the service() method only when someone requests for the servlet. This method will be called for every request on the servlet. This method will contain the code for the response generation.
5. Call destroy() method ===> web container will call destroy() method when the instance/object of the servlet class is destroyed.

So when we override Servlet method, in the above code , 3 methods got overridden, init , service and destroy method.


package com.itvedant;

import java.io.IOException;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class FirstServlet implements Servlet{

	@Override
	public void destroy() {
		// TODO Auto-generated method stub
		System.out.println("Destroy() method called");
		
	}

	@Override
	public ServletConfig getServletConfig() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void init(ServletConfig arg0) throws ServletException {
		// TODO Auto-generated method stub
		System.out.println("Init() Method called");
		
	}

	@Override
	public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Service() method called");
		
	}
 
}


now if we want our servlet to be executed-- in order to map the req to the servlet,
we need to map the Servlet Class with some url using--
1. web.xml
2. annotation 

i.e.
In order to request the Servlet we need to map the Servlet class with the some URL using:

1. web.xml

2. annotation

So in web.xml file, we will add some codes--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>FirstApp</display-name>
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
  <servlet>
	<servlet-name>First</servlet-name>  -------------------------- this name is not restricted to servlet name. It can be anything
	<servlet-class>com.itvedant.FirstServlet</servlet-class> ------ this is restircted. It can be exact path only.
  </servlet>
  <servlet-mapping>
	<servlet-name>First</servlet-name>
	<url-pattern>/first</url-pattern>
  </servlet-mapping>
</web-app>

now right click on firstapp, run as server--
in the output we will see init() called, service() called

http://localhost:8080/FirstApp/first

we will not get any output becoz we have not get 

now as many times will click our url, service() gets executed

Now goto server tab from prompt-- right click-- clean-- restart-- now when we clean our server destroy() gets called.

Now if u want an html response-- in FirstServlet.java

	
	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Service() method called");
		res.setContentType("text/html");
		PrintWriter out = res.getWriter();
		out.print("First Servlet");
		
	}
 
now http://localhost:8080/FirstApp/first -- o/p first servlet

out.print("<h3 style=color:green;> First Servlet</h3>");--- we can make following changes.

http://localhost:8080/FirstApp/first----- see the o/p. Internally it is creating this html page.



---
Now generic servlet class-- servlet interface is the parent interface of any servlet class.
Now when we r implementing servlet class it is forcing us to overwrite all the servlet methods. What if
i dont want to overwrite , then its not possible using only Servlet interface.

So we use GenericServlet class.

extends GenericServlet class: abstract class that implements the Servlet interface. 
Only one method is declared abstract in this class and that is service() method

So creating new java class under same pkg--

Now itis not going to implement my interface instead it is going to extend my GenericServlet class.

it forces u to override only service().

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.GenericServlet;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class SecondServlet extends GenericServlet{

	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		res.setContentType("text/html");
		PrintWriter out = res.getWriter();
		out.print("<h4>Servlet using GenericServlet Class</h4>");
		}

}


now we will do url mapping--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>FirstApp</display-name>
  <welcome-file-list>
    <welcome-file>home.html</welcome-file>
  </welcome-file-list>
  <servlet>
	<servlet-name>First</servlet-name>
	<servlet-class>com.itvedant.FirstServlet</servlet-class>
  </servlet>
  <servlet-mapping>
	<servlet-name>First</servlet-name>
	<url-pattern>/first</url-pattern>
  </servlet-mapping>
  <servlet>
	<servlet-name>Second</servlet-name>
	<servlet-class>com.itvedant.SecondServlet</servlet-class>
  </servlet>
  <servlet-mapping>
	<servlet-name>Second</servlet-name>
	<url-pattern>/second</url-pattern>
  </servlet-mapping>
	
  
</web-app>

http://localhost:8080/FirstApp/second--

Now creating anchor tab for first and second in home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
</body>
</html>



----------------------------------------------

3. extends HttpServlet class: this class contains the method for handling each HTTP request separately 
eg. for post request it has doPost() method
for get request it has doGet() method
Ther are many diifer types of http servlet requests.http get, http post, delte, update reqs
Now all these methods are categorized by service(). There is no categorization.



HTTP Get and Post

HTTP GET

1. Length restriction ===> limited
2. Retrieve the data from the URL (header part of the URL)
3. Visible to everyone
4. Not secure
5. Can be bookmarked

HTTP POST

1. No restriction on the length
2. Retrieve the data from the request body
3. Since the data is part of request body, data is not visible to everyone
4. More secure and is encrepted
5. Cannot be bookmarked

So now in our home page, we will create 1 form-- home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
	<form action="first" method="get">
	Name:
	<input type="text" name="name"/>
	<input type="submit" value="OK"/>
	
	
	</form>
</body>
</html>

and firstServlet.html

only change in service() rest all same--

	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		// TODO Auto-generated method stub
		System.out.println("Service() method called");
		res.setContentType("text/html");
		PrintWriter out = res.getWriter();
		out.print("<h3 style=color:green;> First Servlet</h3>");
		out.print("<h4>Servlet using Servlet Interface</h4>");
		
	}

run as server--

If i will put name and click ok-- req is going to 1st servlet.

now if we will change our url in home.html to second then it will goto our second servlet.


<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
	<form action="second" method="get"> ---------------- change this to second
	Name:
	<input type="text" name="name"/>
	<input type="submit" value="OK"/>
	
	
	</form>
</body>
</html>

refresh url-- and put name.

now irrespective of <form action="second" method="get"> get or post same method will be called.

in the get we will see data going through url but in post we will not.

But many a times we will have a scenario where for get req we want to do some task, for post some.
Currently service() is only handling.

So we have a 3rd type of servlet-- the http servlet class contains a method for handling each type
of servlet req. 

so we have extends HttpServlet class: this class contains the method for handling each HTTP request separately 
eg. for post request it has doPost() method
for get request it has doGet() method

so here 1st the req will come to service method only but then req will be transffered based on the req to 
diff methods.

So create new servlet class ThirdServlet


1st doget()-- it gets 2 parameters.

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ThirdServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			out.print("<h4> Servlet using Http Servlet Class </h4>");
			out.print("<h5>Get Method</h5>");
		
		
		
	}

}




now we r going map in web.xml --

 <servlet>
	<servlet-name>Third</servlet-name>
	<servlet-class>com.itvedant.ThirdServlet</servlet-class>
  </servlet>
  <servlet-mapping>
	<servlet-name>Third</servlet-name>
	<url-pattern>/third</url-pattern>
  </servlet-mapping>

--
now in home.html--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h2 style="color:blue;">Home Page</h2>
	<a href="first"> Go to First Servlet</a>
	<br/>
	<a href="second">Go to Second Servlet</a>
	<form action="third" method="get"> ---------------------
	Name:
	<input type="text" name="name"/>
	<input type="submit" value="OK"/>
	
	
	</form>
</body>
</html>

--

what if it changes to post method--

lets say if in home.html we change it to post(), then the req will goto service() and after that it will give error

So if i want to handle post method also, then-- add in ThirdServlet.java


	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			out.print("<h4> Servlet using Http Servlet Class </h4>");
			out.print("<h5>Post Method</h5>");
		
		
		
	}

refresh browser and see.

--

Servlet part 2--

Servlte is a normal java class and to make a java class
act like a servlet class we need to either implement
an interface called servlet interface which has methods like init, destroy service.
There are 2 more methods which are part of this but most imp are these 3 only.
Service method handles any type of the request,
that will be coming from the client. 
so when the req reach the server, the server handover this req to web container,
the web container is going to call the service().

The no. of instance of 1 servelet class that can exist at 1 time is only 1.
So, even if it is 100 req , all these req will be, handled by a single
servlet instance.

So the .java file is created, which is compiled
as a .class file, this will be handed over to web
container, where the life cycle of the servlet class
is controlled by the web container.
---

So now we will restructure home.html nicely--

<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
<style>
	td{
	 padding:10px;
	}

</style>
</head>
<body>
		<form action="third" method="get">
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" name="name"/></td>
			</tr>
			<tr>
				<td>Marks:</td>
				<td><input type="number" name="marks"/></td>
			</tr>
			<tr>
				<td>Color:</td>
				<td>
					<select name="color">
						<option value="none">.....</option>
						<option>Red</option>
						<option>Blue</option>
						<option>Green</option>
						<option>Pink</option>
						<option>Purple</option>
						<option>Grey</option>
						<option>Violet</option>
						<option>Indigo</option>
					</select>
				</td>
			</tr>
			<tr>
				<td><input type="submit" value="OK"/></td>
				<td><input type="reset"/></td>
			</tr>
		</table>
	</form>
</body>
</html>

now run app-- go to browser-- submit some values-- all the values are going in the url--
sO THE DATA Is going in the form of a key value pair.
So whatever we r sending in the url is going in the form of a req.
i.e. the name of the field will remain same. But the value will vary.

So next we will read tis value and present that value.

So next what we r going to do is in the dopost method we will call doGet().

So we will sent content response text as html.
and we will generate the response by creating the out object . These 2 steps we have alredy done.

So now in ThirdServlet.java--


package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ThirdServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			String name = req.getParameter("name");
			String marks = req.getParameter("marks");
			String color = req.getParameter("color");
		
			out.print("Hello, "+name);
			out.print("<br/>You have scored : "+marks);
		
	}
	
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		doGet(req,resp);
		
		
		
	}
}


run--- put values in browser


Now lets say I want to present this entire output as some color in the browser,
So whatever color is selected, 

so make following changes--

			out.print("<p style='color:" + color + "';>");			
			out.print("Hello, "+name);
			out.print("<br/>You have scored : "+marks);			
			out.print("</p>");
		
Now lets say we want to do some calc on this amrks value,
lets suppose we want to divide marks by 500 to calc what is the aggregate.
For this marks value has to be in proper foramt first and not in String type.

getParameter() returns value in Stirng form.We will do typecasting. thirdservlet.java


	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		resp.setContentType("text/html");
		
			PrintWriter out =resp.getWriter();
			String name = req.getParameter("name");
			float marks = Float.parseFloat(req.getParameter("marks"));
			String color = req.getParameter("color");
			float aggregate = (marks/500)*100;
			
			out.print("<p style='color:" + color + "';>");			
			out.print("Hello, "+name);
			out.print("<br/>You have scored : "+aggregate + "%");			
			out.print("</p>");
		
	}


--

Now lets say I don't want to send empty string or missing value.
And if value is not sent the eroor msg should come

So we will not create complete form by using html page, instead by HttpServlet.

We can setup our servlet as homepage.

So we will create a new servlet--  So now we will see validation part.

new-->dynamic web project-->project name-->ValidationApp

now, right click validation app->new ->java class->package-- com.itvedant , file name-- HomeServlet

package com.itvedant;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HomeServlet extends HttpServlet{
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		super.doGet(req, resp);
	}
	
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(req, resp);
	}
}


this is waht we have done till now.

Now, if the req is coming directly to HomeServlet, so we will need to set url.
For that we will need web.xml file.

Now right click on project folder-->java ee tools-->generate deployment descriptor stub--
so now in src->web-inf folder, web.xml file is ready.

Here, welcome file list,we will map srvlet

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>ValidationApp</display-name>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>
  <servlet>
	<servlet-name>Home</servlet-name>
	<servlet-class>com.itvedant.HomeServlet</servlet-class>	
  </servlet>
  <servlet-mapping>
	<servlet-name>Home</servlet-name>
	<url-pattern>/home</url-pattern>
  </servlet-mapping>
</web-app>

now 1st time when we will run , it will give me error, because we have not created those files yet.

Now lets say in HOmeServlet under, doGet() we have written--

public class HomeServlet extends HttpServlet{
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = resp.getWriter();
		resp.setContentType("text/html");
		out.println("Welcome");
}

run as-- http://localhost:8080/ValidationApp/home

Now if you want directly the req should go to home page only,
so, in web.xml file--

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>ValidationApp</display-name>
  
  <servlet>
	<servlet-name>Home</servlet-name>
	<servlet-class>com.itvedant.HomeServlet</servlet-class>	
  </servlet>
  <servlet-mapping>
	<servlet-name>Home</servlet-name>
	<url-pattern>/home</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>home</welcome-file>
    
  </welcome-file-list>
</web-app>


So now our req is going directly to home servlet.
Now copy form from home.html to HomeServlet.java bcoz we want to create form.
So make the changes in HomeServlet.java

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HomeServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		PrintWriter out = resp.getWriter();
		resp.setContentType("text/html");
		
		out.print("<form action='validate' method='get'>");
		out.print("<table><tr><td>Name:</td>");
		out.print("<td><input type='text' name='name'/></td>");
		out.print("</tr><tr><td>Marks:</td>");
		out.print("<td><input type='number' name='marks'/></td>");
		out.print("</tr><tr><td>Color:</td><td>");
		out.print("<select name='color'>");
		out.print("<option value='none'>.....</option>");
		out.print("<option>Red</option>");
		out.print("<option>Blue</option>");
		out.print("<option>Green</option>");
		out.print("<option>Pink</option>");
		out.print("<option>Purple</option>");
		out.print("<option>Grey</option>");
		out.print("<option>Violet</option>");
		out.print("<option>Indigo</option>");
		out.print("</select></td></tr><tr>");
		out.print("<td><input type='submit' value='OK'/></td>");
		out.print("<td><input type='reset'/></td></tr></table></form>");
	}
	
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		doGet(req, resp);
	}
}


now,creatting into servlet is not an easy task, so we will be using jsp--

Now, we directly have an option of creating servlet.
The adv here is we donot have to create java file then servlet.

So, right click project->new->servlet-->package-- com.itvedant-->class name-->ValidateServlet

so name of my servlet will be automatically set to ValidateServlet

-->next-->now name u can change to Validate-->now in url mapping bcoz V in validate is capital,
so, click Validate in url mapping-->edit make it validate.-->ok-->next-->click the methods u want-->finish

now, keep these functions remove others, if u want to keep that is also fine.

@WebServlet(name = "Validate", urlPatterns = { "/validate" })-- in this line we mapped 
the servlet class with the url,so that the web container can send the request to the requested servlet.
For this 1 way is web.xml file. Here create a deployment descriptor file and do the url mapping.
2nd way --annotation-- @WebServlet above the servlet class. Here u donot need to write anything in web.xml file.

http://localhost:8080/ValidationApp/validate

Now changing the doGet() to see if its actually coming here,

Now we will try to validate data, that our name field is not empty,

ValidateServlet.java

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ValidateServlet
 */
@WebServlet(name = "Validate", urlPatterns = { "/validate" })
public class ValidateServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = response.getWriter();
		response.setContentType("text/html");
		
		String name = request.getParameter("name");
		if(name.equals("")) {
			out.print("<br/>Name not provided");
		}
		String marks = request.getParameter("marks");
		if(marks.equals("")) {
			out.print("<br/>Marks not provided");
		}
		String colo = request.getParameter("color");
		if(colo.equals("none")) {
			out.print("<br/>Color not selected");
		}
		
		out.print("<br/>Validate Servlet Reached");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run as-- http://localhost:8080/ValidationApp/

donot give any value and see error.

Now we want error msgs come back to index page only. and not on other page.

so we will create a list--

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ValidateServlet
 */
@WebServlet(name = "Validate", urlPatterns = { "/validate" })
public class ValidateServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = response.getWriter();
		response.setContentType("text/html");
		List<String> errorList = new ArrayList<String>();
		String name = request.getParameter("name");
		if(name.equals("")) {
			errorList.add("Name not provided");
			
		}
		String marks = request.getParameter("marks");
		if(marks.equals("")) {
			errorList.add("Marks not provided");
		}
		String colo = request.getParameter("color");
		if(colo.equals("none")) {
			errorList.add("Color not provided");
		}
		if(errorList.isEmpty()) {
			request.getRequestDispatcher("success").forward(request, response);
		}
		else {
			
		}
		
		out.print("<br/>Validate Servlet Reached");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}



now lets say my data is fine and their is no error, then,
but in case of error we will do 2 types of operations using an interface called req dispatcher.

1st task-- req is given to servlet1, which gives name,marks and color.
Now, we will forward all the req to servelet2. The res that we will finally get,
we will get from servlet2.

Now lets give this task name as success servlet.

new->servlet-->java package-->com.itvedant-->Class name-->SuccessServlet-->next-->Sucess-->/success-->finish

now, from home servlet, we r bringing 3 things to validate servlet.

now if no error is there then in ValidateServlet.java errorlist is empty.
and we will forward our req to SuccessServlet.

if(errorList.isEmpty()) {
			request.getRequestDispatcher("success").forward(request, response); // fwd my req to success servlet
		}

SuccessServlet.java--

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		out.print("Success");
	}

run--> fill all the values-->success

Now on success page we want to fill all the details.

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(name = "Success", urlPatterns = { "/success" })
public class SuccessServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
  
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		//out.print("Success");
		String name = request.getParameter("name");
		String marks = request.getParameter("marks");
		String color = request.getParameter("color");
		
		out.print("<p style='color : " + color + ";'>");
		out.print("Welcome , "+name);
		out.print("<br/><br/> You have scored "+ marks);
		out.print("</p>");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run as-- fill all the values-->ok. So here we forwarded our req from 1 servlet to another.

Now if u want to show aggregaate then on validate page only, u can also calc the aggregate and forward it to succes page.

So, ValidateServlet.java

	if(errorList.isEmpty()) {
			float m = Float.parseFloat(marks);
			// now this aggregate and m are local variable. We need to forward this local variable to
			// another servlet
			float aggregate = (m/500)*100;
			request.getRequestDispatcher("success").forward(request, response);
		}

now to forward req from servlet1 to 2, we r using forward().
We can also add our local variable in our RequestDispatcher only.

}
		if(errorList.isEmpty()) {
			float m = Float.parseFloat(marks);
			// now this aggregate and m are local variable. We need to forward this local variable to
			// another servlet
			float aggregate = (m/500)*100;
			
			// adding local variable in request.
			request.setAttribute("aggr", aggregate);------------------------------ aggregate will be identified as aggr in another servlet.
			request.getRequestDispatcher("success").forward(request, response);
		}


So going into successservlet--

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(name = "Success", urlPatterns = { "/success" })
public class SuccessServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
  
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		//out.print("Success");
		String name = request.getParameter("name");
		String marks = request.getParameter("marks");
		String color = request.getParameter("color");
		float aggregate = (float)request.getAttribute("aggr"); //----------------------
		
		out.print("<p style='color : " + color + ";'>");
		out.print("Welcome , "+name);
		out.print("<br/><br/> You have scored "+ marks);
		out.print("<br/><br/> Your aggregate is "+ aggregate + "%"); //--------------------
		out.print("</p>");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}

So what we did is-- 1st we r going to home servlet-->then to validate servlet where we r reading each req
, if there is no error and all the values are provided---> then to success servlet

Here the browser is not aware about this transition. This entire process is happening within server.
For browser, when we give all the input, input is going to validate.
But internally it is getting forwarded from validate to success. 
U can see the url. URL is not getting updated with success


What if we want to make browser aware about thi that is--
if we want to move control from 1 servlet to another we can do using 3 techniques.

1. using forward() of RequestDispatcher
2. using include() of RequestDispatcher
3. sendRedirect of HttpRequest

1. forward() of RequestDispatcher

The request of the current servlet is dispatched to another servlet specified. This transition is happening inside the server, 
the client ie. hence browser is not aware about this transition and will not update the URL accordingly

2. include() of RequestDispatcher

The response of the another servlet in included within the first servlet request. Here the final response is generated by the first servlet

3. sendRedirect of HttpServletResponse

The control will move from one servlet to another servlet specified.
 Here the transition will not happen within the server instead the client will issue a new request for the second servlet, 
hence the client is aware about the transition and will update the URL accordingly. 
But here the request of the first servlet is not send to the second servlet.

So lets say in case of error in validateservlet.java, i want my req to send back to home page,

so, ValidateServlet.java

	else {
			response.sendRedirect("home");
		}
		
So, now run-- just click ok, dont put any value. -- It is not going at validate page.

So to just distinguish, 
	else {
			response.sendRedirect("home?redirect=yes");
		}

just to understand that it is getting redirected.

run-- in case of error-- see the url.
so, in sendRedirect, url is aware. So its like a fresh req to another servlet.
So if u just want to do movement from 1 page to another use sendRedirect
and if u want to pass data the use forward().

Now lets say i want to goto my home page but I want to tell user about these errors.
i.e. i want to print my error list.
So next we will see include()---
for this i dont want to pass req from 1 servlet to another instead i will include
home servlet response under validate servlet.
where, the home servlet response is the form page which we r getting.
So here the req is not coming in the picture instead resp is coming.

So, we r sending req to home page. Now if errors are there i am printing my errors.
and after printing errors, home page should be reconstructed,this we will do
by including home servlet within my validate servlet.
We will not rewrite entire home code. So in this case,
servlet2 is home page which is included as response to servlet1 which is validate page.

So the compbined response of servlet1 and servlet2 is given as final response. ValidateServlet.java

	else {
			//response.sendRedirect("home?redirect=yes");
			out.print("<ul style='color:red;'>");
			for(String err:errorList) {
				out.print("<li>" + err + "</li>");
			}
			out.print("</ul>");
		}

run as-- do not provide any value and see.
errors are there. Now below these errors , I want my home page form reconstructed below this .

	else {
			//response.sendRedirect("home?redirect=yes");
			out.print("<ul style='color:red;'>");
			for(String err:errorList) {
				out.print("<li>" + err + "</li>");
			}
			out.print("</ul>");
			request.getRequestDispatcher("home").include(request,response);
			
		}

Now, run as-->give error--->see o/p.

so, wit the help of include, we r including the response of 1 servlet into our servlet.

--

Now to perform initialization, we have 2 interfaces.

1. ServletConfig
2. ServletContext

1 is used for entire application level initialization while another is used for only application level initialization.
So if we nedd some paramenters to be initialized before my servlet gets executed, for that these 2 parameters are used.

See earlier when we created FirstApp-->java resources-->FirstServlet.java--- see init() is there.
init() is taking 1 parameter that is of type ServletConfig. For every servlet, there is going to be 1 instance created for
servletconfig and it will be used to initialize the vaues required to be initialized and it is not sharable.

ServletConfig

Is an interface whose instance is created by the web container for each servlet. For every servlet, 
only one ServletConfig instance is created and is passed as the parameter to the init() method

This object contains initail parameter passed by the web container to the Servlet during initialization

Scope of this instance is restricted to the Servlet for which it is defined.

So now come back to HomeServlet--- the list that we generated using out.print(),
this doesn't need to be generated manually.
instead the value of the colors , we will put into ServletConfig initialization so it will become more dynamic.

So in ur web.xml-- define this as ur initial parameter.

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
  <display-name>ValidationApp</display-name>
  
  <servlet>
	<servlet-name>Home</servlet-name>
	<servlet-class>com.itvedant.HomeServlet</servlet-class>	
	<init-param>
		<param-name>colors</param-name>
		<param-value>Red,Blue,Yellow,Green,Purple,Pink,Indigo,Violet,Grey,Cyan,Magenta,Orange</param-value>
	</init-param>
  
  </servlet>
  <servlet-mapping>
	<servlet-name>Home</servlet-name>
	<url-pattern>/home</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>home</welcome-file>
    
  </welcome-file-list>
</web-app>

Now we will extract <param-value>Red,Blue,Yellow,Green,Purple,Pink,Indigo,Violet,Grey,Cyan,Magenta,Orange</param-value>---- this is a single string.

Now, we r setting this initial parametr for home servlet. So vlidate and sucess servlet will not be able to acecess it.

So from homeservlet we r removing out.print red to indigo.

So the value we r setting in our initial parameter, we will be reading that first.

String colors = getInitParameter("colors");

since,in web.xml, we have setted it to colors.
so, colors has the entire list of param-value.

u can even print and check.

run as-- the entire color list is visible. But this we want in our drop off box.

So what we can do is we can seperate this list and create a string array.

		String colors = getInitParameter("colors");
		//out.print(colors);
		
		String[] colorVaues = colors.split(",");/----------------------------
		
		out.print("<form action='validate' method='get'>"); 

and print using for loop. So --


public class HomeServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		PrintWriter out = resp.getWriter();
		resp.setContentType("text/html");
		
		String colors = getInitParameter("colors");
		//out.print(colors);
		
		String[] colorValues = colors.split(",");
		
		out.print("<form action='validate' method='get'>");
		out.print("<table><tr><td>Name:</td>");
		out.print("<td><input type='text' name='name'/></td>");
		out.print("</tr><tr><td>Marks:</td>");
		out.print("<td><input type='number' name='marks'/></td>");
		out.print("</tr><tr><td>Color:</td><td>");
		out.print("<select name='color'>");
		out.print("<option value='none'>.....</option>");
		
		
		for(String c : colorValues) {
			out.print("<option>"+ c + "</option>");
		}
		
		out.print("</select></td></tr><tr>");
		out.print("<td><input type='submit' value='OK'/></td>");
		out.print("<td><input type='reset'/></td></tr></table></form>");
	}
	
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		doGet(req, resp);
	}
}

so on run as-- u will get drop down in colors.
give all the info--select color-- ok.
 But the thing is this is accessible only inside hoemservlet.

So now inside ValidateServlet--

and write something like this,
PrintWriter out = response.getWriter();
		response.setContentType("text/html");
		
		String colors = getInitParameter("colors");----------
		out.print(colors.charat(0));----------------------------------- doing some task-- it will give error.

		
		List<String> errorList = new ArrayList<String>();


we r getting NullPointException.

So remove above code from validateservlet.

So now we will talk about scope of data on servlet. ServletConfig has least scope and is accessible only inside single servlet.

Scope of the data in the servlet
1. ServletConfig: accessible only in the single servlet
2. HttpServletRequest: accessible in two servlets between which the request is transferred
3. HttpSession: 
4. ServletContext: accessible to the entire application means to all the Servlet & JSP of the application

ServletContext

Is an interface whose instance is created by the web container. Only one instance is created for the entire application (project). 
This instance is accessible to all the servlets and JSP of the project. 

We can initial the parameters in this object using web.xml or add the parameters in the servlet execution 

So inside web.xml, we will not put it inside any servlet, but directly after <display-name>

<display-name>ValidationApp</display-name>
  <context-param> ----------------------------------------------
	<param-name>developer</param-name>
	<param-value>Parinita</param-value>
  </context-param>
  
  <servlet> 

So now I want to access this value everywhere, like in home servlet,success servlet,validate servlet.

So, lets say in HomeServlet.java, we will just retrieve this value,--

out.print("</select></td></tr><tr>");
		out.print("<td><input type='submit' value='OK'/></td>");
		out.print("<td><input type='reset'/></td></tr></table></form>");
		
		String dev = getServletContext().getInitParameter("developer"); -----------
		out.print("<h6>&copy;" + dev + "</h6>"); ----------------------------------
	}
	
	@Override
	protected void doPost

run as-- url--see o/p

Now if u will try to access this code in other servlets also, then it will be accessible to u.
Lets say ValidateServlet.

}
		
		String dev = getServletContext().getInitParameter("developer");
		out.print("<h6>&copy;" + dev + "</h6>");
		
		
	}

	
	protected void doPost

then also u will not get any error.

infact in servlets also u can add values inside context parameters.

egHomeServlets, 1 st u will have reference

String dev = getServletContext().getInitParameter("developer");
		out.print("<h6>&copy;" + dev + "</h6>");
		
		ServletContext ctx = getServletContext();------------------------
		ctx.setAttribute("sample","sampling context");-------------------
	}

u will be able to access this into SuccessServlet,

		out.print("<br/><br/> Your aggregate is "+ aggregate + "%");
		out.print("</p>");
		

		ServletContext ctx = getServletContext();
		String samp = (String)ctx.getAttribute("sample");
		out.print(samp);
	}

this parameter we have set in home servlet, the servlet is going from home to validate
and then from validate to success servlet.

So there are 2 ways of defining servlet context. define it as an initial parametr,
in ur web.xml file or, in the servlet execution get the reference of the servletcontext,
and then set the attribute accordingly.

Servlet part 4---

Now starting with HttpSession object.
So for ur server to remember you, i.e. to recall data we will use HTTP Session.
And for that we need session mgmt.

Session Management Requirement is because HTTP is a stateless protocol wherein the server will not remember anything that 
the user send once the response has been sent back. Everytime user requests to the server, 
server will treat the request as a new request. So there is a need to maintain the state(information) 
of the user so that server can identify the request from the same user.

Session is time interval.

Session Management is the way to maintain the state of the user.

Session Management can be implemented using 4 techniques:
1. HttpSession Object
2. Cookies
3. Hidden Form Field
4. URL Rewriting


HttpSession Object

Is an interface used to manage session for each user. Web container will create the sesssionid for each user and 
will maintain the information related to the user using this sessionid

HttpSession can be created using:

1. HttpSession(): Return current session associated with this user or if there is no session, then will create a new session
2. HttpSession(boolean create):
			create -> true: Always create a new session
			create -> false: Return current session associated with this user or if the session object does not exists for the current user then it will return null


Now lets say our home page opens directly, but we want home page to open only if user is logged in and user id pwd is correct.
So we will create a new web page.
so validateapp---->right click---> new--->jsp page for login and pwd.

index.jsp---

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
	<form action="login" method="post">
		<table>
			<tr>
				<td>Username:</td>
				<td><input type="text" name="username" required></td>
			</tr>
			<tr>
				<td>Password:</td>
				<td><input type="password" name="password" required></td>
			</tr>
			<tr>
				<td><input type="submit" value="login"></td>
				<td><input type="reset"></td>
			</tr>
		</table>
	</form>

</body>
</html>

After this we will make changes in our web.xml file because we need to make index.jsp pages as our home page.

So, web.xml--

	<url-pattern>/home</url-pattern>
  </servlet-mapping>
  <welcome-file-list>
    <welcome-file>index.jsp</welcome-file>-------------------------------
    
  </welcome-file-list>
</web-app>

run as-- run on server-- now if u will put username and password-- url will be directed to login servlet.

So will create 1 servlet file now.

new-- servlet file--> package name-->com.itvedant-->class name LoginServlet-->next-->name-->Login-->url /login-->ok-->finish

Now from url, req is coming as a post req, and not a get req.
So if we want we can remove this get req.


package com.itvedant;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet(name = "Login", urlPatterns = { "/login" })
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
   
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
	}

}


considering a case where username and pwd are matching--



package com.itvedant;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet(name = "Login", urlPatterns = { "/login" })
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
   
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String username = request.getParameter("username");
		String password = request.getParameter("password");
		
		if(username.equals(password)) {
			request.getRequestDispatcher("home").forward(request, response);
		}
		else {
			
		}
	}

}

if they donot match then i can fwd the req to another page. and logic we will write in else part.
and for that we will create a new servlet.

new--servlet--->ErrorServlet--->next--->Error-->/error--->finish

Now in this servlet the req will be coming if there is an error.

So in LoginServlet.java


		if(username.equals(password)) {
			request.getRequestDispatcher("home").forward(request, response);
		}
		else {
			response.sendRedirect("error");
		}
	}

}

ErrorServlet.java-----------------------------------------
package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ErrorServlet
 */
@WebServlet(name = "Error", urlPatterns = { "/error" })
public class ErrorServlet extends HttpServlet {
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter out = response.getWriter();
		out.println("<h1 style='color:red;'>Username or Password is wrong</h1>");
		
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}

run project--
abc 
abc
ok-- got home page

abc
def
ok--- password or username wrong . So we can say our navigation is proper.

Now lets just imagine that in our home page we have created some links,
i.e. if user abc is there then after login , it will print something like welcome abc
and the form page will come. So on hoemservlet---

		String colors = getInitParameter("colors");
		//out.print(colors);
		
		String[] colorValues = colors.split(",");
		String username = req.getParameter("username");----------------
		
		out.print("<h4>Welcome, "+username +"</h4>");------------------
		
		out.print("<form action='validate' method='get'>");
		out.print("<table><tr><td>Name:</td>");
		out.print("<td><input type='text' name='name'/></td>");


run as-- abc abc--login--see the o/p

Now, on all pages I want my session to remember that the username is abc. So we will create 1 more servlet page--
So just some dummy servlet we r going to create.

new servlet--->com.itvedant--->AdmissionServlet--->next-->Admission--->/admission--->finish


 
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		PrintWriter out = response.getWriter();
		String username = request.getParameter("username");
		out.print("<h4>Welcome, "+username +"</h4>");
		}


Since, the req is originating from home servlet only. So after welcome in HomeServlet--

	
		out.print("<h4>Welcome, "+username +"</h4>");
		
		out.print("<a href = 'admission'>Admission</a>");------------------------------
		out.print("<form action='validate' method='get'>");

run-- index to login to admission page.So in login page it remembers username.
but in admission page it doesn,t remeber and we r getting welcome, null as o/p.
it has forgotten. So to remeber across diff pages in single session--

on the page from where req has been generated, while reading the username in homeservlet,
we will keep it in httpsession object. We have 2 methods. getSession with parameter and without parameter.
Without parameter one returns current session object and if no session object is created yet , then it creates 
the session object.

		String username = req.getParameter("username");
		HttpSession session = req.getSession(); ------------- here no session object  exist so it will create a new session object.
		
		out.print("<h4>Welcome, "+username +"</h4>");
		
Now this session will be created if the login is sucessful. So after login page, the page
in which we r going, there we can start with our session object.U can put the values in ur session object.

		String username = req.getParameter("username");
		HttpSession session = req.getSession();
		session.setAttribute("uname", username);------------------
		
		out.print("<h4>Welcome, "+username +"</h4>");

Now after login we will goto index where it remebers after that we will goto admission where it doesnt remember.
So, in admissionservelt, we will not create a new sesson object, instead the already existing object will be used.

HttpSession sess = request.getSession();

and then we will extract the value.

we will not read it like this String username = request.getParameter("username"); because data is not coming through request.
because we have not forwarded anything from home page. We have just created a hyperlink, when we will clcik on that 
hyperlink,then req is coming here, So we will read the values. 

		PrintWriter out = response.getWriter();
		//String username = request.getParameter("username");
		
		HttpSession sess = request.getSession();
		String username = (String)sess.getAttribute("uname");-------------
		out.print("<h4>Welcome, "+ username +"</h4>");
		}

run---now it remembers.

So what is happening is--In the session mgmt, after the successful login, u r creating a session object.
Session id will be created in the memory. Whatever information u will set using set attribute,
that will be added in that memory location till the time session object is active.
So lets say if we create logout 

		out.print("<h4>Welcome, "+username +"</h4>");
		
		out.print("<a href = 'admission'>Admission</a>");
		
		out.print("<a href='logout'>Logout</a>:");
		out.print("<form action='validate' method='get'>");

so now we will create a logout servlet,

new-->servlet-->com.itvedant-->LogoutServlet--> /logout

package com.itvedant;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;


@WebServlet(name = "Logout", urlPatterns = { "/logout" })
public class LogoutServlet extends HttpServlet {
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		HttpSession sess = request.getSession();
		sess.invalidate();
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run as--->login-->admission-->logout-->admission 
i.e. session object is destroyed.

for the same user, same session id is created until and unless we destroy the session object.
Now how it remebers, the session ids of the user, is by using cookies in the m/c. Cookies maintain session id.

so in browser-->settings--->local host

Now, these session ids are occupying space , but our server has limited amount of space, and for each req if session is created
alot of space will be req. So we will use another method-- where we will save nothing at server m/c but at clients m/c only.

but 1st getSession() with parameter. lets say i have not logged in and i am directly 
going into logout page using url http://localhost:8080/ValidationApp/logout

here i am not getting any error. This is bcoz of the getSession().
the HTTPSession object returns current session associated with this user or we can say--

HttpSession can be created using:

1. HttpSession(): Return current session associated with this user or if there is no session, then will create a new session.
So even if we directly logout, it will create a new session without throwing any error.
2. HttpSession(boolean create):
			create -> true: Always create a new session
			create -> false: Return current session associated with this user or if the session object does not exists for the current user then it will return null




in logoutservlet-->getSession() with parameter is something like-- do the changes 

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		HttpSession sess = request.getSession(false);----
		sess.invalidate();


run-- http://localhost:8080/ValidationApp/logout -->refresh-->u will get error-->etting null pointer exception 
bcause since login is not done, session is not existing.

---
now, we will store user's info in user's m/c only.
------------------------------------------------
Cookie

In case of the HttpSession we have seen that the sessionid is maintained using cookies. 
We can also the cookies to maintain more information so that the server is not maintaining the information related to each user instead it is maintained in client's machine itself.

Cookie is file stored in the client machine. This file is send along with the response from the server.
 Now everytime the request is send to the server, all the cookie related will be send along with request.

1. Cookies can be implemented using Cookie class and create the instance of this class
2. This cookie instance will be added in the response of the servlet using addCookie(Cookie) of the response object
3. All the cookies related to this server will be send from the client machine along with the request and then we can extract all the cookies 
from the request using getCookies() 

So we will create a new project now for showing how cookieworks.

so, file-->new---> dynamic web project-->proj name-->SessionManagementUsingCookies--->finish

SessionManagementUsingCookies-->new-->jsp-->index.jsp-->finish

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
	<a href="login.jsp">Login</a><br/>
	<a href="profile">Profile</a><br/>
	<a href="logout">Logout</a><br>

</body>
</html>

SessionManagementUsingCookies-->new-->jsp-->login.jsp-->finish

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
	<form action="login" method="post">
		<table>
			<tr>
				<td>Username:</td>
				<td><input type="text" name="username" required></td>
			</tr>
			<tr>
				<td>Password:</td>
				<td><input type="password" name="password" required></td>
			</tr>
			<tr>
				<td><input type="submit" value="login"></td>
				<td><input type="reset"></td>
			</tr>
		</table>
	</form>
	
</body>
</html>

new-->servlet-->com.itvedant--->LoginServlet--->Finish

change in url to /login in the code like--

in the doPost() we will read the content.

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/login")
public class LoginServlet extends HttpServlet {
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.getWriter().append("Served at: ").append(request.getContextPath());
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String username = request.getParameter("username"); // same name as given in login.jsp
		String password = request.getParameter("password");
		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		// if user id , pwd is not correct then,
		request.getRequestDispatcher("index.jsp").include(request, response);
		
		if(username.equals(password)) {
			out.print("Successfully logged in");
			Cookie c = new Cookie("username",username);
			response.addCookie(c);
		}
		else {
			out.print("Username or passsword is incorrect");
			request.getRequestDispatcher("login.jsp").include(request, response);
		}
	}

}


run as-->login-->same username pwd-->suucc logged in.

if username pwd is incorect, msg is getting printed.

so see in edge browser-- all cookies and site data-- search localhost under which u will see localhost.
this is giving info like when it was created when it will expire.

So lets say, next time, it is reading this cookie. that means all the cookies htat we have,
it wants to take with it and read it.

new-->servlet--->com.itvedant-->ProfileServlet--->finish

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/profile")
public class ProfileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		response.setContentType("text/html");
		PrintWriter out =  response.getWriter();
		
		
		request.getRequestDispatcher("index.jsp").include(request, response);
		
		Cookie[] ck = request.getCookies();
		
		if(ck!=null) {
			for(Cookie c : ck) { // 1st cookie is of session array. So for each cookie 
				if (c.getName().equals("username")){
					String name = c.getValue();
					out.print("Welcome, " + name );
				}
			}			
		}
		else {
			out.print("Please login first");
			request.getRequestDispatcher("login.jsp").include(request, response);
		}
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}


run-- now when it is saying welcome, abc -- this info is not getting stored in ur server,
but on the clients m/c or localhost in the form of a cookie. So when the req will go to 
thwe same m/c using this cookie it will identify.

If u want to delete or want to logout u can set age to ur cookie.U can set it to 0.

So new->servlet->LogoutServlet->finish

package com.itvedant;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/logout")
public class LogoutServlet extends HttpServlet {
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		request.getRequestDispatcher("index.jsp").include(request, response);
		Cookie c = new Cookie("username", "");
		c.setMaxAge(0);
		response.addCookie(c);
		out.print("Successfully logged out");
	}

	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}

}

run-->

so we r using cookies to maintain our sessions.

We can maintain sessions using hidden fields, and from urls which will be discussed later.


------------------------------------------------------------
JSP(Java Servlet Pages)

Cookie

In case of the HttpSession we have seen that the sessionid is maintained using cookies. We can also the cookies to maintain more information so that the server is not maintaining the information related to each user instead it is maintained in client's machine itself.

Cookie is file stored in the client machine. This file is send along with the response from the server. Now everytime the request is send to the server, all the cookie related will be send along with request.

1. Cookies can be implemented using Cookie class and create the instance of this class
2. This cookie instance will be added in the response of the servlet using addCookie(Cookie) of the response object
3. All the cookies related to this server will be send from the client machine along with the request and then we can extract all the cookies from the request using getCookies() 

------------------------------------------------------------
JSP(Java Servlet Pages)--
JSP came after servlets were created.
1 of the major drawback is the html part which u have to put inside double quotes. tags within it. They are quite difficult to analyze.
So instead of putting html code into java code, we can do a reverse thing,
that is,java code within html code.

So till now what we were doing was in servlet the response is generated using the object of the PrintWriter class, 
where the HTML code is written within the double quotes as a string. 
As the response is in the string format, find the problem is very difficult and even writing HTML code in java
 is a tedious job. A programmer must have the good knowlegde of java then only he can create servlet.

JSP page is the combination of the HTML and java code. We will create .jsp file with the base of HTML and Java code added for the business logic

Difference Between Servlet and JSP

Servlet
1. Java Code
2. Writing the code is harder as here HTML code is written with java functions.
3. For every request service() is called, hence we have to override service() method.
4. Mostly used for business logic/controller (move from one page to another)
5. Implementation is faster
6. Every time we make any changes in the servlet, the file is recompiled and the new class file is deployed in the server.

JSP
1. HTML based Code
2. Writing the code is easier as here java code is written with HTML tags when required.
3. For every request _jspService() is called , hence we have to override _jspService() method
4. Mostly used for presentation (final response)
5. Implementation is comparatively slower because here first JSP is converted into servlet
6. Every time we make the changes in the JSP file, they are updated in the server
-------------------------------------------------------
JSP Life Cycle 

1. Create JSP file (.jsp)

Translation Stage/Phase
2. JSP file is converted into Servlet file (.java)
		
		.jsp -----> .java

Compilation Stage/Phase
3. Servlet file is converted into class file (.class)
		.java -----> .class

Execution Phase
4. Load the class file in the web container
5. Web container will create the instance of this servlet class file. Only one instance 
6. Web container will call the init() method only once for this instance
7. Web container will call _jspService() method for every request
8. Web container will call the destroy() method when the instance is removed from the server.

----------------------------------------------------

create a new project-- file--new--dynamic web project-->JSPDemo-->finish

now we will add a jsp page--index.jsp-->finish

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h1>Welcome to JSP</h1>
</body>
</html>

now the translation of this file is going into my server.

D:\learning\apache-tomcat-9.0.87\work\Catalina\localhost\JSPDemo\org\apache\jsp

see the.java file. u will find diff methods.
most imp method is _jspService().the entire html page is written within out.print().
u can even see Welcome to JSp. Everything written inside out.print() is the
response that we have generated.
This file is generated by ur tomcat server. It is extending HttpjspBase.
it also contains init().

Now what we want to do is add java code within jsp page. So,

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<h1>Welcome to JSP</h1>
	<form action="add.jsp">
		<table>
			<tr>
				<td>Number1</td>
				<td><input type="number" name="num1"/></td>
			</tr>	
			<tr>
				<td>Number2</td>
				<td><input type="number" name="num2"/></td>
			</tr>
			<tr>
				<td><input type="submit" value="add"/></td>
				<td><input type="reset"/></td>
			</tr>	
		</table>
	</form>
</body>
</html>

run as-->just make the changes-->save it--refresh it-->no need to deploy again and again. But in case of servlet u do.

lets say we want to send our req to another jsp page, i.e. add.jsp--so that when we give the nos. they will be forwarded to 
add.jsp.

So in add.jsp we will add java code. new-->jsp file-->add.jsp-->finish.

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>ADD</title>
</head>
<body>
<%
String num1 = request.getParameter("num1");
String num2 = request.getParameter("num2");

out.print("Sum = "+(num1+num2));
%>

</body>
</html>

now the problem over here is, the value coming in a url is a string value.
getParameter() always gives string value
So we will do typecasting.

<body>
<%
int num1 = Integer.parseInt(request.getParameter("num1"));
int num2 = Integer.parseInt(request.getParameter("num2"));

out.print("Sum = "+(num1+num2));
%>

</body>

save-->refresh browser-- from jsp to .java to .javac everything is in control of tomcat.
compilation part is not done by compiler in case of servlet.infact for add also u will get code in work folder.
And whatever code we have added in scriptlet, its part of my _jspService() now.

Next is Expression tag -- by using it we can even remove out.print stmt,
out.print("Sum = "+(num1+num2));--- like this one.

So, any Java Code can be written within the JSP page using scripting elements

Three types of the scripting elements:
1. Scriptlet Tag

Any java code can be written within JSP page. This code will be added in _jspService() method when translated

Syntax:
<% java code %>

2. Expression Tag

The code placed inside the expression tag is written to the output stream of the response. So you need not write, out.write() / out.print(). Its mostly used to print the value of the variable or the value returned by the method. This tag code is also added in _jspService() method

SyntaxL
<%= statement%>
eg.

So we will replace out.print("Sum = "+(num1+num2));
and write it outside using expression tag.

<body>
<%
int num1 = Integer.parseInt(request.getParameter("num1"));
int num2 = Integer.parseInt(request.getParameter("num2"));

//out.print("Sum = "+(num1+num2));
%>

<p style="color:purple;">Sum=<%=(num1+num2) %></p>

</body>

<%=(num1+num2) %> this is our expression tag.

code related to this will be added in ur service methd.

3. Declarative Tag--

Used to declare the variables and methods. 
The code written inside the declarative tag is 
placed outside _jspService() method, 
directly inside the generated class

Syntax:
<%! variable or method declaration %>

<body>


<%! int add(int a,int b){
	return a+b;
}
%>
<%
int num1 = Integer.parseInt(request.getParameter("num1"));
int num2 = Integer.parseInt(request.getParameter("num2"));

//out.print("Sum = "+(num1+num2));
%>

<%-- <p style="color:blue;">Sum=<%=(num1+num2) %></p>--%>
<p style="color:blue;">Sum=<%=add(num1,num2) %></p>

</body>


D:\learning\apache-tomcat-9.0.87\work\Catalina\localhost\JSPDemo\org\apache\jsp

add_jsp.java-- see the code---

public final class add_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

 int add(int a,int b){
	return a+b;
}

it is directly added on the class level.
U can also usse it if u want to declare any
variable on class level.
Now, the jsp gives translated class.
So the servlet class thats gets created from jsp,
inside that class if u want to put anything,
that u can do with the help of ! mark.
for response u use expression tag or =.
And for any other java code u will use <%%>-- scriplets.

if u want to print time-- then--

<%@page import="java.time.LocalDate" %>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>ADD</title>
</head>
<body>
<h1>Today is <%=LocalDate.now() %></h1>

<%! int add(int a,int b){
	return a+b;
}
%>
<%
int num1 = Integer.parseInt(request.getParameter("num1"));
int num2 = Integer.parseInt(request.getParameter("num2"));

//out.print("Sum = "+(num1+num2));
%>

<%-- <p style="color:blue;">Sum=<%=(num1+num2) %></p>--%>
<p style="color:blue;">Sum=<%=add(num1,num2) %></p>

</body>
</html>
--------------------------------------------------------------
Comments in JSP

1. HTML Comments

Syntax:
<!-- Comment -->

This comment will added in the translate code 
using out.write() method inside _jspService() method.
 Only this comment will be part of the final 
response being send to the browser

eg
<body>
<!-- This is the HTML comment -->
<h1>Today is <%=LocalDate.now() %></h1>

<%! int add(int a,int b){
	return a+b;
}
%>
<%

now save-->go to browser-->give values-->add-->view page source
-->this html comment is part of ur final response.
Infact in add_jsp.java this comment is added
using out.write, that is why this comment is there in ur response page.



2. JSP Comments

Syntax:
<%-- Comment --%>

This comment is not translated into the servlet file.
 This comment exists only in the JSP, 
and not in .java file

3. Java Comments

This comment will be placed directly inside the _jspService() method after translation. This comment is not added in the final response.

<%@page import="java.time.LocalDate" %>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>ADD</title>
</head>
<body>
<!-- This is the HTML comment -->
<h1>Today is <%=LocalDate.now() %></h1>

<%! int add(int a,int b){
	return a+b;
}
%>
<%--This is JSP comment. Not visible anywhere --%>
<%
//Single line java comment
/*Multiline java comment.*/
// They are translated and gets added to add_jsp.java .Not Part of final response. 
%>

<%
int num1 = Integer.parseInt(request.getParameter("num1"));
int num2 = Integer.parseInt(request.getParameter("num2"));

//out.print("Sum = "+(num1+num2));
%>

<%-- <p style="color:blue;">Sum=<%=(num1+num2) %></p>--%>
<p style="color:blue;">Sum=<%=add(num1,num2) %></p>

</body>
</html>

------------------------------------------------------
Now whenever we add any JSP page, there is a page directive
tag added at the top which gives direction to my translation.
It tells how the entire page wil behave like.
So 2 directive tags that we will discuss are page directive tag
and include directive tag.

Directive Tags

Used to tell the web container how to translate the JSP page into the corresponding servlet

Syntax:
<%@ directive attribute="value" ..... %>

In directive we can specify page or include
Each directive has multiple predefined attributes to which we need to assign the values

-----------------------------------------------------
JSP Page Directive-- this is default.
Topmost place for it is not mandatory but since
we r setting up properties
for entire page, its better to place it on top.


Define some attributes that will define the translation if the entire page

<%@page ..... %>

language ===> programming language used to create the servlet, it has only one value, ie. java

contentType ===> define the type of the response generated by the page. For html response we use the value "text/html"

pageEncoding ===> define the encoding techinque using the response will be encoded

encode ===> decode (browser).

import ===> define the classes or interfaces or the entire package been used in jsp

session ===> 
Now, earlier we used to create our session object after getting logged in.
We used to create HttpSession object, but for jsp by default it is started.
The session object is already created , u can see in index_jsp.java
inside _jspService() it is already created.
And its default value is True, If
on a page u dont want to use it, then set it to False.
And then this object will be removed from index_jsp.java page.

<%@page import="java.time.LocalDate" %>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1" session="false"%>

now, and see in index_jsp.java, session objects will be gone
And if u will make it true, it will appear in the file.

define whether the page should include
 the session object. The default value is true. 
This attribute makes sure that each JSP page 
is the part of the session. 
But if we don't want some pages to be part of 
the session we can set the value of this attribute 
as false.

-----------------------------------------------------
JSP include directive

Used to include the content of any resource (JSP, HTML, Text) at the page translation phase. It can used to include the common layout file. It can be used to include only static page and not the page which will be changed at the runtime

<%@include file=""%>

So, now in our application , lets have some header file created,
Jsp demo-->new jsp file-->header.jsp

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Header</title>
<style>
#header{
	width:100%;
	heiht:30px;
	color:white;
	background: navy;
	text-align: center;
}
</style>
</head>
<body>
	<div id="header">
		<h2>Welcome to the world of the JSP</h2>
	</div>
		
</body>
</html>

now lets say this is a common header file,
which u want to include in both, index.jsp and add.jsp.

Simply right click on header.jsp-->run as-->and see o/p 
on browser. This is what it will look like.

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Header</title>
<style>
#header{
	width:100%;
	heiht:80px;
	color:white;
	background: navy;
	text-align: center;
}
#header a{
	color:white;
	
	text-decoration: none;
}
</style>
</head>
<body>
	<div id="header">
		<h2>Welcome to the world of the JSP</h2>
		<a href="index.jsp">Index</a>
	</div>
		
</body>
</html>

now we will include this in another file--

<%@page import="java.time.LocalDate" %>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<%@include file="header.jsp" %>
<!DOCTYPE html> 
in both index.jsp and add.jsp

Now, when we will run and put values in browser--
the code will be translated.the entire code will
be added in index_jsp.java in out.write();
the index code of both index.jsp and header.jsp
will be added in index_jsp.java and not at runtime.
So its static when we talk about include directive code.

Now, our header.jsp is like--

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Header</title>
<style>
#header{
	width:100%;
	heiht:80px;
	color:white;
	background: navy;
	text-align: center;
}
#header a{
	color:white;
	
	text-decoration: none;
}
</style>
</head>
<body>
	<div id="header">
		<h2>Welcome to the world of the JSP</h2>
		<a href="index.jsp">Index</a>
	</div>
		
</body>
</html>

We will do this in index page also.

------------------------------------------------------
Action Elements

Special Tag of the jsp to perform some specific task and is used to replace the java code with tags

jsp:forward
jsp:include



----------------------------------------------------

1. include directive will include the resource at the translation time, hence the entire code of the resource included is added in the response of the current page
2. include action tag will include the resource at the runtime, hence we can make some changes at the runtime in the response to be included.

header.jsp--

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Header</title>
<style>
#header{
	width:100%;
	heiht:80px;
	color:white;
	background: navy;
	text-align: center;
}
#header a{
	color:white;
	
	text-decoration: none;
}
</style>
</head>
<body>
	<div id="header">
		<h2>Welcome to the world of the JSP</h2>
		<a href="index.jsp">Index</a>
	</div>
		
</body>
</html>

Now index.jsp---

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1" session="true"%>
<%@include file="header.jsp" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
	<form action="login.jsp">
		<table>
			<tr>
				<td>Username</td>
				<td><input type="text" name="username"/></td>
			</tr>
			<tr>
				<td>Password</td>
				<td><input type="password" name="password"/></td>
			</tr>
			<tr>
				<td>Color</td>
				<td>
					<select name="color">
						<option>red</option>
						<option>pink</option>
						<option>blue</option>
						<option>green</option>
						<option>orange</option>
					</select>
				</td>
			</tr>			
			<tr>
				<td><input type="submit" value="Login"/></td>
				<td><input type="reset"/></td>
			</tr>
		</table>
	</form>
</body>
</html>


Now we will add a new login page.

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<%@include file="header.jsp" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
	<%
		String username = request.getParameter("username");
		String password = request.getParameter("password");
		String color = request.getParameter("color");
		if(username.equals(password)){
	%>
	
	<jsp:forward page="success.jsp">
		<jsp:param value="<%=username %>" name="username"/>
		<jsp:param value="<%=color %>" name="color"/>
	</jsp:forward>
	
	<%} %>
</body>
</html>

from login page we are forwarding req to success.jsp-- so in success.jsp--

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<%@include file="header.jsp" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Success</title>
</head>
<body>
<%
String username = request.getParameter("username"); ------- reading values sent by login.jsp
String color = request.getParameter("color");
%>

<h3>Welcome, <%=username %></h3>

<form action="add.jsp">
		<table>
			<tr>
				<td>Number1</td>
				<td><input type="number" name="num1"/></td>
			</tr>
			<tr>
				<td>Number2</td>
				<td><input type="number" name="num2"/></td>
			</tr>
			<tr>
				<td><input type="submit" value="Add"/></td>
				<td><input type="reset"/></td>
			</tr>
		</table>
	</form>
	
	<jsp:include page="footer.jsp">
		<jsp:param value="<%=color %>" name="color"/>
	</jsp:include>
</body>
</html> 

now the req is going form login page to server page, only the server
knows about it and not the client from url.


Now from success.jsp to add.jsp, no changes on add.jsp



run-->put smith smith red-->index.jsp-->login.jsp
in my suuccess page the footer value will be inthis color.
now in success.jsp we will include footer and not forward it.
Now it is included at the runtime and everytime the 
user selected some color, in that color the o/p is getting forwarded So in success page see
how we included footer page..

we have passed a color value to success.jsp which is again getting forwarded to footer.jsp.
The inclusion is happening at the runtime and not at the translation time.

so now we will design footer page--

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<%String color = request.getParameter("color"); %>
	<h6 style='color:<%=color%>'>&copy;www.itvedant.com</h6>
</body>
</html>

So if we talk about inclusion using directive tag and include regarding ur action tag then,


1. include directive will include the resource at the translation time, 
hence the entire code of the resource included is added in the response of the current page
2. include action tag will include the resource at the runtime, 
hence we can make some changes at the runtime in the response to be included.

-------------

Now, next we will see some implicit objects declared within ur jsp page.

Implicit object--

There are 9 implicit objects created by web container that are available to all the jsp pages.
So the objects and different class to which they belong--
out		JSPWriter
request		HttpServletRequest
response	HttpServletResponse
config 		ServletConfig
application	ServletContext
session 	HttpSession
pageContext	PageContext
page		this/Object
exception	Throwable


D:\learning\apache-tomcat-9.0.87\work\Catalina\localhost\JSPDemo\org\apache\jsp

for eg index_jsp.java file--

in the _jspService method, HttpServletRequest and HttpServletResponse object are already created.
i.e. request and response. U can see PageContext, HttpSession object.
then Servlet context object application. THis is used to share data across any application.

(niote--if u want to change version of java then JSPDemo-->Java Resources-->libraries-->JRE system library
-->properties-->choose JavaSE-17.)

index.jsp--

<meta charset="ISO-8859-1">
<title>Welcome</title>
</head>
<body>
<% application.setAttribute("author","P"); %>
	<form action="login.jsp">
		<table>

then we can go on footer.jsp and on footer.jsp page--

<%String color = request.getParameter("color"); %>
	<h3>
	<%=(String) application.getAttribute("author") %>
	</h3>
	<h6 style='color:<%=color%>'>&copy;www.itvedant.com</h6>

refresh-->run -->put values-->see.

So we can access values using setAttribute and getAttribute.

By default jsp puts all the pages into session object.
But we can disable our session also. Something like lets say , in footer page, session is not allowed.

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1" session="false"%>

then,in footer.jsp page no session object will be created.

So in the translation of footer.jsp i.e. footer_jsp.java there won't be any session object

-----------

Exceptions in JSP--
Dedicated page for handling the exeption need to be created in jsp,Implicit exceptions object are not available to all the jsp pages.
it will be available to only those jsp pages,where in the page directive tag, attribute isErrorPage 
is set to true.

new-->jsp file-->errorpage.jsp-->finish

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1" isErrorPage="true"%>
<!DOCTYPE html>

right click -->run it on server-->in the o/p we will not get anything,
but in the translation of this page--> see the throwable exception under _jspService.
This will only come when isErrorPage=True.

Lets say i want to do this in index.jsp-- then simply write--

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1" session="true" errorPage="erroepage.jsp"%>
<%@include file="header.jsp" %>

so now all the jsp pages where the exception will be occuring can transfer exception
handling to this page by setting the value of errorPage atttribute to the name of the 
error page created.

<body>
<% application.setAttribute("author","P"); 
   int a=10/0;---------- we know this is an error.
%>

and in erroepage.jsp--

<title>Insert title here</title>
</head>
<body>
This is error page
</body>

do save all and just run index.jsp page-- see the msg getting printed.

So wherever or errors are going that page need to be marked isErrorPage=True.

-----------

Project on JSP Servlet--

Income Expense Application ===> User should be able to login and 
keep the track of the income details and expense details. 
That is, amount that I am receiveing from different sources 
and the amount that I am expending.
We can also add new users. 
Able to display the income and expense details.

So the different pages that we will require are--
Register
Login
Add Income
Add Expense
Income List
Expense List
About Us

-----------------------------------------------
Now to tackle this problem, we will be working with MVC architecture.
So we will be breaking our entire application into Model,View and Controller.
MVC

M ==> Model ==>Model is a normal java class.
This Class represent the state of the application, data that is stored in the database is mapped as the object of this class.
So for equivalent tables, equivalent classes will be there. Normal POJO classes.

V ==> View ==> JSP Page which will be the final response presented to the user (i.e. the client) 

C ==> Controller ==> Servlet will acts as the interface for the incoming request and will also acts as the bridge between view and model

View is something that user will be looking into for eg form.
And when that form will be filled, the req will be forwarded to servlet.
So in the servlet we will be writing our main business logic.
i.e. validation, traversing part i.e. mving from 1 servlet to another
or from 1 jsp page to another, that everything will be taken care by servlet class.
It also acts as the bridge between view and model. Model puts or getrs data to/from database.

Other than this for db connectivity we will use DAO classes.
These are the normal java classes.These are for performing activities on db. So,

DAO ==> Data Access Object ==> Class which will be used to interact with the database. 
This class will contain the commands like insert, update, delete, select to perform task on the database

Utility classes are helper classes .

Utility(Helper) ==> Class that will acts as the helper class for performing some extra work that req by u but is not related to ur application. 
For eg, db connectivity, some conversion work , etc.
Here we can use it to connect and disconnect from the database

-----------------------------------------------
So how we will procedd with the project--

Display the data from the database:

1. Utility Class to establish the connection with the database
2. Model Class to map the table in the database as the object in this application
3. DAO class that will contain a function to perform select operation on the database and return the list of the corresponding model class objects
4. Using the servlet we will pass this list to the view
5. View will display the records to the user

---------------------------------------------
Lets start the project:

Create the database
create database income_expense;
use income_expense;

Tables:

User
-userid
-name
-email
-contact
-password

create table user(
	id int primary key auto_increment,
	name varchar(20),
	email varchar(30) unique,
	contact varchar(15),
	password varchar(10));

Income
-incomeid
-userid ==> foreign key(userid=>user)
-income amount
-income type
-income date
-description

create table income(
	id int primary key auto_increment,
	income double,
	income_type varchar(30),
	income_date date default now(),
	description varchar(200),
	user_id int,
	foreign key(user_id) references user(id));

Expense
-expenseid
-userid ==> foreign key(userid=>user)
-expense amount
-expense type
-expense date
-description

create table expense(
	id int primary key auto_increment,
	expense double,
	expense_type varchar(30),
	expense_date date default now(),
	description varchar(200),
	user_id int,
	foreign key(user_id) references user(id));

show tables;
---------------------------------------------
We will need a new workspace fo this.
file-->switch account-->new workspace-->IncomeExpense-->launch
Once it is loaded-->close welcome file--> add server in it-->
see servers near terminal-->click on no servers are available-->
select apache--> select tomcat v9.0(bcoz we have that u can check version 
od tomcat see inside building folder)-->next-->
browse for the tomcat location-->just select apache-tomcat-9.0.87 dont go inside.
-->selet folder-->next-->finish

Now we can check it if its running fine or not-->so click on the server-->
start-->started synchronized

Now goto browser and confirm it--->on the browser url type--> http://localhost:8080/
the error msg is from tomcat

Now we will add a neew prioject-- file-->new->dynamicweb project-->IncomeExpenseApp-->next-->finish

(now if u get error--> java version possibility-->right click IncomeExpenseApp-->properties-->
project facets-->click on java and near to version there is dropdown select 17-->Apply and close)

Now since we have installed xampp, xampp also has tomcat,Inside building file u can check tomcat version.

For db connectivity we need mysql jar file, which needs to be added
in a project. This jar file u will add once and tomorrow
if we update this jar file,
u will have to again download this jar file, replace the
current jar file with this new jar file,
And all this bcoz my db connectivity code is
 dependent upon this code in jar file,
The drver class that we require is part of this jar file.
So normally whart we do, we download jar file, put it in library of project,
As a student its fine, but for a long time project,
the manual updation is not good.
So for doing updation automatically, maven comes into picturre.
Maven is a project mgmt system which helps u to cover up
ur dependencies. The main focus of maven is, in ur project,
u have lot many dependencies, lot many jar files,
which needs updation, so all these responsibilitites u will hand over to maven.
i.e. download the jar file, get it ready for me,
etc. We will only use it.
So when external codes are there in a project, its good to use maven project. 

Then,Convert it into Maven Project.

Now, currently we have our normal web project,
we want to covert this into a maven project.
For that we need to follow some steps--
Now, maven project contains pom.xml file.

Right click on IncomeExpenseApp --> Configure-->
convert to maven project---> No need of changing group id,
artifact id, Normally the projects jar file gets created if its a core
java application, but in advance java applications whatever dependencies
u have, war file gets created. i.e. web archive file.
The version no. of the project is controlled in Version.
Group id is generally same as ur project,
artifact id we can change, in a single group we can have many projects,
so artifact id deals with trhat to identify each project.

So currently we r doing finish. Project Order Model(POM)
file gets created and pom.xml file gets added.
Also the projects icon change and small M is written there.

Now, all the dependencies are already registered in the maven 
repository. Repository is like a metadat of
all the libraries.
How we can access this repository--> so go on browser-->
url-->maven repository-->
https://mvnrepository.com/ -- this is the repositroy link.
now on the search bar of site, search mysql and u will 
get mysqlconnector/j which we want.-- click on it.

So my artifacts name is musql. There  are different artifacts 
that we r going to add from here--
we will work with the latest version only.
Wde can also see currently how many users are using it.
So click on th current version-- we will not download 
anything, just link it-- we will get the xml code,
we will just place this code on pom.xml file.
So copy this entire xml code, in pom.xml file
after </build> 

   </plugins>
  </build>
  <dependencies>
    	<!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j -->
		<dependency>
    		<groupId>com.mysql</groupId>
    		<artifactId>mysql-connector-j</artifactId>
    		<version>8.3.0</version>
		</dependency>
  </dependencies>
</project>

Now by default maven doesn't know servlet,
so we need to add dependencies regarding servlets too.

So search for servlet in the maven repository--
java servlet api--> copy xml code --> add as dependency

   </plugins>
  </build>
  <dependencies>
    	<!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j -->
		<dependency>
    		<groupId>com.mysql</groupId>
    		<artifactId>mysql-connector-j</artifactId>
    		<version>8.3.0</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
		<dependency>
    		<groupId>javax.servlet</groupId>
		    <artifactId>javax.servlet-api</artifactId>
		    <version>4.0.1</version>
		    <scope>provided</scope>
		</dependency>

  </dependencies>
</project>

getting error cannot find the declaration of element 'project'
possible root causes-- xml syntax error, missing or incorrect namespace declaration,
encoding issues, maven plugin issues, corrupted pom, n/w or repository issues,
ide-specific issues.
In our case we will do changes in namespace.

<project xmlns="https://maven.apache.org/POM/4.0.0" xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

i.e. make all the http to https.
save pom.xml
U can also right click on project-->maven-->update-->and errors will be gone.

Now inside java resources-->libraries-->maven dependencies-- the dependencies are downloaded.
-----------------------------------------------
M ==> we will be creating 3 classes-- User, Income, Expense

####################################################################################################33

Income Expense Application ===> User should be able to login and keep the track of the income details and expense details. We can also add new users. Able to display the income and expense details.

Register
Login
Add Income
Add Expense
Income List
Expense List
About Us

MVC

M ==> Model ==> Class represent the state of the application, data that is stored in the database is mapped as the object of this class
V ==> View ==> JSP page which will be the final response presented to the user(client).
C ==> Controller ==> Servlet which will acts as the interface for all the incoming request and will also acts as a bridge between view and model.

DAO ==> Data Access Object ==> Class which will used to interact with the database. This class will contain the commands like insert, update, delete, select to perform task on the database.

Utility ==> Class that will acts as the helper class for performing some extra work. Here we can use it to connect with the database

Example:

Display the data from the database:

1. Connect the database
2. Use DAO class to perform task on the database
3. Load/Create the object of the corresponding model class
4. Passing these objects to the view
5. View will display the data from the object

---------------------------------------------------------
Create the database and required tables in the database:

 create database aj_income_expense;

 use aj_income_expense;

Tables:

User
- userid
- name
- email
- contact
- password


create table user(
	id int primary key auto_increment,
	name varchar(20),
	email varchar(30) unique,
	contact varchar(15),
	password varchar(10));


Income
- income id
- userid ==> foreign key (userid=>user)
- income amount
- income type
- income date
- description

create table income(
	id int primary key auto_increment,
	income double,
	income_type varchar(30),
	income_date date default now(),
	description varchar(200),
	user_id int,
	foreign key(user_id) references user(id));


Expense
- expense id
- userid ==> foreign key (userid=>user)
- expense amount
- expense type
- expense date
- description

create table expense(
	id int primary key auto_increment,
	expense double,
	expense_type varchar(30),
	expense_date date default now(),
	description varchar(200),
	user_id int,
	foreign key(user_id) references user(id));


show tables;


file--switch workspace-->AJIncomeExpense

new-->dynamic web project-->Glitter IE Application-->Finish

index.jsp--

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>

<h1>GLITTER IE APP</h1>

<h4><a href="adduser.jsp">Register</a></h4>
<h4><a href="">Login</a></h4>
<h4><a href="addincome.jsp">Add Income</a></h4>
<h4><a href="">Add Expense</a></h4>
<h4><a href="">Income List</a></h4>
<h4><a href="">Expense List</a></h4>
<h4><a href="">Logout</a></h4>
<h4><a href="">Edit Profile</a></h4>
<h4><a href="">About Us</a></h4>
</body>
</html>

Now add all these jsp files---
adduser.jsp,addincome.jsp,addexpense.jsp,incomelist.jsp,expenselist.jsp

1st file that we will work is adduser.jsp
When user is going to register he is going to call this file.

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>

<form action="UserServlet" method="post">
	<table>
		<tr>
			<td>Email</td>
			<td><input type="email" name="email" required/></td>
		</tr>
		<tr>
			<td>Password</td>
			<td><input type="password" name="passwd1" required/></td>
		</tr>
		<tr>
			<td>Confirm-Password</td>
			<td><input type="password" name="passwd2" required/></td>
		</tr>
		<tr>
			<td><input type="submit" value="Register"/></td>
			<td><input type="reset"/></td>
		</tr>
	</table>
</form>

</body>
</html>

run--register-- see th o/p

from here we will go to UserServlet file.
So right click on project -->add a new servlet--pakg name com.glitter.controller-->UserServlet-->Finish

next we will create a pkg inside which we will add normal java class.

right click project-->new jAva class->pkg-->com.glitter.model-->User

write fields of user table , generate getter setter and toString.

package com.glitter.model;

public class User {
	private int id;
	private String name;
	private String email;
	private String contact;
	private String password;
	
	@Override
	public String toString() {
		return "User [id=" + id + ", name=" + name + ", email=" + email + ", contact=" + contact + ", password="
				+ password + "]";
	}
	
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public String getContact() {
		return contact;
	}
	public void setContact(String contact) {
		this.contact = contact;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
}



Now come to UserServlet file and read data from there.

here we require only doPost method.

package com.glitter.controller;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


@WebServlet("/UserServlet")
public class UserServlet extends HttpServlet {
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String email = request.getParameter("email");
		String password1 = request.getParameter("passwd1");
		String password2 = request.getParameter("passwd2");
		
		if(email!=null && password1.equals(password2)) {
			//insert the user details in the database
			
		}
		else {
			//display the error message
			request.setAttribute("errorMsg", 
					"Password and Confirm Password Does Not Match!");
			request.getRequestDispatcher("adduser.jsp").include(request, response);
		}
	}

}

run and see-->register-->same pwd UserServlet it is going wrong pwd same index page is showing.

in this line we r sending error msg to adduser,jsp
request.getRequestDispatcher("adduser.jsp").include(request, response);
so in adduser.jsp we will add following code--

<body>

<%String message = (String)request.getAttribute("errorMsg"); %>
<%if(message!=null){ %>

	<h3 style="color:red;"><%=message %></h3>

<%} %>

<form action="UserServlet" method="post">


run and see register error msg will be displayed.
but if there is no error then we want to insert the data.

So we will add 2 class files-- 1 for db connectivity 

so--> new class file--> pkg-->com.glitter.dao-->UserDao-->Finish
and for db connection--> new class file-->com.glitter.util-->DBConnect-->Finish

DBConnect.java--

package com.glitter.util;

import java.sql.Connection;
import java.sql.DriverManager;

public class DBConnect {
	public static Connection getConnection() {
		Connection con = null;
		
		try {
			Class.forName("com.mysql.cj.jdbc.Driver");
			con = DriverManager.getConnection("jdbc:mysql://localhost:3306/aj_income_expense","root","");
		}
		catch(Exception e) {
			e.printStackTrace();
		}
		
		return con;
	}

}


UserDao.java--

package com.glitter.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;

import com.glitter.util.DBConnect;

public class UserDao {
	Connection con = DBConnect.getConnection();
	
	public boolean addUser(String email, String password) {
		String sql = "insert into user(email,password) values(?,?)";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setString(1, email);
			ps.setString(2, password);
			
			int i = ps.executeUpdate();
			if(i>0) {
				return true;
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		
		return false;
	}

}



? is for parameterized query.

ps.setString(1, email); // means 1st ? is email.

int i =ps.executeUpdate(); // for running the query
if insert operation is successful then it returns the no. of rows,
that has been inserted.
Since we r inserting only 1 row, it will atleast return 1.

If this value is 0, i.e. no rows inserted, then its an error.
and false will be returned.

Now, db will be working then only it will be possible.

So now going back to UserServlet.java--

			boolean b = new UserDao().addUser(email, password1);
			
			if(b) { // if user is added successfully then go to index.jsp
				response.sendRedirect("index.jsp");
			}
			else { 
				request.setAttribute("errorMsg", 
						"User Already Exists!");
				request.getRequestDispatcher("adduser.jsp").include(request, response);
			}

So, with above code file is like--

package com.glitter.controller;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.glitter.dao.UserDao;


@WebServlet("/UserServlet")
public class UserServlet extends HttpServlet {
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String email = request.getParameter("email");
		String password1 = request.getParameter("passwd1");
		String password2 = request.getParameter("passwd2");
		
		if(email!=null && password1.equals(password2)) {
			//insert the user details in the database
			boolean b = new UserDao().addUser(email, password1);
			
			if(b) {
				response.sendRedirect("index.jsp");
			}
			else {
				request.setAttribute("errorMsg", 
						"User Already Exists!");
				request.getRequestDispatcher("adduser.jsp").include(request, response);
			}
		}
		else {
			//display the error message
			request.setAttribute("errorMsg", 
					"Password and Confirm Password Does Not Match!");
			request.getRequestDispatcher("adduser.jsp").include(request, response);
		}
	}

}


run server--register--

select * from user;

Now addincome.jsp---

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>
<form action="" method="post">
	<table>
		<tr>
			<td>Income Amount</td>
			<td><input type="number" name="incomeamount" required/></td>
		</tr>
		<tr>
			<td>Income Type</td>
			<td>
				<select name="incometype">
					<option>-----Select-----</option>
					<option>Salary</option>
					<option>Bonds</option>
					<option>Others</option>
				</select>
			</td>
		</tr>
		<tr>
			<td>Description</td>
			<td>
				<textarea rows="3" cols="21" name="description" required></textarea>
			</td>
		</tr>
		<tr>
			<td>User</td>
			<td></td>
		</tr>
		<tr>
			<td><input type="submit" value="Register"/></td>
			<td><input type="reset"/></td>
		</tr>
	</table>
</form>
</body>
</html>

in  <td>User</td>
    <td></td> this part we want to bring email address enererd in db. So as of now we r leaving it as it is.

Also, in index.jsp--
<h4><a href="addincome.jsp">Add Income</a></h4> // give header ref to Add income.

Now run-- add income-- u can see th combo box and everything. Next to user we will add combo box later.

model class maps db. 3 tables in db so 3 classes in model package.

income.java--

package com.glitter.model;

public class Income {
	private int id;
	private double income;
	private String incomeType;
	private String incomeDate;
	private String description;
	private int userId;
	
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public double getIncome() {
		return income;
	}
	public void setIncome(double income) {
		this.income = income;
	}
	public String getIncomeType() {
		return incomeType;
	}
	public void setIncomeType(String incomeType) {
		this.incomeType = incomeType;
	}
	public String getIncomeDate() {
		return incomeDate;
	}
	public void setIncomeDate(String incomeDate) {
		this.incomeDate = incomeDate;
	}
	public String getDescription() {
		return description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public int getUserId() {
		return userId;
	}
	public void setUserId(int userId) {
		this.userId = userId;
	}
	@Override
	public String toString() {
		return "Income [id=" + id + ", income=" + income + ", incomeType=" + incomeType + ", incomeDate=" + incomeDate
				+ ", description=" + description + ", userId=" + userId + "]";
	}
	
}


Expense.java--

package com.glitter.model;

public class Expense {
	private int id;
	private double expense;
	private String expenseType;
	private String expenseDate;
	private String description;
	private int userId;
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public double getExpense() {
		return expense;
	}
	public void setExpense(double expense) {
		this.expense = expense;
	}
	public String getExpenseType() {
		return expenseType;
	}
	public void setExpenseType(String expenseType) {
		this.expenseType = expenseType;
	}
	public String getExpenseDate() {
		return expenseDate;
	}
	public void setExpenseDate(String expenseDate) {
		this.expenseDate = expenseDate;
	}
	public String getDescription() {
		return description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public int getUserId() {
		return userId;
	}
	public void setUserId(int userId) {
		this.userId = userId;
	}
	@Override
	public String toString() {
		return "Expense [id=" + id + ", expense=" + expense + ", expenseType=" + expenseType + ", expenseDate="
				+ expenseDate + ", description=" + description + ", userId=" + userId + "]";
	}
	
	
}


Now to establish the connectivity we have created utility package-- DBConnect

Now coming to index.jsp file--

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>

<h1>GLITTER IE APP</h1>

<h4><a href="adduser.jsp">Register</a></h4>
<h4><a href="">Login</a></h4>
<h4><a href="addincome.jsp">Add Income</a></h4>
<h4><a href="addexpense.jsp">Add Expense</a></h4>
<h4><a href="IncomeServlet">Income List</a></h4>
<h4><a href="ExpenseServlet">Expense List</a></h4>
<h4><a href="">Logout</a></h4>
<h4><a href="">Edit Profile</a></h4>
<h4><a href="">About Us</a></h4>
</body>
</html>
 
Here whatever queries  i want to run on user, i will
write it in another package called as UserDao i.e.
if u want to do update delete on user table then
go to userdao.

similarly creating IncomeDao.class and ExpenseDao.class under Dao package

income mein kuch karna query run karna hai to incomdao pe
and expense pe kuch query run karna hai toh expensedao pe.

So after adduser.jsp we have added income.java and then addincome.jsp

<%@page import="com.glitter.dao.UserDao"%>
<%@page import="com.glitter.model.User"%>
<%@page import="java.util.List"%>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>

<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">

<%List<User> ul = new UserDao().getUserList(); %>
<form action="IncomeServlet" method="post">
	<table>
		<tr>
			<td>Income Amount</td>
			<td><input type="number" name="incomeamount" required/></td>
		</tr>
		<tr>
			<td>Income Type</td>
			<td>
				<select name="incometype">
					<option>-----Select-----</option>
					<option>Salary</option>
					<option>Bonds</option>
					<option>Others</option>
				</select>
			</td>
		</tr>
		<tr>
			<td>Description</td>
			<td>
				<textarea rows="3" cols="21" name="description" required></textarea>
			</td>
		</tr>
		<tr>
			<td>User</td>
			<td>
			<select name="userid">
			<%
				for(User u : ul){
			%>	
				<option value="<%= u.getId()%>"><%=u.getEmail() %></option>		
			<%
				}
			%>
			</select>
			</td>
		</tr>
		<tr>
			<td><input type="submit" value="Insert"/></td>
			<td><input type="reset"/></td>
		</tr>
	</table>
</form>
</div>
</body>
</html>

here we r taking 1st amount from the user,
Income type from the user,
The description from the user,
then we want to display user's list i.e. in user table what 
all records are there, we will extract that and show that,
for that we need to connect to userdao file which we have done in
<%List<User> ul = new UserDao().getUserList(); %>

so in our UserDao file we have added certain functions-- 

package com.glitter.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;

import com.glitter.model.User;
import com.glitter.util.DBConnect;

public class UserDao {
	Connection con = DBConnect.getConnection();
	
	public boolean addUser(String email, String password) {
		String sql = "insert into user(email,password) values(?,?)";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setString(1, email);
			ps.setString(2, password);
			
			int i = ps.executeUpdate();
			if(i>0) {
				return true;
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		
		return false;
	}
	
	public List<User> getUserList(){
		String sql = "select * from User";
		List<User> ul = new ArrayList<User>();
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ResultSet rs = ps.executeQuery();
			
			while(rs.next()) {
				User user = new User();
				user.setId(rs.getInt("id"));
				user.setName(rs.getString("name"));
				user.setEmail(rs.getString("email"));
				user.setContact(rs.getString("contact"));
				user.setPassword(rs.getString("password"));
				
				ul.add(user);
			}
			
			return ul;
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	
}


the getUserList() is returning a list of user.
so we wrote select * from user query,
with the preparedstmt we r going to go to the db,
which will return me a resultset.
And corresponding to that result set,
we will create object of User() class and set its value accordingly.
and bu ul.add(user) we will add it in the list.

and finally we will return complete ul to the variable that
i created in addincome.jsp-- i.e. <%List<User> ul = new UserDao().getUserList(); %>.
then in addincome.jsp using the for loop--

		for(User u : ul){
			%>	
				<option value="<%= u.getId()%>"><%=u.getEmail() %></option>		
			<%
				}

Same thing we have done for expense also.

So, in expensedao.java--

package com.glitter.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;

import com.glitter.model.Expense;
import com.glitter.model.Income;
import com.glitter.util.DBConnect;

public class ExpenseDao {
	Connection con = DBConnect.getConnection();

	public boolean addExpense(Expense inc) {
		String sql = "insert into expense(expense,expense_type,description,user_id) values(?,?,?,?)";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setDouble(1, inc.getExpense());
			ps.setString(2, inc.getExpenseType());
			ps.setString(3, inc.getDescription());
			ps.setInt(4, inc.getUserId());
			
			int i = ps.executeUpdate();
			
			if(i>0) {
				return true;
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		
		return false;
	}
	
	public List<Expense> getExpenseList(){
		List<Expense> expList = new ArrayList<Expense>();
		
		String sql = "select * from expense";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ResultSet rs = ps.executeQuery();
			
			while(rs.next()) {
				Expense exp = new Expense();
				exp.setId(rs.getInt("id"));
				exp.setExpense(rs.getDouble("expense"));
				exp.setExpenseType(rs.getString("expense_type"));
				exp.setExpenseDate(rs.getDate("expense_date").toString());
				exp.setDescription(rs.getString("description"));
				exp.setUserId(rs.getInt("user_id"));
				
				expList.add(exp);
			}
			
			return expList;
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	
}


expenselist.jsp--

<%@page import="com.glitter.model.Expense"%>
<%@page import="java.util.List"%>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>

<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">

<%List<Expense> expList = (List<Expense>)
				session.getAttribute("expList"); 
int count=1;
%>
	<table cellpadding="10">
		<tr>
			<th>ID</th>
			<th>Expense</th>
			<th>Expense Type</th>
			<th>Expense Date</th>
			<th>Description</th>
			<th>User ID</th>
			<th>Action</th>
		</tr>
		<%for(Expense e : expList) {%>
		<tr>
			<td><%=count++ %></td>
			<td><%=e.getExpense() %></td>
			<td><%=e.getExpenseType() %></td>
			<td><%=e.getExpenseDate() %></td>
			<td><%=e.getDescription() %></td>
			<td><%=e.getUserId() %></td>
		</tr>		
		<% } %>
	</table>
	
</div>
</body>
</html>

IncomeDao.java--

package com.glitter.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;

import com.glitter.model.Income;
import com.glitter.util.DBConnect;

public class IncomeDao {
	
	Connection con = DBConnect.getConnection();

	public boolean addIncome(Income inc) {
		String sql = "insert into income(income,income_type,description,user_id) values(?,?,?,?)";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setDouble(1, inc.getIncome());
			ps.setString(2, inc.getIncomeType());
			ps.setString(3, inc.getDescription());
			ps.setInt(4, inc.getUserId());
			
			int i = ps.executeUpdate();
			
			if(i>0) {
				return true;
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		
		return false;
	}
	
	public List<Income> getIncomeList(){
		List<Income> incList = new ArrayList<Income>();
		
		String sql = "select * from income";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ResultSet rs = ps.executeQuery();
			
			while(rs.next()) {
				Income inc = new Income();
				inc.setId(rs.getInt("id"));
				inc.setIncome(rs.getDouble("income"));
				inc.setIncomeType(rs.getString("income_type"));
				inc.setIncomeDate(rs.getDate("income_date").toString());
				inc.setDescription(rs.getString("description"));
				inc.setUserId(rs.getInt("user_id"));
				
				incList.add(inc);
			}
			
			return incList;
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
}




run--> register-->on successful register it comes to index page--
then going to add income--in users drop down u can see the email ids of all the users.
select any email id-- give income amount lets say 10000,income type--salary-- description april 2022
-- insert

do select * from income; in db

then we want to display the income list. 
i.e. list of my income, my expenses i want to display.
so we will come to index.jsp--
for displaying income list i will go to my IncomeServlet
and for showing expense list, i will go to ExpenseServlet.

Now these 2 req will not go as post req but as get req.

that means inside these 2 servlets, i will need doGet().

IncomeServlet.java

package com.glitter.controller;

import java.io.IOException;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import com.glitter.dao.IncomeDao;
import com.glitter.model.Income;

@WebServlet("/IncomeServlet")
public class IncomeServlet extends HttpServlet {
	Income inc = new Income();
	IncomeDao incd = new IncomeDao();
	
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		HttpSession session = req.getSession();
		List<Income> incList = incd.getIncomeList();
		session.setAttribute("incList", incList);
		resp.sendRedirect("incomelist.jsp");
	}
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		Double income = Double.parseDouble(request.getParameter("incomeamount"));
		String incomeType = request.getParameter("incometype");
		String description = request.getParameter("description");
		int userId = Integer.parseInt(request.getParameter("userid"));
		
		inc.setIncome(income);
		inc.setIncomeType(incomeType);
		inc.setDescription(description);
		inc.setUserId(userId);
		
		boolean b = new IncomeDao().addIncome(inc);
		if(b) {
			response.sendRedirect("index.jsp");
		}
		else {
			response.sendRedirect("addincome.jsp");
		}
	}

}

so inside doGet() we connected to our db and we r going to read the files..
with the help of IncomeDao.
So in IncomeDao,we have a getIncomeList(), i.e. public List<Income> getIncomeList(){
where we are doing select * from income; i.e. getting all the income from the income table.
and putting the records in my incList.

So, in incomeServlet we will call this method.
for that we will use a session object

IncomeDao incd = new IncomeDao();

and inside doGet() we will create object of HttpSession.

i.e.
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		HttpSession session = req.getSession();
		List<Income> incList = incd.getIncomeList();
		session.setAttribute("incList", incList); // setting the attribute incList
		resp.sendRedirect("incomelist.jsp"); // sending the response to incomelist.jsp.
	}


i.e. when user will click to see incomelist, the req will go to income servelt,
from income servlet it will connect to incomedao file which will bring complete list from th db,
and add the list into the session object. and then the response will be forwarded to incomelist.jsp

So, in our incomelist.jsp we will do following changes---
In incomelist.jsp we will show this entire list.

So this code which we have putted in our income servlet we will put that in our
ExpenseServlet.jsp also.


ExpenseServlet.java

package com.glitter.controller;

import java.io.IOException;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import com.glitter.dao.ExpenseDao;
import com.glitter.model.Expense;

@WebServlet("/ExpenseServlet")
public class ExpenseServlet extends HttpServlet {	
	Expense exp = new Expense();
	ExpenseDao expd = new ExpenseDao();
	
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		HttpSession session = req.getSession();
		List<Expense> expList = expd.getExpenseList();
		session.setAttribute("expList", expList);
		resp.sendRedirect("expenselist.jsp");
	}
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		Double expense = Double.parseDouble(request.getParameter("expenseamount"));
		String expenseType = request.getParameter("expensetype");
		String description = request.getParameter("description");
		int userId = Integer.parseInt(request.getParameter("userid"));
		
		exp.setExpense(expense);
		exp.setExpenseType(expenseType);
		exp.setDescription(description);
		exp.setUserId(userId);
		
		boolean b = new ExpenseDao().addExpense(exp);
		if(b) {
			response.sendRedirect("index.jsp");
		}
		else {
			response.sendRedirect("addincome.jsp");
		}
	}

}

From incomeServlet.jasp and ExpenseServlet.jsp the response is going to incomelist.jsp
and expenselist.jsp.

So run and click incomelist-->in the url req fwd to incomelist
and on clicking ExpenseList--> in the url req fwded to expenselist.

Basicallly, on clicking the req is going to servlet which is getting redirected to jsp page.

So first we will create incomlist.jsp that same thing we will do in expenselist.jsp.

<%List<Income> incList = (List<Income>)
				session.getAttribute("incList"); -- list is added inside session object.
In incomeServlet, while doing setAttribute, we took the name "incList". So same name we will use for getAttribute.
Also, session.getAttribute("incList") is returning a value of type object, so we will need to typecast,(List<Income>).

We have applied for loop to create rows.

incomelist.jsp-----

<%@page import="com.glitter.model.Income"%>
<%@page import="java.util.List"%>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>

<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">

<%List<Income> incList = (List<Income>)
				session.getAttribute("incList"); 
int count=1;
%>
	<table cellpadding="10">
		<tr>
			<th>ID</th>
			<th>Income</th>
			<th>Income Type</th>
			<th>Income Date</th>
			<th>Description</th>
			<th>User ID</th>
			<th>Action</th>
		</tr>
		<%for(Income i : incList) {%>
		<tr>
			<td><%=count++ %></td>
			<td><%=i.getIncome() %></td>
			<td><%=i.getIncomeType() %></td>
			<td><%=i.getIncomeDate() %></td>
			<td><%=i.getDescription() %></td>
			<td><%=i.getUserId() %></td>
		</tr>		
		<% } %>
	</table>
	
</div>
</body>
</html>

run and click on income list--- see the o/p.

Same thing we will do with expenselist also---

expenselist.jsp--

<%@page import="com.glitter.model.Expense"%>
<%@page import="java.util.List"%>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>

<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">

<%List<Expense> expList = (List<Expense>)
				session.getAttribute("expList"); 
int count=1;
%>
	<table cellpadding="10"> ---------- padding because data will otherwise look congested.
		<tr>
			<th>ID</th>
			<th>Expense</th>
			<th>Expense Type</th>
			<th>Expense Date</th>
			<th>Description</th>
			<th>User ID</th>
			<th>Action</th>
		</tr>
		<%for(Expense e : expList) {%>
		<tr>
			<td><%=count++ %></td>
			<td><%=e.getExpense() %></td>
			<td><%=e.getExpenseType() %></td>
			<td><%=e.getExpenseDate() %></td>
			<td><%=e.getDescription() %></td>
			<td><%=e.getUserId() %></td>
		</tr>		
		<% } %>
	</table>
	
</div>
</body>
</html>

run-- expense list-- if only 1 expense is seen then add more-- by clicking--add expense--
eg 6000, bill payment,etc.

So in the index.jsp page when we will clack on Expense List link,
the req will go to ExpenseServlet, And this will go as get req.
In the ExpenseDao file we have already extractiong list of all the expenses.
See ExpenseDao it is returning list of expense.
which we are trying to read in ExpenseServlet by creating object of Dao file.
ExpenseDao expd = new ExpenseDao();
and then I am adding the list in the session object expList,
so that whenever I feel like using it, i can extract it from the session.
and then i am redirecting to expenselist.jsp .

So in expenseList.jsp--> the list that we have putted in expList object,
we are extracting that, and after extracting we r displaying by putting for loop.

Now we dont want to see this incomelist expenses for every user.
these options of adding the income, adding the expense, expenselist, incomelist,
should come when the user is already existing.
i.e. user is not a new user.
The new user should get the option of register / login.

So the list that we r currently showing should be visible, when we r already loggedin.

So, for that we will do some settings here. We will add the css file,
So, under webapp folder-->we will create new folder-->resources-->finish 
ur image file, video file, java script file,css files u will put here.

then u need to add 1 more folder inside resources-->CSS-->finish
Inside this folder we will find all the css files. 
So, inside CSS folder-->new-->css file-->main.css

Now this main.css file i want to be applied on my project.

click on src folder--> we r going to create another jsp file--> sidebar.jsp

In sidebar.jsp-- all the links that I have in index.jsp we will put in it.

sidebar.jsp--- cut alll the h4 from index.jsp and paste here.

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>


<h4><a href="adduser.jsp">Register</a></h4>
<h4><a href="">Login</a></h4>
<h4><a href="addincome.jsp">Add Income</a></h4>
<h4><a href="addexpense.jsp">Add Expense</a></h4>
<h4><a href="IncomeServlet">Income List</a></h4>
<h4><a href="ExpenseServlet">Expense List</a></h4>
<h4><a href="">Logout</a></h4>
<h4><a href="">Edit Profile</a></h4>
<h4><a href="">About Us</a></h4>

</body>
</html>

Now we will link our css file to sidebar.jsp file.
so, in sidebar.jsp file--

<title>Insert title here</title>
<link href="resource/css/main.css" rel="stylesheet"/>---------
</head>

then we r adding all the options in a division.

<div>
<h4><a href="adduser.jsp">Register</a></h4>
<h4><a href="">Login</a></h4>
<h4><a href="addincome.jsp">Add Income</a></h4>
<h4><a href="addexpense.jsp">Add Expense</a></h4>
<h4><a href="IncomeServlet">Income List</a></h4>
<h4><a href="ExpenseServlet">Expense List</a></h4>
<h4><a href="">Logout</a></h4>
<h4><a href="">Edit Profile</a></h4>
<h4><a href="">About Us</a></h4>
</div>

In sidebar.jsp we will put a condition, based on the user has loggedin or not what options to show.

next we r giving teh id to div, Bcoz on the basis of id we will get the css.

<div id="sidebar">
	<h4><a href="adduser.jsp">Register</a></h4>
	<h4><a href="">Login</a></h4>
	<h4><a href="addincome.jsp">Add Income</a></h4>
	<h4><a href="addexpense.jsp">Add Expense</a></h4>
	<h4><a href="IncomeServlet">Income List</a></h4>
	<h4><a href="ExpenseServlet">Expense List</a></h4>
	<h4><a href="">Logout</a></h4>
	<h4><a href="">Edit Profile</a></h4>
	<h4><a href="">About Us</a></h4>
</div>

Now in the main.css we will do styling of sidebar.
this is all part of web designing.

#sidebar{
	width: 200px;
	height: 100%;
	background-color: navy;
	position: fixed;
	padding: 10px;
	left: 0%;
	top: 0%;	
	font-variant: small-caps;
}

#sidebar a{ -------------------------  sidebar ke andar ke anchor tags will have diff styling.
	color: white;
	text-decoration: none;
}

#sidebar a:hover {
	color: aqua;
}

Now, in url--in index.jsp--> u will only get GLITTER IE APP.
change the url and instead of index.jsp write-- sidebar.jsp--

And u will get styled sidebar.

Now coming back to index.jsp--

<body>
<div id="main">
	<h1>GLITTER IE APP</h1>
</div>
</body>

we gave id to div main. Then we will include jsp page sidebar.jsp

<body>
<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">
	<h1>GLITTER IE APP</h1>
</div>
</body>

run--> now since Glitter IE App is in a division, it will come down only.

main.css--

#sidebar{
	width: 200px;
	height: 100%;
	background-color: navy;
	position: fixed;
	padding: 10px;
	left: 0%;
	top: 0%;	
	font-variant: small-caps;
}

#sidebar a{
	color: white;
	text-decoration: none;
}

#sidebar a:hover {
	color: aqua;
}

#main{
	padding-left: 250px;
}

Now in every jsp page we will include sidebar file
after body tag and add complete code inside div tag whose id is main.
and before closing body tag end div too.

<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">

addincome,addexpense,incomelist,adduser,addincome,index.jsp,expenselist

adduser.jsp--

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>


<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">

<%String message = (String)request.getAttribute("errorMsg"); %>
<%if(message!=null){ %>

	<h3 style="color:red;"><%=message %></h3>

<%} %>

<form action="UserServlet" method="post">
	<table>
		<tr>
			<td>Email</td>
			<td><input type="email" name="email" required/></td>
		</tr>
		<tr>
			<td>Password</td>
			<td><input type="password" name="passwd1" required/></td>
		</tr>
		<tr>
			<td>Confirm-Password</td>
			<td><input type="password" name="passwd2" required/></td>
		</tr>
		<tr>
			<td><input type="submit" value="Register"/></td>
			<td><input type="reset"/></td>
		</tr>
	</table>
</form>
</div>
</body>
</html>




note--> main.css contains styling code.

run-->links are coming click on any link content is coming.

in the head part  of sidebar we link the css file.

Now we will design login page 
new-->jsp page-->login.jsp-->finish

its layout will be similar to adduser.jsp

so ctrlA,ctrlC,ctrlV

we will change action in this page. SO instead of going to UserServlet,
goto LoginServlet.

We will not take confirm password.

We will take password only once during login.

Instead of register button its a login button.

And after the table i.e. </table> we will add 1 link--

<a href="adduser.jsp">Click here to register</a>----- in case the user is not logged in from before.

login.jsp----------

<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>


<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">

<%String message = (String)request.getAttribute("errorMsg"); %>
<%if(message!=null){ %>

	<h3 style="color:red;"><%=message %></h3>

<%} %>

<form action="LoginServlet" method="post">
	<table>
		<tr>
			<td>Email</td>
			<td><input type="email" name="email" required/></td>
		</tr>
		<tr>
			<td>Password</td>
			<td><input type="password" name="password" required/></td>
		</tr>
		
		<tr>
			<td><input type="submit" value="Login"/></td>
			<td><input type="reset"/></td>
		</tr>
	</table>
	<br/><br/>
	<a href="adduser.jsp">Click here to register</a>
</form>
</div>
</body>
</html>
</html>

now in sidebar.jsp---

in the login reference--

	<h4><a href="adduser.jsp">Register</a></h4>
	<h4><a href="login.jsp">Login</a></h4> ------------------------------
	<h4><a href="addincome.jsp">Add Income</a></h4>

run---->login--->url(login.jsp)--give email and pwd-->url going to LoginServlet

So now adding login servlet to java controller--package--com.glitter.controller-->
LoginServlet--> finish

delete complete code inside it. We will add our code later on.

we will need doPost() so we will override it.

in doPost() we will read our email,

package com.glitter.controller;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/LoginServlet")
public class LoginServlet extends HttpServlet {
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String email= req.getParameter("email");
		String password = req.getParameter("password");
	}
}

now this user id and pwd we will send to DAO,Now in DAO 1st we will search,
So we will have 2 objects , 1 of user and 2nd of UserDao.


@WebServlet("/LoginServlet")
public class LoginServlet extends HttpServlet {
	User u = new User(); -------------------------
	UserDao ud = new UserDao(); ------------------
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {


Now in UserDao class we will create 1 method to which we will pass these 2 values.

and from there it will return boolean values

UserDao.java


public User userLogin(String email) {
		
	}

in LoginServlet.jsp, this will go as a req to UserDao.java

String email= req.getParameter("email");
		String password = req.getParameter("password");
		
		boolean b = ud.userLogin(email, password);
	} 

So now addding more code to UserDao.java---

1st we will write a query.
			e.printStackTrace();
		}
		
		return null;
	}
	
	public User userLogin(String email,String Password) {
		String sql = "select * from user where email=? and password=?";
		User user = new User();
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setString(1, email);
			ps.setString(2, password);
			
			
			ResultSet rs = ps.executeQuery();
			
			while(rs.next()) {
				user.setId(rs.getInt("id"));
				user.setName(rs.getString("name"));
				user.setEmail(rs.getString("email"));
				user.setContact(rs.getString("contact"));
				user.setPassword(rs.getString("password"));
			}			
			return user; -------- if it finds the user it will return me the user otherwise it will return me null
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
}

So in our LoginServlet--
package com.glitter.controller;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import com.glitter.dao.UserDao;
import com.glitter.model.User;

@WebServlet("/LoginServlet")
public class LoginServlet extends HttpServlet {
	User u = new User();
	UserDao ud = new UserDao();
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String email= req.getParameter("email");
		String password = req.getParameter("password");
		HttpSession session=req.getSession();
		
		u = ud.userLogin(email, password);
		if(u.getEmail().equals(email) && u.getPassword().equals(password)) {
			session.setAttribute("user", u);
			resp.sendRedirect("index.jsp");
		}
		else {
			req.setAttribute("errorMsg", 
					"Email and Password Does Not Match!");
			req.getRequestDispatcher("login.jsp").include(req, resp);
		}
		
		
	}
}


now come to sidebar.jsp-- bcoz if user gets logged in then only he will get the sidebar code.

<body>
<%User user=(User)session.getAttribute("user"); %>------------
<div id="sidebar">

<%if(user!=null){ %> if user!= null , that means login succesful,then he will get some sidebar , 
<%} %>

<%if(user==null){ %> if user == null, login not successful then he will get some sidebar
<%} %>

So, our sidebar.jsp is like--

<%@ page import = "com.glitter.model.User" %>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
<link href="resource/css/main.css" rel="stylesheet"/>
</head>
<body>
<%User user=(User)session.getAttribute("user"); %>  ---------- here if we r getting user, then only user should be added in a session.And sidebar with option is dispalyed, i.e. <%if(user!=null){ %>
<div id="sidebar">
<h4><a href="index.jsp">Home</a></h4>
<%if(user!=null){ %>

	
	<h4><a href="addincome.jsp">Add Income</a></h4>
	<h4><a href="addexpense.jsp">Add Expense</a></h4>
	<h4><a href="IncomeServlet">Income List</a></h4>
	<h4><a href="ExpenseServlet">Expense List</a></h4>
	<h4><a href="">Logout</a></h4>
	<h4><a href="">Edit Profile</a></h4>
	<h4><a href="">About Us</a></h4>

<%} %>

<%if(user==null){ %>
	<h4><a href="adduser.jsp">Register</a></h4>
	<h4><a href="login.jsp">Login</a></h4>
<%} %>
	
<h4><a href="">About Us</a></h4>
	
</div>
</body>
</html>

run-->
1st we r getting 4 options.
hoem,register,login,about us

login-- see the o/p.

SO till now what we did-- if the user has logged in then we will add 
value in our session object. And this will happen when the user will click on the login
page , the req will goto LoginServlet.

In the login servlet we are reading these values,
We have used dao here bcoz in our db, these values should be already there.

then we creaetd 1 func userlogin-- where we are trying to extract email id and pwd from db.
if email id and user is not there in my db, then this rs will be null.

but if email id pwd exist, then in the rs object we will fill the value
i.e. id name email pwd. and to user we r sending user.
Then in login servlet, we will do further checking.
Now if user!= null then only we will get sidebar options.

Now what we want to do is logout. On logout, we will invalidate the sesion which we started.

SO in case of Logout we will send our rew to LoginServlet only.
form login.jsp req is going to LogiServlet which is a post req,
and when we will logout, that will go as a get req.
 
So, sidebar,jsp--

	<h4><a href="ExpenseServlet">Expense List</a></h4>
	<h4><a href="LoginServlet">Logout</a></h4>

So, in LoginServlet we will add doGet().


in th doGet() we will retrieve session object, and we will simply invalidate teh session and indirect to index.jsp.


	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		HttpSession session = req.getSession();
		session.invalidate();
		resp.sendRedirect("index.jsp");
	}

run and see-- do login  once logout index page comes.

Next code we will do is related to updating values.

After logging in edit profile link comes,
if we notice, we have saved only email id and password of user in table.
not name , contact details, etc.

So we will design another jsp page, updateuser.jsp--- this will come after login.

so in sidebar.jsp--

	<h4><a href="LoginServlet">Logout</a></h4>
	<h4><a href="updateuser.jsp">Edit Profile</a></h4>
	

<%} %>

now in the updateuser.jsp,
since user is already logged in, i can extract user's data.

<body>
<%User user = (User)session.getAttribute("user");%>
</body>

user contains all the values of user.

now we will create form where we will take all the values input from user like
name value, email value, whatever it wants to update.

So we will take adduser.jsp form only from jsp to /div-- copy everything and paste
or updateuser.jsp file is shared u can just copy paste..

We have taken hidden field. Now in both adduser and update user case req is going to UserServlet only.
So to distinguish and to get to know from where the req has come, from adduser or updateuser..
I have added hidden values.
<form action="UserServlet" method="post">
		<input type="hidden" name="action" value="updateuser"> --- here the value is update user but in case of adduser,
the value is adduser. With user.getId() and all the values from the db will also get filled there.


<%@page import="com.glitter.model.User"%>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

<%User user = (User)session.getAttribute("user");%>

<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">

	<form action="UserServlet" method="post">
		<input type="hidden" name="action" value="updateuser"> 
			<table>
				<tr>
					<td>Id</td>
					<td><input type="text" name="id" value="<%=user.getId()%>" readonly="readonly"></td>
				</tr>

				<tr>
					<td>Name</td>
					<td><input type="text" name="name" value="<%=user.getName()%>" required="required"></td>
				</tr>

				<tr>
					<td>Email</td>
					<td><input type="email" name="email" value="<%=user.getEmail()%>" required="required"></td>
				</tr>

				<tr>
					<td>Contact</td>
					<td><input type="text" name="contact" value="<%=user.getContact()%>" required="required"></td>
				</tr>

				<tr>
					<td>Password</td>
					<td><input type="password" name="passwd1" value="<%=user.getPassword()%>" required="required"></td>
				</tr>


				<tr>
					<td><input type="submit" value="Save"></td>
					<td><input type="reset" value="Reset"></td>
				</tr>
			</table>

		</form>
	</div>

</body>
</html>

Now in userservlet, where we r checking the pwd and correct email,
we will put this complete code inside if stmt.

we will read the action here.We are adding action stme ,
 bcox to user servlet req is coming from both add user and update user,
for distinguishing them . i am using add user and update user.

if(action!=null && action.equals("adduser")) {}-- write complete authentication code inside this.

else if(action!=null && action.equals("updateuser")) {
			
		}-- here we will add code for user updation.

So if we will just run the code--
login--edit profile-- if u will notice all ur fields are filled.
id is not changeable rest all u can change.
Now when u will edit and u will press save buttton, the req will goto
User Servlet only.
And in User Servlet we will read all the fields, and need to update
table. So we will create our HttpSession object again.

HttpSession session = request.getSession(); 
and then i will read all the fields of the object.

So, UserServlet.java-----

package com.glitter.controller;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import com.glitter.dao.UserDao;
import com.glitter.model.User;


@WebServlet("/UserServlet")
public class UserServlet extends HttpServlet {
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String email = request.getParameter("email");
		String password1 = request.getParameter("passwd1");
		String password2 = request.getParameter("passwd2");
		String action = request.getParameter("action");
		if(action!=null && action.equals("adduser")) {
		
		if(email!=null && password1.equals(password2)) {
			//insert the user details in the database
			boolean b = new UserDao().addUser(email, password1);
			
			if(b) {
				response.sendRedirect("index.jsp");
			}
			else {
				request.setAttribute("errorMsg", 
						"User Already Exists!");
				request.getRequestDispatcher("adduser.jsp").include(request, response);
			}
		}
		else {
			//display the error message
			request.setAttribute("errorMsg", 
					"Password and Confirm Password Does Not Match!");
			request.getRequestDispatcher("adduser.jsp").include(request, response);
		}
		}
		else if(action!=null && action.equals("updateuser")) {
			HttpSession session = request.getSession();
			String name = request.getParameter("name");
			String contact = request.getParameter("contact");
			int id = Integer.parseInt(request.getParameter("id"));
			
			User user = new User();
			user.setId(id);
			user.setName(name);
			user.setEmail(email);
			user.setContact(contact);
			user.setPassword(password1);
			
			boolean b = new UserDao().updateUser(user); ------- here the req will goto UserDao updateuser().
			
			if(b) { ------------------------------------ if values got updated, in updateUser(), b iset to true.
				session.setAttribute("user",user); ------ if b true then set attribute user and redirect to index page.
				response.sendRedirect("index.jsp");
			}
			}
	}

}

Now, in UserDao class, boolean b = new UserDao().updateUser(user);----- we will create updateUser().

USerDao.java--

public boolean updateUser(User u) {
		String sql = "update user set name=?, email=?, contact=?, password=? where id=?";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setString(1, u.getName());
			ps.setString(2, u.getEmail());
			ps.setString(3, u.getContact());
			ps.setString(4, u.getPassword());
			ps.setInt(5, u.getId());
			
			int i = ps.executeUpdate();
			
			if(i>0) {
				return true;
			}
		}catch (Exception e) {
			e.printStackTrace();
		}
		
		return false;
	}


run---edit profile-->user--abc contact-123

index.jsp--

<%@page import="com.glitter.model.User"%>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Glitter IE App</title>
</head>
<body>
<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">
	<h1>GLITTER IE APP</h1>
	<%User user = (User)session.getAttribute("user");%>
	<%if(user!=null){ %>
	<h2>Welcome, <%=user.getEmail() %></h2>
	<%} %>
</div>
</body>
</html>

Now run---> login-- goto add income, in the user field, we are getting combo box which gives list 
of emails available. But i dont want that, I want the email of logged in user only.
Not other user's email.
So,
in add income, add expense, we will extract our user again.

so addincome.jsp--

<body>

<%User user = (User)session.getAttribute("user");%>----------- wherever u require user info,extract that from user.
<jsp:include page="sidebar.jsp"></jsp:include>
<div id="main">


and scroll down , we created a combo box earlier delete that--

i.e. delete this code--

			<select name="userid">
			<%
				for(User u : ul){
			%>	
				<option value="<%= u.getId()%>"><%=u.getEmail() %></option>		
			<%
				}
			%>
			</select>

and add--

we will create here a normal text field, with the values filled in it.

	<tr>
			<td>Description</td>
			<td>
				<textarea rows="3" cols="21" name="description" required></textarea>
			</td>
		</tr>
		<tr>
			<td>User</td>
			<td>
			<input type="text" name="userid" value="<%=user.getEmail() %>" readonly>-------------------
			</td>
		</tr>
		<tr>
			<td><input type="submit" value="Insert"/></td>
			<td><input type="reset"/></td>
		</tr>



now referesh in browser and see, only the logged in email id is coming.

So this same thing we will do in add expense also.

add expense.jsp--

<body>

<%User user = (User)session.getAttribute("user");%>

and

<td>User</td>
			<td>
			<input type="text" name="userid" value="<%=user.getEmail() %>" readonly>-------------------
			</td>

infact in incomelist and expenselist also we want this user's values only.

So, incomelist.jsp-- the req is going to IncomeServlet which we can see in sidebar.jsp
And from IncomeServlet, the req is going to addincome.jsp and with us we r taking
inc object. So along with inc object, we will take user's id also.

See in the doGet()-- we r calling getIncomeList() , lly in case of expense, getExpenseList()
what if to these funcs, we will send the id value and the func will return only those id's values.

So little changes we will do.
We will extract user from session.

IncomeServlet.java---------

	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		HttpSession session = req.getSession();
		User user = (User)session.getAttribute("user");
		List<Income> incList = incd.getIncomeList(user.getId());
		session.setAttribute("incList", incList);
		resp.sendRedirect("incomelist.jsp");
	}

IncomeDao.java----- in getIncomeList()--------

public List<Income> getIncomeList(int uid){ ----------------------------------------
		List<Income> incList = new ArrayList<Income>();
		
		String sql = "select * from income where user_id=?"; ---------------
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setInt(1, uid);  ----------------------------------------
			ResultSet rs = ps.executeQuery();

run-- see income list

now same changes we will do in expense Servlet.java and ExpenseDao.

protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		HttpSession session = req.getSession();
		User user = (User)session.getAttribute("user");-----------------
		List<Expense> expList = expd.getExpenseList(user.getId());---------
		session.setAttribute("expList", expList);
		resp.sendRedirect("expenselist.jsp");
	}
	
expenseDao---

public List<Expense> getExpenseList(int uid){
		List<Expense> expList = new ArrayList<Expense>();
		
		String sql = "select * from expense where user_id=?";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setInt(1, uid);
			ResultSet rs = ps.executeQuery();
			

run--login---Now we r getting error in addexpense and add income case.

goto addincome.jsp--

instead of writing like this-- <input type="text" name="userid" value="<%=user.getEmail() %>" readonly>
it was taking id value taht is why it is giving error.

we will write like--

		<td>User</td>
			<td>
			<input type="hidden" name="userid" value="<%= user.getId()%>"/>
			<input type="text" value="<%=user.getEmail() %>" readonly> 
			</td>

			
Same in addexpense.jsp--

<tr>
			<td>User</td>
			<td>
			<input type="hidden" name="userid" value="<%= user.getId()%>"/>
			<input type="text" value="<%=user.getEmail() %>" readonly> 
			</td>
		</tr>

Now run and see--

Now lets say in index page, i want to show totla income
and totalexpense.

index.jsp---
<%@page import="com.glitter.dao.IncomeDao"%>
<%@page import="com.glitter.model.User"%>

	<%if(user!=null){ %>
	<h2>Welcome, <%=user.getEmail() %></h2>
	<h3>Total income = <%=new IncomeDao().getTotalIncome(user) %></h3> -- passing user object
	<%} %>

Now coming to IncomeDao class---

public double getTotalIncome(User user) {
		String sql = "select sum(income) as totalincome from income where user_id=?";
		
		try {
			
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setInt(1, user.getId());
			
			ResultSet rs = ps.executeQuery();
			if(rs.next()) {
				return rs.getDouble("totalincome");
			}
			
		}catch (Exception e) {
			e.printStackTrace();
		}
		
		return 0;
	}
	
run--login -- now it is aslo giving total income.

Now just like totakl income we can put total expense and total bal.

So, index.jsp--
<%@page import="com.glitter.dao.IncomeDao"%>
<%@page import="com.glitter.dao.ExpenseDao"%>
<%@page import="com.glitter.model.User"%>

	<%if(user!=null){ %>
		<h2>Welcome, <%=user.getEmail() %></h2>
		
		<h3>Total Income = <%=id.getTotalIncome(user)%></h3>
		
		<h3>Total Expense = <%=ed.getTotalExpense(user)%></h3>
		
		<h3>Final Balance = <%=id.getTotalIncome(user) - ed.getTotalExpense(user)%></h3>
	<%} %>

ExpenseDao---


public double getTotalExpense(User user) {
		String sql = "select sum(expense) as totalexpense from expense where user_id=?";
		
		try {
			
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setInt(1, user.getId());
			
			ResultSet rs = ps.executeQuery();
			if(rs.next()) {
				return rs.getDouble("totalexpense");
			}
			
		}catch (Exception e) {
			e.printStackTrace();
		}
		
		return 0;
	}
	



run-- login-- see

Now coming to incomelist.jsp---

we have one action tab--
<th colspan="2">Action</th>---------------------
and
			<td><%=i.getDescription() %></td>
			<td><%=i.getUserId() %></td>
			<td><a href="IncomeServlet?action=edit&id=<%=i.getId() %>">Edit</a></td>---------------
			<td><a href="IncomeServlet?action=delete&id=<%=i.getId() %>">Delete</a></td>------------

so in action we have 2 cols-- edit and delete.

href="IncomeServlet?action=edit&id=<%=i.getId()%>--In case of both, edit and delete, the req is going to IncomeServlet.

we r giving action value here, so along with action, we also want to take id value for performing particular action.

Now the req is going as a doget() in Income Servlet, we will extract the value of the action--

So, IncomeServlet.java--

instead of this--
		HttpSession session = req.getSession();
		User user = (User)session.getAttribute("user");
		List<Income> incList = incd.getIncomeList(user.getId());
		session.setAttribute("incList", incList);
		resp.sendRedirect("incomelist.jsp");

write this--

protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		HttpSession session = req.getSession();
		
		User user = (User) session.getAttribute("user");
		
		String action = req.getParameter("action");
		
		if(action!=null && action.equals("delete")) {
			int id = Integer.parseInt(req.getParameter("id"));
			
			boolean b = incd.deleteIncome(id); ----------------- inside IncomeDao class create this method
			
			if(b) {
				resp.sendRedirect("IncomeServlet");
			}
		}
		
		else { -------------------------------------------- remember to put rest thing inside else part
		
			List<Income> incList = incd.getIncomeList(user.getId());
			session.setAttribute("incList", incList);
			resp.sendRedirect("incomelist.jsp");
		}
	}

IncomeDao---


public boolean deleteIncome(int id) {
		String sql = "delete from income where id=?";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setInt(1, id);
			
			int i = ps.executeUpdate();
			
			if(i>0) {
				return true;
			}
		}catch (Exception e) {
			e.printStackTrace();
		}
		
		return false;
	}

Next is update operation---

IncomeServlet--

		else if(action!=null && action.equals("edit")) {
			int id = Integer.parseInt(req.getParameter("id"));
			
			Income inc = incd.getIncome(id); // 1st we will extract 1 single income.For which we will create method in IncomeDao class.
		}

IncomeDao--


	public Income getIncome(int id) {
		String sql = "select * from income where id=?";
		
		try {
			
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setInt(1, id);
			
			ResultSet rs = ps.executeQuery();
			if(rs.next()) {
				Income inc = new Income();
				inc.setId(rs.getInt("id"));
				inc.setIncome(rs.getDouble("income"));
				inc.setIncomeType(rs.getString("income_type"));
				inc.setIncomeDate(rs.getDate("income_date").toString());
				inc.setDescription(rs.getString("description"));
				inc.setUserId(rs.getInt("user_id"));
				
				return inc; ------- from here the income is getting returned to incomeservlet, which we will set in session by session.setAttribute("inc", inc);
			}
			
		}catch (Exception e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
IncomeServlet.jsp---

else if(action!=null && action.equals("edit")) {
			int id = Integer.parseInt(req.getParameter("id"));
			
			Income inc = incd.getIncome(id);
			
			session.setAttribute("inc", inc); -------- so inc added in session object
			
			resp.sendRedirect("updateincome.jsp"); -------- then we will create a new page updateincome.jsp
		}

run login-- incomelist-- edit-- see url --


So create new jsp page--> updateincome.jsp -- this page is similar to addincome.jsp
Here we will extract the income session object i.e. inc which we setted in IncomeServlet.jsp

Income inc = (Income) session.getAttribute("inc");

extracting all the values inside inc,

<td><input type="number" name="incomeamount" value="<%=inc.getIncome()%>" required="required"></td>

U can share copied code--

updateincome.jsp--

<%@page import="com.glitter.model.Income"%>
<%@page import="com.glitter.model.User"%>
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
	pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>


	<%
	User user = (User) session.getAttribute("user");
	Income inc = (Income) session.getAttribute("inc");
	%>
	<jsp:include page="sidebar.jsp"></jsp:include>

	<div id="main">
		<form action="IncomeServlet" method="post">
			<input type="hidden" name="id" value="<%=inc.getId()%>">
			<input type="hidden" name="action" value="updateincome">
			<input type="hidden" name="userid" value="<%=user.getId()%>">
			<table>
				<tr>
					<td>Income</td>
					<td><input type="number" name="incomeamount" value="<%=inc.getIncome()%>" required="required"></td>
				</tr>

				<tr>
					<td>Income Type</td>
					<td><select name="incometype" >
							<option><%=inc.getIncomeType() %></option>
							<option>-----Select-----</option>
						<option>Salary</option>
						<option>Bonds</option>
						<option>Others</option>
					</select></td>
				</tr>

				<tr>
					<td>Description</td>
					<td><textarea rows="3" cols="20" name="description"><%=inc.getDescription() %></textarea>
					</td>
				</tr>

				<tr>
					<td>User</td>
					<td><input type="text" value="<%=user.getEmail()%>" readonly></td>
				</tr>

				<tr>
					<td><input type="submit" value="Update"></td>
					<td><input type="reset" value="Reset"></td>
				</tr>
			</table>

		</form>

	</div>


</body>
</html>


run--login--income list-- edit-- see the values are coming already filled.

<form action="IncomeServlet" method="post">------ now if u will notice the req is going back into IncomeServlet as a post req.
i.e. when we r clicking on update the req is going once again to IncomeServlet as a post req.

So to distinguish, just like we did in add income case,
i.e. in Income Servlet to distinguish betw add income req and update income req,

addincome.jsp---

<%List<User> ul = new UserDao().getUserList(); %>
<form action="IncomeServlet" method="post">
<input type="hidden" name="action" value="addincome"> -----------------------------
	<table>
		<tr>


Then in our IncomeServlet in doPost()--we will read our action.

protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		HttpSession session = request.getSession();
		String action = request.getParameter("action");--------
		
		User user = (User)session.getAttribute("user");	--------	


while in the case of updateincome-- 

<input type="hidden" name="action" value="updateincome">

So now in incomeservlet--

so finally IncomeServlet is like--


package com.glitter.controller;

import java.io.IOException;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import com.glitter.dao.IncomeDao;
import com.glitter.model.Income;
import com.glitter.model.User;

@WebServlet("/IncomeServlet")
public class IncomeServlet extends HttpServlet {
	Income inc = new Income();
	IncomeDao incd = new IncomeDao();
	
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		HttpSession session = req.getSession();
		
		User user = (User) session.getAttribute("user");
		
		String action = req.getParameter("action");
		
		if(action!=null && action.equals("delete")) {
			int id = Integer.parseInt(req.getParameter("id"));
			
			boolean b = incd.deleteIncome(id);
			
			if(b) {
				resp.sendRedirect("IncomeServlet");
			}
		}
		else if(action!=null && action.equals("edit")) {
			int id = Integer.parseInt(req.getParameter("id"));
			
			Income inc = incd.getIncome(id);
			
			session.setAttribute("inc", inc);
			
			resp.sendRedirect("updateincome.jsp");
		}
		else {
		
			List<Income> incList = incd.getIncomeList(user.getId());
			session.setAttribute("incList", incList);
			resp.sendRedirect("incomelist.jsp");
		}
	}
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		HttpSession session = request.getSession();
		String action = request.getParameter("action");
		
		User user = (User)session.getAttribute("user");		
		
		
		Double income = Double.parseDouble(request.getParameter("incomeamount"));
		String incomeType = request.getParameter("incometype");
		String description = request.getParameter("description");
		int userId = Integer.parseInt(request.getParameter("userid"));
		
		if(action!=null && action.equals("addincome")) {
			inc.setIncome(income);
			inc.setIncomeType(incomeType);
			inc.setDescription(description);
			inc.setUserId(userId);
		
			boolean b = new IncomeDao().addIncome(inc);
			if(b) {
				response.sendRedirect("index.jsp");
			}
			else {
				response.sendRedirect("addincome.jsp");
			}
		}
		else if(action!=null & action.equals("updateincome")) {
			inc.setIncome(income);
			inc.setIncomeType(incomeType);
			inc.setDescription(description);
			inc.setUserId(userId);
			
			int id = Integer.parseInt(request.getParameter("id"));
			inc.setId(id);
		
			boolean b = new IncomeDao().updateIncome(inc); ------ creating func in IncomeDao
			if(b) {
				response.sendRedirect("IncomeServlet");
			}
		}
		
		
	}

}

Then in IncomeDao.java---

public boolean updateIncome(Income inc) {
		String sql = "update income set income=?, income_type=?, description=?, user_id=? where id=?";
		
		try {
			PreparedStatement ps = con.prepareStatement(sql);
			ps.setDouble(1, inc.getIncome());
			ps.setString(2, inc.getIncomeType());
			ps.setString(3, inc.getDescription());
			ps.setInt(4, inc.getUserId());
			ps.setInt(5, inc.getId());
			
			int i = ps.executeUpdate();
			
			if(i>0) {
				return true;
			}
		}catch (Exception e) {
			e.printStackTrace();
		}
		
		return false;
	}


run---


==========================================================
#----------------------------------------------------------

===========================

SpringBoot

===========================

with java prog application--
we can create desktop appli, web applic, gamin app, mobile application.


using internet i can connect machines.
with network 2 devices connect.
Multiple devices connect with one another is web.
Now web applications are the applications running using internet.
files are accessible from 1 machine to another using web.
Web applications in todays life r divided into 3--
static, dynamic, PWA- Progressive Web Applications.

Static web applications by html. Almost similar age as java.
There is an application design called browser which
is used to access html pages.
url has domain name-ip addr-- filename
this is based on req-resp model.
This is a behaviour of static web page.

the machine requesting is my client and
the achine giving response is server.

Then dynamic websites came into place. 
Dynamic web app r again categorized into 2.
Client and server r there--
client has browser. And client req the browser.
The prog lang can be added to the web application.
Now where exactly my application will run according to
that we have client side programming language
and server side programming language.
We also call them client side scripting or server side 
scripting.

Client side scripting is done using a lang called
java script. Here from ur url, u initiate some req,
which is sent to a server.
In a server we have multiple files, These files can
have html+js code, to check dynamically that whatevver 
u r typing is right or wrong, 
Now my server here look for the requested page
and returns the response,which comprise of
js code. Now this js code, will run on the browser,
on the client side. No execution. Within
a browser only we have an interpreter which 
executers the js code, So it will run on my clent machine only.
So my browser should be capable enough to run my java script. 
If the browser is not capable enough,then that
code won't be executed , only the html part will be visible to it.
Here the security check is also coming on my client side.


And if i have any file to be executable on the server, then 
we cant use java sript.
Then comes server side scripting.
The browser contains req The server doesnot just contain 
html pages but also my application which can be by java,python,C#
Now my application will run on server m/c.
From which a dynamic html code will be generated.
This dynamic html code is sent back to browser as response.
Because browser doesnt understand python, java, etc.
It understands html,css, js.
So, in server scripting, i can write programs
to connect with db, security, trxs happening,,etc.

Now java is 1 of the 1st programming lang to 
come up with this.
Web application should be running continuously 
in server.

So we have springboot fraework.

In java, when we have jsp-- ur front end and backend 
ur client and server both are in single m/c.
Frontend was developed using java script and backend 
by java.The jsp pages gets converted into html while giving response.
Everything was done in 1 single appliaction,
in 1 single m/c.

But many problems started coming bcoz of this.
1.Changeability-- if iam changing 1 part of
my prog, other part might stop working,
If something im changing in frontend, then 
the change needs to be there in backend,
and vice versa.
Also I have 1 single frontend.
for eg, we have backend, using servlet we r connecting db,
using jsp we r reading it and displaying it.
No more we r using desktop to access our web application,
we have mobile apps also.
So what i want is using common backend i can connect with 
multiple devices becus we cannot access servlets through mobile.

Then scalability was also an issue.
So we have 2 parts. Frontend and backend.
Client m/c has browser.
Another device has servers. One frontend server, another backend server.
So req from client's browser goes to frontend server, which
can be creaed using technologies like js,angular, react,etc.
Now frontend framework receives the data and 
give everything to backend server which can have 
java prog, python prog,php,etc.
This backend server will save the data in the database.
And interact with it.
this backend server then interacts with frontend server
and gives the result, which gives to browser.

Now in springboot we will not have frontend part.
We will only understand backend part.

For backend access we use springboot framework
but it is not restricted to backend only.
Using it we can develop web application using mvc architecture,
restapi(backend),microservice.

Springboot is a spring framework only minus XML configurations.

Springboot mostly has autoconfiguration.
Springboot applications are standalone applications.
Only create the springboot application and that will be directly executable.
Using JVM. So what client needs is a JVM installed in
their machine.

DB u will have to externally configure.

And this is possible if u r creating ur application from a tool
 spring initializer.

1st come to https://start.spring.io/

project-- for java prog lang we use maven.
gradle-groovy and kotlin can be used if ur prog lang is springboot.

what is maven-- jar files are downloaded externally,
deploying my project. Maven is a project mgmt tool.
Which takes care of dependencies. 
Maven also does testing of project.
Maven also takes care of deplyment of project.

so, project--maven
lang-java
springboot version-- 3.1.8 -- go with 3.1.x
project metadata-- 
group id is a domain name if its itvedant.com then group id is com.itvedant
i.e. write the companies domain name in reverse.
artifact is the project name i.e. firstapp
name firstapp
description-- First project for Spring Boot.
package name-- com.itvedant.firstapp
packaging jar
java 17
generate

Now zip file will get installed in the system.
open that zip file. Extract.
double click folder-- u will see gitignore file.
.md-  is like a read me file.
mvnw are like ur maven tools to execute the application.

mvnw is a maven wrapper.

pom.xml is a main configuration file for maven.

Right click on pom.xml open with notepad++
the dependencies are there, and springboot starter test 
for testing purpose.

src folder contains main and test folder.
main folder again has java and resources--
java folder contains all java files.
resources contains images, configurations,
html files, extra files needed for execution.

now inside java->com->itvedant->firstapp there
is a java file created-- FirstappApplication.java

open this file and check. Its a file, which contains 
main method, which is going to start ur project.

Now the folder where folder got extracted,
on its addr bar, write cmd.
 
D:\learning\aj\SpringBoot\firstapp>
java home error--

Now java_home is an environment var which we r
going to create, to hold the addr of jdk.

steps-- open folder where jdk is installed.
c folder --> prog files --> java--> now select the version of 
jdk u want to use. here we have jdk17.

Copy the path of jdk17-- C:\Program Files\Java\jdk-17
now goto start-- search environment variables--edit env var--
syatem properties--click on env varaibls--
system var-- 
new--JAVA_HOME 
path-- C:\Program Files\Java\jdk-17

ok ok

Now select the folder where mvnw is there.

D:\learning\aj\SpringBoot\firstapp>mvnw

11 jdk will not run have 17 or above.

from oracle site we download jdk.

if jdk is not there inside java folder,
then download jdk from oracle website-- i.e. search oracle jdk--
windows-- click on 1st link-- windows--x64 msi installer.
we need 17 or above. Anything below 17 will not work.

Now in pom.xml file of springboot-- right click and open--
if in ur system-- jdk 21 is there , then change java.version to 21
or else if 17 is there then let it be 17.

cmd prompt--

D:\learning\aj\SpringBoot\firstapp>mvnw

then to run project--
D:\learning\aj\SpringBoot\firstapp>mvnw spring-boot:run

we got build success message.

Now to see if something is running or not,
open src forlder-- main--java==com--itvedant--project folder--then open FirstappApplication.java file in notepad.

package com.itvedant.firstapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FirstappApplication {

	public static void main(String[] args) {
		SpringApplication.run(FirstappApplication.class, args);
		
		System.out.println("Welcome to SpringBoot");  ----------------------------------------------------------
	}

}

then save and close file.
then come to cmd prompt-- and run the same cmd--

D:\learning\aj\SpringBoot\firstapp>mvnw spring-boot:run
Above build success , u will see Welcome to SpringBoot printed.

Now since we r going to build a web application-- it continuously runs.
Its not like , it will run for 1 time and close.
The web apps are deployed on server.

Now creating a web application.
the project that we ran before got downloaded, ran and ended.

Now lets suppose we have a client and server.
client has browser.It will send a req to server.
So we need something on server, who will listen to these req and give response back to client.
That something on server is an application called as web server.
Web server is a s/w.
So for java there are variety of applications that can act as web server, like--
apache tomcat,glassfish server then jboss server.

these r all s/ws which i can install on my os.

these servers listens to any incoming req,
understand the req, escalate the req to proper location where the req can be handled.
and give the response via the web server will be given to browser.

So what we will do, we will deploy our .class files i.e. compiled java files into 
these web servers, Now this web server runs continuosly until i ask it to stop.

So in servlet+jsp-- we downloaded web server,which required external setup,
and then we deployed our files.

But in springboot,
we just need to give a starter file as starter-web,inside which the default server, tomcat 
server is embedded.
i.e. u donot need to externally download and install server like in normal spring projects or jsp+servlet projects.

So both in the case of mvc and restapi, we are supposed to tell about starter-web.

Both mvc and restapi works on req res model.

Now on browser , coe to the portal-- start.spring.io -- this we call as spring initializer

project-maven-
java
3.1.X
group- com.itvedant
artifact-- firstwebapp
description-- First Web App project for Spring Boot
packaging-- jar
java 17--- whichever u have selected in ur project 21 or 17.

now click on add button to add dependency. These dependencies are starter files or starters..

So u have many starter files or development tools for web applications, for dbs,for security,etc
actuators for monitoring web application, etc.

now search spring web and read about it,
build web including restful applications, using spring mvc,Uses apache tomcat as default embedded container.
----- click on it and it gets selected.

--click generate

extract downloaded folder.

day 39-- 49:42.--https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

now under src, if u will see resource folder, thenearlier static and templates were not there.
These r coming only to support ur web applications.
Static folder is used to hold ur static files like images,htmls, static htmls, audio files,video files,
etc.
templates is for dynamic htmls.
Now we will run the project.
So in previous cmdline-- exit

D:\learning\aj\SpringBoot\firstwebapp -- cmd

D:\learning\aj\SpringBoot\firstwebapp>mvnw springboot:run

now see our tomcat got installed and its running. And if any req will come on port no. 8080- then only it will listen 
otherwise not.

Now open the browser tab and type localhost:8080 -- u got whitelabel errorpage.
This says the req is coming to tomcat, but it doesnt know how to handle it.Tomcat is not getting any homepage
to handle it.

Now we will see how to do this same thing in visual studio,

becuse once ide is there, we will not do the complicated steps.
The ide will go to spring initializer, and download the project.

for closing running tomcat server press ctrl+c, y, exit.

start vs code.--
we will add an extension in vs related to springboot.

come to extention tab of vs-- type springboot --- selet the one with the leaf sign--

Spring Boot Extension Pack
v0.2.1
VMware
vmware.com
2,292,852
(17)
A collection of extensions for developing Spring Boot applications
Install

-- this has spring initializer and dashboard which is required for running project.
-- click install

1:18--

now once its installed--

now in view tab--command pallete-- type spring initializer-- select spring initializer create a maven proj--
-- version-- 3.1.11 --- select lang java-- now update the domain name--com.itvedant
-- then add artifact id -- springmvcapp-- jar--17-- ultimately vs will go to spring initializer only and will
dpwnload the zip file. --so now we will add the starter-- spring web web -- select that-- so now 1 dependency selected--
-- press enter-- now u will get file explorer-- to select the location where project is to be created.
-- D:\learning\aj\SpringBoot--- generate into this folder -- now zip file downloaded and extracted.
--- now in vscode click open-----

now if u will see java--- main-- resources-- static and template folders are there
also in java-- click SpringmvcappApplication.java

now to run this project -- in the vs code there is a button like object added.
that is ur springboot initializer. click that and u will see a section created called appsection and here
u can see ur app.-- just hover over the project name and u will see a play button. click that.

start ur project. Now on localhost:8080 u can see ur project running

if u want to stop then stop from the appsection and refresh localhost:8080. Its not working.

once again start--  and refresh localhost:8080 u will get o/p.

this is indicating that our tomcat server is working properly.

stop it for now.

MVC---

Now lets say if ur project is closed. i.e. visual studio is closed.

click vs code-- open folder-- goto springmvcapp -- and ur project opens.

Now MVC is an architecture or an approach for programmers to create a web application.

Model view controller.

Now u have view-- now from the client req comes to web server.
which is a tomcat server. 
Now tomcat has a controller which redirects request.
But how?-- so in our controller, we have methods.
method1() and method2() which maps to some url.
So if we decorate /m1 with method1() and /m2 with method2().
now if req comes for /m1 from client,
the controller will redirect /m1 to method1().
if for /m2 , then to method2().

SO url mapping is very imp.

now inside method there is some logic.
Now this method return a view file.

so controller pass the req to the method according to url,
the response given by the method is given to the view,
which is known to my controleer.
And via my controller we tomcat server will know.

So controller directs working of the application.

Now if html files are dynamic,
in that case controller goes to model,create model,
gives it to some method or redirects to the response
to view to show.
so controller is central point of the application.
controller connects with model.
controller redirects the request to view, where exactly
the model has to be dispalyed.
and gives back response to a point.

But here if u will see, everything is packed together in 1 application.
i.e. the person should be very good in producing web pages, 
sql, business logic, etc. which is not really feasible.
So we have frontend and backend.

now start project in vs.
and in browser -- localhost:8080/
this / is our url.
now in view we donot have any html page 
or view page designed for /
that is why we r getting 404 error.

So come to vs appli stop execution.
go to project explorer.
1st thing that we will add is controller and a view.

so 1st adding view file.
now resources->static-> add a new file-->home.html

now in vs u have some html code snippets.
And 1 of the snippet is--
html:5 enter

<body>
    <h1>Welcome to SpringBoot</h1>
</body>

now, we will add the controller to direct
the sender, that this is the view file,i
want to return to my browser.

Now in project mgmt part--
hover over java\com\itvedant\springmvcapp
and click on springmvcapp--
i.e. select the last packge which has SpringmvsappApplication.java
now in this same pkg, we will have a new file,
DemoController.java

no what we got here is a normal java class.
Now to declare a democontroller as controller class
to whom my req should be directed to,
so for this we will use annotation.
@Controller which is coming from org.springframework.stereotype.Controller
i.e.

@Controller
public class DemoController {
    
}

controller class is the one where
the req will be directed from tomcat.

and the controler class contains some
methods that we will map with the req url.
inside class,to do mapping, we have
@RequestMapping annotation 
 where we specify the url .
and from this method we return the name of the
view file( html file) that the tomcat will return as response.

So, DemoController.java

package com.itvedant.springmvcapp;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;


@Controller
public class DemoController {
    @RequestMapping("/")
    public String home() {
        return "home.html";
    }
    
}

annotation is like an extended info u r providing to ur class.

In spring framework, annotations were not compulsary,
Their programmer could have done configurations using xml file also.
but in springboot xml files doesnot exist.
and everything has to be done using xml only.
So annotations are compulsary.
And using annotation i can give my url.
This helps in autoconfiguration.


Now run ur file-- localhost:8080/
See o/p.

now come back to code and write sysout stmt.

everutime u r requesting a url , ur method is getting called.



@Controller
public class DemoController {
    @RequestMapping("/")
    public String home() {
        System.out.println("Home method");
        return "home.html";
    }
    
}

now these changes will not be directly escalated to tomcat.
So after making the changes, u will have to redeploy,
entire project on the tomcat.

so stop the project and rerun it.
Because this is a .java file.
This need to be compiled by java first,
and the compiled code, i.e. .clss file will 
be given to the tomcat.

So stop the execution and restart.

localhost:8080--
when i ran this , home method got printed on my terminal.

Now trying out 1 more eg.

Now stop the curret execution.
come to prj explorer
static folder-- add file--aboutus.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=>, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>
        About Us
    </h1>
    <p>
        Lorem ipsum dolor sit amet consectetur, adipisicing elit. Sint neque similique voluptatem error eum. Totam, recusandae autem! Eaque distinctio labore laudantium, ratione ad iure nam dignissimos perferendis explicabo sint facilis!
        
    </p>
</body>
</html>

now go to -- DemoController.java

package com.itvedant.springmvcapp;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;




@Controller
public class DemoController {
    @RequestMapping("/")
    public String home() {
        System.out.println("Home method");
        return "home.html";
    }
    @RequestMapping("/about")
    public String xyz() {
        System.out.println("XYZ method called");
        return "aboutus.html";
    }
    
  
}


Now u can start ur project-- localhost /about.

now what if i cahnge the url from /about to /aboutus
theni need to deploy my project again.

So for any changes i need to stop my project and rstart.
But u can make the changes to apply as soon as 
u did.
for now stop the project.

there is a starter file called springboot dev tools.
which we can add in our project means
there are some external jar files--
which we can tell our maven to add it in our project,
so that this change and deploy becomes automated.
But now our project is created.
So how to do this after our project is created.
so, goto pom.xml file.
in dependency, we already have 1 starter file.
spring-boot-starter-web.
another for starter test , for testing purpose.
in future we will need dependency for security,
validation,for db connectivity,
that we can do by doing the steps--
so goto pom.xml -- right click anywhere on the file--
add starter--
now 1 dependency we added earlier to get our static folder, template folder,etc
tomcat by which we r deploying our project,
is also a web dependency.
so what i want to do now is -- whatever little changes i
am doing on my project, for that i dont have 
to restart my project.
in the search bar-- search for dev tools--it
proveides fast application restarts,live reloads,
and configuration for enhanced developments.
-- got selected 2 dependencies-- now because this 
is to be used only for the development purpose,
we r supposed to remove this dependency after our project is in
the production envi.-- so now press enter-- proceed

now goto file-- click on autosave--then u got some pop-up,
and press yes.

Now just to check if its working properly
or not, start ur project--
In democontroller change url from about to aboutus.

check in url-- its changed.

i.e. anything we will change now, our project will 
get automatically started, and deployed.

change url to /about and see the changes will be there.

Now there is a file got application.properties
file in resources folder--
click on it-- 
now this file is made available to everyone by default.
anyone can put their configuration into the project.
so here any configuration related to project is written.
here we write in the form of a key-value pair.
for eg- the tomcat server always start on port no. 8080.
what if i dont want to launch my server on port 8080,
what if i want to give some user defined port now.
So any particular application related things are
putted over here.
there are some predefined properties also.

so lets say if i want to launch on port no. 9090,
then, 

application.properties--
server.port=9090

now see our project is deployed on port 9090.
http://localhost:9090/about

so mostly application.properties u use for
db connectivity,server change, file upload download setting,
for security purpose to setup default username and
password.

Now some core concepts that we will utilize 
in our application that we have adapted from ur spring framework.
as spring framework is mostly used to create MVC
(front end + back end) based web applications.
Spring boot framework is mostly used to create REST Apis.
3############################################################### All the notes of SpringBoot ############################################
Spring Boot => Framework

Framework => Generic Structure(Base) upon which application can be developed.

It allows you to focus on application logic  rather than investing time to create things from the scratch

Since it provide with Generic Structure code maintainability becomes easy.

Framework is a code library that make application development quicker and easier by giving basic patterns or structure for building reliable, scalable application

Types of Frameworks in Web Application Development

1. Frontend Framework
	React
	Angular
	Vue
	Jquery
	Bootstrap

2. Backend Framework

	Python - Django
	PHP - Laravel
	Java - Spring, Spring Boot

Frontend vs Backend

Spring Boot Framework ==> Is built on the top of the Spring Framework which is used to create the enterprise applications using java programming language

Spring Framework is mostly used to create MVC(frontend + backend) based web applications 

Spring Boot Framework is mostly used to create the REST APIs.
Now after u have learnt rest api's then only u can learn about microservices.

Spring Boot = Spring Framework + Embedded Web Server - XML Configuration

Create a web application using Spring Boot, a web server is embedded within the project as the part of the framework

In Spring Boot most of the configuration that used to be implemented manually in the Spring application is automated.

Spring Boot Project

https://start.spring.io/

Maven - Java 
Project Management Tool 
-> Manage the dependencies 
Spring Boot projects are created using starter jar(this files comprises of the predefined codes needed in the application and some of them also include the autoconfiguration codes). Using pom.xml file of the maven we can manage this dependencies
-> Build the project (jar for your project will be created that can be deployed in the another machine)
-> Test the project (command line of the maven can be used to activate the test case in order to unit test the application)


Install JDK 17
Install Visual Studio Code

-----------------------------------------------
Spring Core Concepts - This concept form the basis of the Spring Boot project and they come from Spring framework

1. IoC (Inversion of Control)
2. Dependency Injection
3. Aspect Oriented Programming (AOP)

The IOC is imp--- Inversion of Control--

cources--> master in full stack web dev with aws--> creating restapis

We r not going to concentrate more on mvc.
because now projects arenot created using mvc.

now in mvc model is nothing but data, which i will be
passing from controller to view.
After that view creates some dynamic web pages 
where dynamic web pages are the pages
which are created as templates.
This concept we have seen in django
where u use jinja syntax {{}}, put some variables
in it or loops, etc. This gives little bit of dynamic
code within ur html.

Son now when we run our app the req goes to tomcat server.

Now we will see IOC


IoC (Inversion of Control)

class Student{
	int id;
	String name;
	float marks;
	
	void print(){}
}

main(){
		1			2
	Student s = new Student();
	s.print();
}
A()
{ Student a=null;
  a.print();
}

now uptill now, we were creating object of the class. And with this object I can call
the methods of class.i.e. we created reference variable and through this variable,
we access method. But will i be able to access the obj outside this main method?
No right, So what if i want to create an obj and i want to make it accessible across
the project, What if i will write method A, then will my compiler give any error?

now this is aproblem for me, where me as a programmer have forgotten to create the object like Student s = null;
what if i want to automate this task of obj creation.
i.e. as i create class, i want my object to be created.
Because i am giving inversion of control-- i.e. till now i was having a control of
creation of an obj. so now rather than me creating an obj, as a programmer i will
just specify, if this is the class then create its objects
also this obj i want it to be publicly accessible everywhere.
And this is possible using IOT and dependency Injection.
They both work together.

IoC will create the objects, configure and manages their lifecycle

In Spring Boot, IoC is implemented using java annotations

Now u can think of this as container or a bucket, which contains
all the objects.And this container is accessible to the entire application.
This conatiner is called as Aplication Context Contorller.

So here ApplicationContext container will be used to manage the object created using IoC. 
These objects inside the container are known as beans,

So now instead of saying obj of a class, we will say bean of a class.
Bean of an employee, etc.

Now,As the process of the java object creation and managing their lifecycle is not done by the programmer, 
instead is done by the container it is called inversion of control.

Annotation for implementing IoC:
1. @Component - Class level, class is the component whose object has to be created and maintained by the container. 
This annotation can be used only on the class

2. @Configuration - class level, indicate that this class contains some @Bean methods. 
We cannot create @Bean methods without declaring the class using @Configuration

3. @Bean - method level, where the object of the class is created by the programmer 
but this object will be placed inside the container and will be managed by the container. 
Any method annotated with @Bean annotation will be called automatically when the application starts.

The following three annotation are subtypes of the @Component annotation and 
will show the default behaviour of the @Component ie. the object of the class on 
which we will apply the following annotation will be automatically created and placed inside the container

4. @Controller / @RestController - Also used to handle the request that will come from the client
 
1:43------day40
create a new java class in a folder containing DemoController.java-- Student.java

we will annotate this class with @component. This indicates the obj of this calss will
be automatically created and will be placed inside this container.

so now stop ur app and start it. See the beans.  The methods that we have created 
are not static methods.
So obj of all will be placed inside my beans.

1:44

Now the constructor is called as soon as the obj gets created.

Student.java

package com.itvedant.springmvcapp;

import org.springframework.stereotype.Component;

@Component
public class Student {
    public Student(){
        System.out.println("Student Object Created");
    }
}

So ioc 's work is to add or when lifecycle of objects are closed.
then to remove object from the app contxt conatiner.
Now how to add obkjects i.e. beans inside container?
Beans are something which are completely accessible
inside projects. Now how do we add objects in this bucket..
so we use annotations.
@component .

Object is created by jvm.
After object creation, the constructor is called.

The bean name is same as the class name.

Now @component acts as parent of @controller, 
@service, @Repository.

So if we create @controller then that class obj will
also get cretaed. Same with @service and @repository
obj of all these class are created and added in controleer.

@repository is used for hibernate framework,
for creating the orm.

@bean is a methiod level annotation.

@Bean - method level, where the object of the class is created by the programmer 
but this object will be placed inside the container and will be managed by the container. 
Any method annotated with @Bean annotation will be called automatically when the application starts.

now create BeanAnnotationDemo.java inside SpringMVCApp---

package com.itvedant.springmvcapp;

public class BeanAnnotationDemo {
    @Bean
    public void BeanCheck(){
        System.out.println("Bean Method Called Automatically");
    }
}

Start ur application And see. 
Componect class bean is getting created but our BeanCheck() is not getting called.
The bean methods can be automatically called.
But it has 1 compulsion.
The class which is containing a bean method,
U will have to identify that class also.
i.e. mark that class also differently so that the spring boot
is aware that this class contains bean().
Because how it will know which class contains bean method?
So this is done by addding @Configuration

@Configuration tells taht this class may contain bean method.

so above method will be like--

package com.itvedant.springmvcapp;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class BeanAnnotationDemo {
    @Bean
    public void BeanCheck(){
        System.out.println("Bean Method Called Automatically");
    }
}
But how we will use bean method for IOC?
SO bean method can be used to cretae an object where we will be writing
some logic. According to this logic we can decide when we will
create or not create object.
But the obj creation process will be automated.

for eg, we r creating this class Employee. which we r creating as a normal class.



https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN
30:00--- 41

Employee.java---

package com.itvedant.springmvcapp;
//normal class
public class Employee {
    public Employee(){
        System.out.println("Employee object created\n");
    }
    
}

now i want the obj of this class to be created using bean().
So go to BeanAnnotationDemo.java

@Configuration
public class BeanAnnotationDemo {
    @Bean
    public void BeanCheck(){
        System.out.println("Bean Method Called Automatically");
    }
    @Bean // to call this method automatically and create object automatically.
    public Employee createEmployee(){
        return new Employee();
    }
}

now see in the terminal-- obj of main method,bean method, employee method all called.
Also see the beans folder-- bean name is same as class name.

but what if i want to give a different name to my bean.

@Bean(name="emp") // to call this method automatically and create object automatically.
    public Employee createEmployee(){
        return new Employee();
    }

refresh bean the name of the bean changed.

now objects are created, but how do i use these objects, for that we have dependency injections.

DI are used to get reference of the obj inside the container.
The container is containing the object. To use this obj,
we will inject the ref of the obj and give it to the ref variable using DI.
The dependency injection is implemented using @Autowired.

There are actually 3 ways to implement dependency injection, they are--
1. Field based dependency inj,
Here, u can create any class or field, and whatever obj u have created inside the container,
u only want the ref of those objs and u want to use it in ur project.

For eg in class Student, we created some method,

@Component
public class Student {
    public Student(){
        System.out.println("Student Object Created");
    }
    public void studing(){
        System.out.println("Student is studying");
    } 
}

then employee contains some method-- Employee.java--

package com.itvedant.springmvcapp;

import org.springframework.context.annotation.Bean;

public class Employee {
    public Employee(){
        System.out.println("Employee object created\n");
    }
    

    public void working(){
        System.out.println("Employee is working");
    }
    
}
now my objects have been created, and i want to call these methods.
Now for calling these methods, i will nedd object's reference,
which we will get with the help of dependency injection.
So in my controller class, we can inject reference/address of obj of student class,
using which i can call these methods.

So goto DemoController.java

i am not going to do something like--
Student s = new Student; becuse this is already +nt in my container.

rather we will be annotating this field, with an annotation called as autowired, so that
the ref of the type student will be given to s . i.e.

@Autowired
Student s;

this annotation autowired the the reference of the bean type Student inside the conatiner,
with ref variable, s.

now in the home() we can call s.studying();

package com.itvedant.springmvcapp;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;




@Controller
public class DemoController {

    @Autowired
    Student s;
    @RequestMapping("/")
    public String home() {
        System.out.println("Home method");
        s.studing();
        return "home.html";
    }
    @RequestMapping("/about")
    public String xyz() {
        System.out.println("XYZ method called");
        return "aboutus.html";
    }
    
  
}

now obviously this method will not get called by itself.
we will have to give ref to the url ("/"), as it is described inside its controller method only.
So go to browser, localhost:8080/

and we can see this obj call inside container.

this is field based ependency injection.

53: -- 41-- https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

lly we can do for employee too.

package com.itvedant.springmvcapp;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;




@Controller
public class DemoController {

    @Autowired
    Student s;
    @Autowired
    Employee e;
   

    @RequestMapping("/")
    public String home() {
        System.out.println("Home method");
        s.studing();
        e.working();
        
        return "home.html";
    }
    @RequestMapping("/about")
    public String xyz() {
        System.out.println("XYZ method called");
        return "aboutus.html";
    }
    
  
}

Now next is constructor based dependency injection.
where 1 class is dependent for the object of the another class to be completely created.
For eg car contains engine, tyres, etc.
now,
class engine{ type , speed }
class car{engine}

that means, my car class object is dependent on the obj of class engine.
so my car class cannot be completed till it gets the obj of class engine.
so my car class in dependent on engine class.

so 1st create engine class,

engine.java--

package com.itvedant.springmvcapp;

public class Engine {
    private String type;
    private Double speed;

    public Engine(){
        this.type="Combustible";
        this.speed=120.00;
    }
}

car.java--

package com.itvedant.springmvcapp;

public class Car {
    private String color;
    private Engine engine;

    public Car(){
        this.color="red";
        this.engine=new Engine(); // this object we r creating manually. What if i have performed IOC on this engine and i dont want to create it manually.
        

    }
}

i.e. there is an obj of this class already existing,
so what i want is as the car class obj is getting created,
let it be automatically wired, to that particular object.
So that is what we do with constructor based injection.

So declare engine class as component.


package com.itvedant.springmvcapp;

import org.springframework.stereotype.Component;

@Component
public class Engine {
    private String type;
    private Double speed;

    public Engine(){
        this.type="Combustible";
        this.speed=120.00;
        System.out.println("Engine object created");
    }
}


in Engine e-- e will get the ref of the bean

package com.itvedant.springmvcapp;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Car {
    private String color;
    private Engine engine;

    @Autowired
    public Car(Engine e){
        this.color="red";
        //this.engine=new Engine(); // this object we r creating manually. 
        //AFter @Component, we will not do this.
        this.engine=e;
        System.out.println("Car object created");
    }
}

This is what we call constructor based dependency injection. This takes place during runtime.

Now if we will not create engine as component then we will get error bcoz obj didnt got created.

so, 2nd way, if u r not creating @bean function,
then u can also create, a public func inside beanAnnotationDemo.java--
like--

  @Bean(name="emp") // to call this method automatically and create object automatically.
    public Employee createEmployee(){
        return new Employee();
    }
    @Bean
    public Engine createEngine(){
        return new Engine();
    }
So, it doesnt matter , the obj that u have created is with bean() or @component().
Object should be created.

Now delete the above code and run again.

Now split screen and see car.java and engine.java

We use dependency injection so that we donot have to create objects manually.
Its very time consuming.
Also,As a programmer when i create any obj , I am constrained in its scope.
So here not only obj reation is imp, but also, putting obj into container,
so that it is available in my entire application.
Now the Dependency Injection -- we were doing it earlier also,like-- for eg--


class Laptop{
	IntelRam Ram,
	IntelProcessor pro;
};
class LenovoLaptop extends Laptop(){  #---- now here extends is doing Dependency injection
	LenovoLaptop(){
		this.ram=new IntelRam();
		this.pro=new IntelProcessor();
	}
};
class AsusLaptop extends Laptop(){  #---- now here extends is doing Dependency injection
	AsusLaptop(){
		this.ram=new IntelRam();
		this.pro=new IntelProcessor();
	}
};
class Factory{

};

Now inboth Lenoveo and asus , I am creating objects ,manually, which i dont want.
So rather I will use a Factory class, and I will ask this Factory class to create object of this.
So in factory class, the manual dependecy inj will be like-- SO now--

class Laptop{
	IntelRam ram,
	IntelProcessor pro;
};
class LenovoLaptop extends Laptop(){  #---- now here extends is doing Dependency injection
	LenovoLaptop(){
		Factory f= new Factory(); #--- we will only put ref here, 
		this.ram=f.getRam();
		this.pro=f.getPro();
	}
};
class AsusLaptop extends Laptop(){  #---- now here extends is doing Dependency injection
	AsusLaptop(){
		this.ram=f.getRam();
		this.pro=f.getPro();
	}
};
class Factory{
	IntelRam Ram,
	IntelProcessor pro;
	Factory(){
		this.createObjects();
	}
	public void cretaeObjects(){
		this.ram=new IntelRam();
		this.pro=new IntelProcessor();
	}
	public IntelRam getRam(){
		return this.ram;
	}
	public IntelProcessor getPro(){
		return this.pro;
	}

};

So this we call as design pattern, where my class is creating an obj,
rather than me creating object everytime,let the obj be created by any other class,
and let it provide me with the obj of that class.

Now the problem here is I am fixed with Intel ram and pro. What if I want to have AMD pro.
So now we will not use the ref of type, Intel. We will only use Ram and Processor. i.e.--
class Ram{}
class IntelRam extends Ram{}
class AmdRam extends Ram{}

class Processor{}
class IntelProcessor extends Processor{}
class AmdProcessor extends Processor{}

class Laptop{
	Ram ram,
	Processor pro;
};
class LenovoLaptop extends Laptop(){  #---- now here extends is doing Dependency injection
	LenovoLaptop(){
		Factory f= new Factory("Intel"); #--- we will only put ref here, 
		this.ram=f.getRam();
		this.pro=f.getPro();
	}
};
class AsusLaptop extends Laptop(){  #---- now here extends is doing Dependency injection
	AsusLaptop(){
		this.ram=f.getRam();
		this.pro=f.getPro();
	}
};

So now we can ask factory which ram and pro we want--

class Factory{
	IntelRam Ram,
	IntelProcessor pro;
	Factory(type){
		this.createObjects();
	}
	public void cretaeObjects(String type){
	     type=="Intel"
		this.ram=new IntelRam();
		this.pro=new IntelProcessor();
	     type=="Amd"
		this.ram=new AmdRam();
		this.pro=new AmdProcessor();
	}
	public IntelRam getRam(){
		return this.ram;
	}
	public IntelProcessor getPro(){
		return this.pro;
	}

};

Now this factory class is somewhat creating an IOC manually.
where AsusLaptop thinks obj is created by factory class
and the ref is getting injected.

Now this above thing we have shorten up by creating @component injection.
and where ever u want to inject htis object,
we can do @autowire.

So by using Annotations, we automated this.

So next is-- Setter based dependency
Either use constructor based or setter based dependency injection.

So in car.java--

     //this.engine=new Engine(); // this object we r creating manually. 
        //AFter @Component, we will not do this.
        this.engine=e;
        System.out.println("Car object created");
    } */
    public Car(){ -------------------------------------------
        System.out.println("car Object Created");
    }
    // Setter dependency injection--
    @Autowired ---------------------------------------------- if we r not doing autowiring then setter method will not work
    public void setEngine(Engine e){
        this.engine=e;
	System.out.println("\n Injecting engine object using setter().");
    }

if we will not do this autowiring, then, setter object will not be called.
i.e. setter dependency is not done by default.

now, run ur proj and see o/p.


https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN-------- day 42, restAPI

Now in Spring MVC-we had API, in which we have controller which has method , this method was mapped with url,
This method at the end returns name of html file, which is a view file that will be displayed on the browser.
Now what we r saying, our API will not return view, our api will return data, so our data becomes
new type of a view, and to get that, few of the annotations needs to be changed.
Same annotations cannot be utilized which we have used earlier.
And that is so becoz in restapi, we r not going to return html page, instead we will return data.
And that too the data will be in json format.

Now steps for creating a project--
goto vs code-
goto view cmd pallete-- spring initializer--create a maven project- springboot ver--3.1.11==java--
--group id--com.itvedant-- name of project or artifact id--petstoreapp--jar file-- 17--
then add dependency-- spring web and spring boot dev tools--generate

now open petstoreappfolder in vs code.
now come to src main -- java--folder---now click on the package petstoreapp.
Now add a new folder in petstoreapp and give a name--controllers-- we will
pack all our controllers in 1 single pkg.

Now inside this package, cretae-- file DemoController.java

package com.itvedant.petstoreapp.controllers;

import org.springframework.stereotype.Controller;

@Controller ------------------------------------------------
public class DemoController {
    
}

now cretae a method and define it--

package com.itvedant.petstoreapp.controllers;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class DemoController {
    @RequestMapping("/message")
    public String getMessage(){
        return "Welcome to RestAPI";
    }
}

so now we r not returning the name of the html or view file.
we r returning a normal string or data.
Now the issue will be there bcoz by default,
if y class is a controller then it expects to return a html file.
So we will have to tell the controller, that we r not returning an html or view file.
So, 1st we will see what error will come and after that we will see annotation.

now from springboot dashboard button start petsroreapp--so now we 
will send req on /message and we will see what msg is coming
and how--

http://localhost:8080/message-- now we r getting error
that it is unable to find a file.

So our data needs to be converted into a json format..
So this will be done by @ResponseBody annotation.
This annotation will specify that the method is returning the data,
which will be converted into json and sent
as the response.

package com.itvedant.petstoreapp.controllers;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class DemoController {
    @RequestMapping("/message")
    @ResponseBody
    public String getMessage(){
        return "Welcome to RestAPI";
    }
}


So now--
http://localhost:8080/message--refresh

Welcome to RestAPI

lly,

@Controller
public class DemoController {
    @RequestMapping("/message")
    @ResponseBody
    public String getMessage(){
        return "Welcome to RestAPI";
    }
    @RequestMapping("/marks")
    @ResponseBody
    public double getMarks(){
        return 99.35;
    }
}

http://localhost:8080/marks-- o/p 99.35

So ResponseBody is converting data into json data.

What if we have list of data--

    @RequestMapping("/marks")
    @ResponseBody
    public double getMarks(){
        return 99.35;
    }
    @RequestMapping("/colors")
    @ResponseBody
    public List<String> getColors(){
        List<String> colors=Arrays.asList("red","blue","green","yellow");
        return colors;
    }
}


http://localhost:8080/colors

Now creating a class--

class Student{
    private int id;
    private String name;
    private double marks;
}
then right click inside class-- source action--
generate getters and setters.

 Now because it is a class, we will initialize an object
and will return the obj of the class which will be serialized into
json format and  then send as the response.

http://localhost:8080/stud--- o/p will be in json format.

package com.itvedant.petstoreapp.controllers;

import java.util.Arrays;
import java.util.List;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

class Student{
    private int id;
    private String name;
    private double marks;
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setMarks(double marks) {
        this.marks = marks;
    }
    public String getName() {
        return name;
    }
    public double getMarks() {
        return marks;
    }
    
}

@Controller
public class DemoController {
    @RequestMapping("/message")
    @ResponseBody
    public String getMessage(){
        return "Welcome to RestAPI";
    }
    @RequestMapping("/marks")
    @ResponseBody
    public double getMarks(){
        return 99.35;
    }
    @RequestMapping("/colors")
    @ResponseBody
    public List<String> getColors(){
        List<String> colors=Arrays.asList("red","blue","green","yellow");
        return colors;
    }
    @RequestMapping("/stud")
    @ResponseBody
    public Student getStudent(){
        Student s = new Student();
        s.setId(1);
        s.setName("Harry");
        s.setMarks(78.35);
        return s;
    }

    
}


if u want to return list of students, then,

@RequestMapping("/stud")
    @ResponseBody
    public Student getStudent(){
        Student s = new Student();
        s.setId(1);
        s.setName("Harry");
        s.setMarks(78.35);
        return s;
    }
    @RequestMapping("/studs")
    @ResponseBody
    public List<Student> gStudents(){
        List<Student> students= new ArrayList<>();
        Student s1 = new Student();
        s1.setId(10);
        s1.setName("Rahul");
        s1.setMarks(88.35);
        students.add(s1);

        Student s2 = new Student();
        s1.setId(20);
        s1.setName("Rahul");
        s1.setMarks(88.35);
        students.add(s1);

        return students;

    }
}


http://localhost:8080/studs--
o/p--

[{"id":20,"name":"Rahul","marks":88.35},{"id":20,"name":"Rahul","marks":88.35}]

Now this is the technique which we will use for restapi.

Now everytime i am writing a method
and i am wirting responsebody.
So to get rid of that, rather than making a normal controller,
we will make it a RestController-- and comment responsebody everywhere.

So @RestController is combining 2 annotations.
@Controller and  @ResponseBody.

@RestController
public class DemoController {
    @RequestMapping("/message")
    //@ResponseBody
    public String getMessage(){

Now filhaal, the methods that we have, getMarks,getColors, etc
are webapis and not restapis.

for converting them to restapi, we will follw some guideline
to do the url mapping.

Now based on what we need to perform,
i.e. which crud operation we r performing,
we first have to select our resource.
This is very imp in restapi.

For eg in our case, we created a student class,
and the student obj can be said as a resource.
i.e. Student s=new Student(); is our resource.

So in rest api, we first select our resource,
and the restapi is created around this resource only.

In this resource, we wil perform diff crud operations,
either we wil create new instance of the resource,
Now, depending on the crud op, u r supposed to 
select ur http request method.

Now earlier when we did url mapping, by default http()
used get().
But now If in a crud op,
 Iam creating any resource, then that will be http req post method,
reading - get http req post ().
Updation-- put/patch
delete-- we have http method delete only.

Now url has no info which crud op we r going to perform.

So in restapi, the most imp thing is resource,
i.e. with whose obj we r going to work.

So 1st we will create a class  whose obj
will be our resource, on which we will
perform crud op.

This class is mapped to a db table.
And internally this class will be known as entity class,
and on this class (pojo class) objects u will perform restapi.

So now, come outside controllers pkg--
click on petstorapp--create new folder--
give the name entities.
And inside entities folder- create a new file-- Product.java

The object of the product class, we r going to put inside collection
or on which we will built our entire restapi.
 in product.java we will use wrapper classes bcoz
that works well with the entire concept that we will see,
so instead of int, we will use Integer.

package com.itvedant.petstoreapp.entities;

public class Product {
    private Integer id;
    private String name;
    private Double price;
    private String description;
    
}

now inorder to convert our data into json
format, we need getter setter method,
so right click-- source action-- getter setter
-- select all --ok.
now we r going to design a controller.

So inside controllers creating a new file--
ProductController.java

For every entity class we will have Controller class.
Annotate it to @RestController--

package com.itvedant.petstoreapp.controllers;

import org.springframework.web.bind.annotation.RestController;

@RestController
public class ProductController {
    
}


This class will perform 2 crud ops-- create and read all.

package com.itvedant.petstoreapp.controllers;

import java.util.List;

import org.springframework.web.bind.annotation.RestController;

@RestController
public class ProductController {

    //cretae
    public String addProduct(){
        return "Product Added";
    }

    //Read all
    public List<Product> getProducts(){
        return null;
    }
    
}

next we will create a map collection.
In the map, the key part, will be of type integer,
i.e. id of product will be key
and complete product info will be our value part.

private Map<Integer,Product> productMap=new HashMap<>();

now for id values-- we will use,
private AtomicInteger atomic = new AtomicInteger();


    //cretae
    @RequestMapping("/products")
    public String addProduct(){
        return "Product Added";
    }

    //Read all
    @RequestMapping("/products")
    public List<Product> getProducts(){
        return null;
    }
}

Now we have mentioned /products only in both the
methods, and not mentionaed anything about which crud op is taking place.

Now on running, it is giving error ambiguous mapping.

Now this is happening becoz with both the methods,
it is expecting a get().
Now even if the url is same,
but http req for addProduct is Post and for getProduct is get.

package com.itvedant.petstoreapp.controllers;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import com.itvedant.petstoreapp.entities.Product;

@RestController
public class ProductController {

    private Map<Integer,Product> productMap=new HashMap<>();
    private AtomicInteger atomic = new AtomicInteger();

    //cretae
    @RequestMapping(path="/products", method=RequestMethod.POST)
    public String addProduct(){
        return "Product Added";
    }

    //Read all
    @RequestMapping(path="/products", method=RequestMethod.GET)
    public String getProducts(){
        return "Product Read";
    }
    
}


http://localhost:8080/products-- o/p-- Product Read

Now to test restapi's we can use some api clients,
like postman application, hopscotch application, 
so we will install postman app, 
so go to browser, search postman app,
download postman, install-- continue with lightweight api client

now in postman u can choose--
get-- http://localhost:8080/products -- send-- Product Read
do post-- send-- product added.

Now next we will create RestAPI--

So now we will create restapi for all the crud op which we can perform on 
our resource. i.e. the object of Product class is our resource.
over whih we will create our rest api.
So, table, rows of our table, everything is resource.

Now the class here is a normal POJO class
i.e. plain old java obj class.
We will not add many functionalities inside this class.
We will define properties inside this class,
and methods to access these properties.
for that we can have constructors.

Now restapi we will create inside controller,
which will contain methods to perform the task.

the url with methods is actually the RestAPI.

Now how to design this url--
If the resource is the object of class Product,
then rest api will contain plural i.e. products.
i.e. with restapi we r referring to entire container-products.
for single product access- we will give product id--
/products/1
now u will not write anything like-- /products/add
or /products/read, etc.

rather u will send a call to /products
using http req method.

Now, the req method selection i.e. get/post/
put/patch/delete we cant do from url.
instead from an application called as postman.
The postman acts as a client to test the restapi
to check if the o/p is correct on.

So now we will test our project not on browser, but 
on postman app.
Project start and stop is done with the button only.


Now we will adding 2 dummy product objects in which we r not taking input from user.
now in our map object, key is id part and value is product object.
now, if we will write productMap.values--
we will get values but it will not be of type list 
instead value of type collection.
So,we will convert collection into list
values() methods return Collection<Product>
we can convert this into a list by creating.
an ArrayList and using it.

package com.itvedant.petstoreapp.controllers;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import com.itvedant.petstoreapp.entities.Product;

@RestController
public class ProductController {

    private Map<Integer,Product> productMap=new HashMap<>();
    private AtomicInteger atomic = new AtomicInteger();

    //cretae
    @RequestMapping(path="/products", method=RequestMethod.POST)
    public String addProduct(){
        Product p1= new Product();
        p1.setId(atomic.incrementAndGet());
        p1.setName("Dog Show Blue");
        p1.setPrice(640.00);
        p1.setDescription("Blue shoes for Pet Dogs");
        productMap.put(p1.getId(), p1);

        Product p2= new Product();
        p2.setId(atomic.incrementAndGet());
        p2.setName("Dog Show Blue");
        p2.setPrice(640.00);
        p2.setDescription("Blue shoes for Pet Dogs");
        productMap.put(p2.getId(), p2);
        return "Product Added";
    }

    //Read all
    @RequestMapping(path="/products", method=RequestMethod.GET)
    public List<Product> getProducts(){
        return new ArrayList<Product>(productMap.values());
    }
    
}


So now when we will run our projects--
We will 1st run post methods, then get method.

post-- http://localhost:8080/products --send
get-- http://localhost:8080/products --send

we got o/p in json format.

NOw if u want to take input from user,
SO the input which we will get in json format,
will be deserialized into the product object,
and that product obj we will add in map.

So in the postman-- click on body tab-- 
see radio button called as raw--
as soon as u click on it, u get dropdown Text--
by default it is text, change it to json.

now every object will be enclosed in {}.
Dont give id.

post-- http://localhost:8080/products

{
    "name":"Blue neck band",
    "price":299.00,
    "description":"Blue neck band for pet dogs"
}

Now in postman app--
header part contains url,
req body part contains data,
what we want is , this data gets converts  
into products class object.

So, goto vs code--ProductController.java--addProduct()--

   @RequestMapping(path="/products", method=RequestMethod.POST)
    public String addProduct(@RequestBody Product newProduct){
        
        return "Product Added";
    }

the annotation @RequestBody will convert json data,
into the obj of class Product , which will be refrred by newProduct.

So,

  //cretae
    @RequestMapping(path="/products", method=RequestMethod.POST)
    public String addProduct(@RequestBody Product newProduct){
        newProduct.setId(atomic.incrementAndGet());
        productMap.put(newProduct.getId(),newProduct);
        return "Product Added";
    }

    //Read all

So now from Postman, with json data written --
post --http://localhost:8080/products--send

product added

then do get -- http://localhost:8080/products--send
we can see the added product.

Adding another data through postman--
post--http://localhost:8080/products--

{
    "name":"Green neck band",
    "price":299.00,
    "description":"Green neck band for pet dogs"
}

--send

now do get and see-- 

day-43-- 47:00

Now currently controller is taking care of 2 things--
1. Handling req and giving resp back.
2. It is also implementing business logic on the map.
i.e.. after reading data, setting its id and after that putting into Product,
is business logic.

Now controller is supposd to do only 1st part.
i.e. read and give response.

this business logic codes we will move into another class,
i.e. service class--which is a helper class for
controller which will contain main business logic.

So in vs code-- folder petstoreapp-- 
add new folder--services--

43--53:21

https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN


So now inside services folder-- create a java class-
ProductService.java class.
The object of this class i want it to be automatically created,
so we will declare it @services.

Move these 2 stmts from ProductController.java to ProductService.java

    private Map<Integer,Product> productMap=new HashMap<>();
    private AtomicInteger atomic = new AtomicInteger();

also create a new method - addProduct, 
cut the business logic from ProductController.java
and put in ProductService.java

Now bcoz of @service annotation the object of ProductController is
going to be created which is going to be placed on ProductController.java
by autowiring. So--


So, ProductService.java--

package com.itvedant.petstoreapp.services;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import org.springframework.stereotype.Service;

import com.itvedant.petstoreapp.entities.Product;

@Service
public class ProductService {

    private Map<Integer,Product> productMap=new HashMap<>();
    private AtomicInteger atomic = new AtomicInteger();

    public String addProduct(Product newProduct){
        newProduct.setId(atomic.incrementAndGet());
        productMap.put(newProduct.getId(),newProduct);
        return "Product Added";
    }

    public List<Product> getAll(){
        return new ArrayList<Product>(productMap.values());
    }
    
}


ProductController.java--

package com.itvedant.petstoreapp.controllers;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import com.itvedant.petstoreapp.entities.Product;
import com.itvedant.petstoreapp.services.ProductService;

@RestController
public class ProductController {
    @Autowired
    private ProductService service;

    //cretae
    @RequestMapping(path="/products", method=RequestMethod.POST)
    public String addProduct(@RequestBody Product newProduct){
        
        return this.service.addProduct(newProduct);
    }

    //Read all
    @RequestMapping(path="/products", method=RequestMethod.GET)
    public List<Product> getProducts(){
        return this.service.getAll();
    }
    
}

Now inside ProductService create a method--


    public List<Product> getAll(){
        return new ArrayList<Product>(productMap.values());
    }

    public Product getById(Integer id){ ----------
        return productMap.get(id);
    }
    
}

Now creating a read single method in ProductController.java--

 //read single
    @RequestMapping(path="/products/{id}")
    public Product geProductByID(){
        return this.service.getById();
    }
    
where /products/{id} --id is called path variable.
This helps in dynamic value passing.
Now this id is in my url path,
@PathVariable will help in fetching id from url,

   //read single
    @RequestMapping(path="/products/{id}",method = RequestMethod.GET)
    public Product geProductByID(@PathVariable Integer id){
        //return this.service.getById();
        System.out.println(id);
        return null;
    }

now goto postman-- get-- http://localhost:8080/products/100 send
u will see 100 getting printed in terminal.

i.e. whichever id value we will send in url, that will get printed.
So,

 //read single
    @RequestMapping(path="/products/{id}",method = RequestMethod.GET)
    public Product geProductByID(@PathVariable Integer id){
        return this.service.getById(id);
        //System.out.println(id);
        //return null;
    }

And now in service class-

So now using Post just adding some values via postman.
then via Get, get the values.

Now what i want is- if the product exists, then
return me that product, otherwise, return me a message
that product doesn't exist.
But at 1 time, 1 kind of value can be returnde 
from method. 
The restapis can also be configured to give some response code.

The status code is 200ok if ebverythings ok.

https://restfulapi.net/http-status-codes/------- study about restapis.

The status codes can be divided into 5 generally--
informational,success,redirection,client error,server error.

Mostly we go for success ones, client error and server error.

Now if u want ,when u r creating some resource then 
u get response msg--201 created,
and when u r deleting then 204 no content.

For error u can send,400 bad req that the req send by
user is bad.
401 unauthorized and 403 forbidden we will see in security 
chapter.
Most common ones are 404 not found 
and 405 method not allowed.

500 internal server error

So based on what error we r getting,
we can pass this as a response.

We can also do something like, in 1 situation ,
if u want to pass string as reponse and in other
u want product as response, then u can do that also.
So now we will not send response as String
or List<Product> instead, we will send response
of another class called as ResponseEntity and
we will specify which type of data we want as response.

ResponseEntity will help to send status code,

    //cre
    @RequestMapping(path="/products", method=RequestMethod.POST)
    public ResponseEntity<String> addProduct(@RequestBody Product newProduct){
        
        return ResponseEntity.status(HttpStatus.CREATED).body(this.service.addProduct(newProduct));
        //
    }


Now http://localhost:8080/products post-- send
see status code-- 201 created

So now we will change it for every method. So--

  //Read all
    @RequestMapping(path="/products", method=RequestMethod.GET)
    //? indicates the value of any type
    public ResponseEntity<?> getProducts(){
        return ResponseEntity.ok(this.service.getAll());
    }

Check from postman.

So because of ? , my response can be of any type.

now read single--
if the requested id record is there, the record will be given as o/p.
If requested record is not there, then 



    //read single
    @RequestMapping(path="/products/{id}",method = RequestMethod.GET)
    public ResponseEntity<?> getProductByID (@PathVariable Integer id){
        Product foundProduct= this.service.getById(id); 
        // null is returned if getbyID() doesnt get requested id 
        if(foundProduct==null)
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body("Requested id product doesn't exist");
        else
                return ResponseEntity.ok("Found Product");

        
    }
    
}

Now becoz this is not our permanaent 
storage, everytime we will use postman, we will
insert some values.

Do post and get and get individually.

Now we will delete and update.

Now for deleting an obj in restapi,
the httpreq is delete.

 //Delete
    @RequestMapping(path="/products/{id}",method = RequestMethod.DELETE)
    public ResponseEntity<?> deleteProductByID (@PathVariable Integer id){
        Product foundProduct= this.service.getById(id); 
        // null is returned if getbyID() doesnt get requested id 
        if(foundProduct==null)
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body("Requested id product doesn't exist");
        else
             {  

                return null;

             }
        
    }
    
}

Now go to service calss-

    //delete 
    public void deleteProduct(Integer id){
        productMap.remove(id);
    }

Now goto controller--

//Delete
    @RequestMapping(path="/products/{id}",method = RequestMethod.DELETE)
    public ResponseEntity<?> deleteProductByID (@PathVariable Integer id){
        Product foundProduct= this.service.getById(id); 
        // null is returned if getbyID() doesnt get requested id 
        if(foundProduct==null)
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body("Requested id product doesn't exist");
        else
             {  
                this.service.deleteProduct(id);
                return ResponseEntity.noContent().build();

             }
        
    }
    
}

Now from postman do add delte.

for update we will copy getProductById().

controller--

here via postman we will give id of data to update
and also updated data . SO 2 info we r passing.
//update
    @RequestMapping(path="/products/{id}",method = RequestMethod.PUT)
    public ResponseEntity<?> updateProduct(@PathVariable Integer id,
                                            @RequestBody Product updatedProduct){
        Product foundProduct= this.service.getById(id); 
        // null is returned if getbyID() doesnt get requested id 
        if(foundProduct==null)
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body("Requested id product doesn't exist");
        else
                return ResponseEntity.ok("Found Product");

        
    }


}


service--

 //update 
    public Product updateProduct(Integer id,Product updatedProduct){
        updatedProduct.setId(id);
        productMap.put(id,updatedProduct);
        return productMap.get(id);
    }
    
}

now in controller class--

   //update
    @RequestMapping(path="/products/{id}",method = RequestMethod.PUT)
    public ResponseEntity<?> updateProduct(@PathVariable Integer id,
                                            @RequestBody Product updatedProduct){
        Product foundProduct= this.service.getById(id); 
        // null is returned if getbyID() doesnt get requested id 
        if(foundProduct==null)
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body("Requested id product doesn't exist");
        else
                return ResponseEntity.ok(this.service.updateProduct(id,updatedProduct));

        
    }

So now in postman--
add few products.

for put--http://localhost:8080/products/2
then in the json data lets suppose i want to 
update price--199.00 -- give that--
send

now do get-- u will see updated value.

day 44-- 40.59-- https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

Now come to entities package--
new file-- User.java

package com.itvedant.petstoreapp.entities;

public class User {
    private Integer id;
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
}


now instead of creating getter setter,
 we will use lambork library to generate getter setter methods.

So come to pom.xml.
we will add another library.
right click pom.xml-- add starter-- search lombok--select 3 dependencies -- enter  -yes--
--yes
it is a library to reduce boilerplate code.

then check-- u will get something like--

		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<scope>annotationProcessor</scope>
		</dependency>

in pom.xml

Now goto user.java--


@Data ----------------- put annotation
public class User {
    private Integer id;
    private String firstNmae;
    private String lastName;
    private String email;
    private String phone;
}

Next in the service pkg, add UserService.java file--

package com.itvedant.petstoreapp.services;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import org.springframework.stereotype.Service;

import com.itvedant.petstoreapp.entities.User;

@Service
public class UserService {
    private Map<Integer, User> userMap= new HashMap<>();
    private AtomicInteger atomic = new AtomicInteger();

    //create
    public User addUser(User newUser){
        newUser.setId(atomic.incrementAndGet());
        userMap.put(newUser.getId(),newUser);
        return newUser;
    }

    //ReadAll
    public List<User> getAll(){
        return new ArrayList<User>(userMap.values());
    }

    //ReadOne
    public User getByID(Integer id){
        return userMap.get(id);
    }

    //Delete
    public void deleteUser(Integer id){
        userMap.remove(id);
    }

    //Update
    public User updateUser(Integer id, User updatedUser){
        updatedUser.setId(id);
        userMap.put(id, updatedUser);
        return updatedUser;
    }
}


Now this is our backend part.
We will call these methods from our controller.

Next we r going to create UserController--

Now here we will see PostMapping.
This is similar to, 

package com.itvedant.petstoreapp.controllers;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;

import com.itvedant.petstoreapp.entities.User;
import com.itvedant.petstoreapp.services.UserService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;



@RestController
public class UserController {
    @Autowired
    private UserService service;

    //create
    @PostMapping("/users")
    public ResponseEntity<?> addProduct(@RequestBody User newUser){
        return ResponseEntity.status(HttpStatus.CREATED)
               .body(this.service.addUser(extracted(newUser)));
    }

    private User extracted(User newUser) {
        return newUser;
    }
    

    //read all
    @GetMapping("/users")
    public ResponseEntity<?> getAllUsers(){
        return ResponseEntity.ok(this.service.getAll());
    }
    

    //read one
    @GetMapping("/users/{id}")
    public ResponseEntity<?> getUserById(@PathVariable Integer id){
        User foundUser= this.service.getByID(id);
        if(foundUser == null)
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body("User with this ID doesnot exist");
        else
            return ResponseEntity.ok(foundUser);
    }
    

    //delete

    //update
}


1hr 31--https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN
day 44.

package com.itvedant.petstoreapp.controllers;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RestController;

import com.itvedant.petstoreapp.entities.User;
import com.itvedant.petstoreapp.services.UserService;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;



@RestController
public class UserController {
    @Autowired
    private UserService service;

    //create
    @PostMapping("/users")
    public ResponseEntity<?> addProduct(@RequestBody User newUser){
        return ResponseEntity.status(HttpStatus.CREATED)
               .body(this.service.addUser(extracted(newUser)));
    }

    private User extracted(User newUser) {
        return newUser;
    }
    

    //read all
    @GetMapping("/users")
    public ResponseEntity<?> getAllUsers(){
        return ResponseEntity.ok(this.service.getAll());
    }
    

    //read one
    @GetMapping("/users/{id}")
    public ResponseEntity<?> getUserById(@PathVariable Integer id){
        User foundUser= this.service.getByID(id);
        if(foundUser == null)
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body("User with this ID doesnot exist");
        else
            return ResponseEntity.ok(foundUser);
    }
    
    //update
    @PutMapping("/users/{id}")
    public ResponseEntity<?> updateUser(@PathVariable Integer id,
                                        @RequestBody User updatedUser){
        User foundUser= this.service.getByID(id);
        if(foundUser == null)
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body("User with this ID doesnot exist");
        else
            return ResponseEntity.ok(this.service.updateUser(id, updatedUser));
    }

    //delete
    @DeleteMapping("/users/{id}")
    public ResponseEntity<?> deleteUser(@PathVariable Integer id){
        User foundUser= this.service.getByID(id);
        if(foundUser == null)
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body("User with this ID doesnot exist");
        else
            this.service.deleteUser(id);
            return ResponseEntity.noContent().build();
    }
}


postman--8080/users

{
    "firstName":"Harry",
    "lastName":"potter",
    "email":"harry.potter@gmail.com",
    "phone":"5388492892"
}

then day 45-- validations will come--
https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN


Now come to product.java class--
here we have created manual getter setter methods.
just delete all the getter setter methods.

package com.itvedant.petstoreapp.entities;

import lombok.Data;

@Data
public class Product {
    private Integer id;
    private String name;
    private Double price;
    private String description;
    
}


now via postman whatever values i am inputting , all the values gets inserted.
Nulls, etc, There are no restrictions.
So,
Now as from service , data is coming to controller, there only we need to check
if data is correct or not.
So this is what we do in validation part.
We validate the input, so that wrong data doesnt get stored.

So validation in springboot is applied through annotations.
2 types of annotations are-- built-in and custome types.

come to pom.xml file-- we will add a starter file.
add starters--validation I/O-- proceed-- yes

now see, validation dependency got ---
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
	</dependencies>



Now goto user.java

package com.itvedant.petstoreapp.entities;

import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class User {
    private Integer id;

    @NotNull
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
}


now goto postman-- donot provide value for firstName.
The value is getting added as Null.
So we have provideed the validation, but still it is not applied, bcoz,
input is coming from UserController.java .
So we will put validation there also.

So now goto UserController.java--

 //create
    @PostMapping("/users")
    public ResponseEntity<?> addUser(@RequestBody @Valid User newUser){ ---------@Valid
        return ResponseEntity.status(HttpStatus.CREATED)
               .body(this.service.addUser(extracted(newUser)));
    }

now make changes -- User.java

@Data
public class User {
    private Integer id;

    @NotNull
    private String firstName;
    @NotNull
    private String lastName;
    @NotNull
    private String email;
    @NotNull
    private String phone;
}

Now restart-- 
day 45
42:43-------------------https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN


postman--
{
    
    "lastName":"",
    "email":"",
    "phone":"5388473578"
}
error -- bad req

package com.itvedant.petstoreapp.entities;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class User {
    private Integer id;

    @NotNull(message = "First Name cannot be null")
    @NotBlank(message = "First Name cannot be blank")
    private String firstName;
    @NotNull(message = "Last Name cannot be null")
    @NotBlank(message = "Last Name cannot be null")
    private String lastName;
    @NotNull(message = "Email Name cannot be null")
    @NotBlank(message = "Email cannot be null")
    private String email;
    @NotNull(message = "Phone Name cannot be null")
    @NotBlank(message = "Phone Name cannot be null")
    private String phone;
}


postman--

{
    "firstName":"Harry",
    "lastName":"Potter",
    "email":"",
    "phone":"5388473578"
}

error.

package com.itvedant.petstoreapp.entities;

import org.hibernate.validator.constraints.Length;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class User {
    private Integer id;

    @NotNull(message = "First Name cannot be null")
    @NotBlank(message = "First Name cannot be blank")
    private String firstName;
    @NotNull(message = "Last Name cannot be null")
    @NotBlank(message = "Last Name cannot be null")
    @Length(min=2,max=10,message="Lastname should have 2-5 characters.")
    private String lastName;
    @NotNull(message = "Email Name cannot be null")
    @NotBlank(message = "Email cannot be null")
    @Email
    private String email;
    @NotNull(message = "Phone Name cannot be null")
    @NotBlank(message = "Phone Name cannot be null")
    private String phone;
}


Now going to Product.java-------

package com.itvedant.petstoreapp.entities;

import org.hibernate.validator.constraints.Length;

import io.micrometer.common.lang.NonNull;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class Product {
    private Integer id;
    @NotNull(message = "Last Name cannot be null")
    @NotBlank(message = "Last Name cannot be null")
    @Length(min=2,max=20,message="Lastname should have 2-20 characters.")
    private String name;
    @NonNull
    @Min(value = 0)
    @Max(value = 4000)
    private Double price;
    private String description;
    
}

ProductController.java----


    //create
    @RequestMapping(path="/products", method=RequestMethod.POST)
    public ResponseEntity<String> addProduct(@RequestBody @Valid Product newProduct){
        
        return ResponseEntity.status(HttpStatus.CREATED).body(this.service.addProduct(newProduct));
        //
    }


post--http://localhost:8080/products--

58----https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN--- day45

Custom validation--

we require 2 things in custom validaton-- for applying validator rules we apply annotations.
which we can apply on our fields and these annotations are not pre defined on my validation starter file.

next we need to define isvalid().

So goto project explorer, we will create seperate package for custom validators.

So,click on petstoreapp-->click new folder-->name it validators-- create new file--Phone.java
our annotation name is Phone.

in browser search-- annotations in java---- see the one by oracle-- https://docs.oracle.com/javase/tutorial/java/annotations/basics.html
--- declaring an annotation type---

So in phone.java--- 

package com.itvedant.petstoreapp.validators;

public class Phone {
    
}

so now instaed of class put @interface.

now goto User.java to see if its getting applied or not,
put @Phone on PhoneNumber

import com.itvedant.petstoreapp.validators.Phone;---- import it from validators pkg.


    @NotNull(message = "Phone Name cannot be null")
    @NotBlank(message = "Phone Name cannot be null")
    @Phone
    private String phone;
}

Now i can apply this annotation anywhere.
Even on class eg-- write below @Data, @Phone.
But I dont want that. It should be applied only on field.

So, in Phone.java we can give target like--

package com.itvedant.petstoreapp.validators;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
public @interface Phone {
    
}


So now if we will apply annotation over the class, then it will start giving error.

Now when should this validator come into use?-- when code is compiled or at runtime?

Now the annotations that we have seen earlier are compile time annotations.
like functional annotations;

but the annotation which we will use now is for runtime.
So we will use @Retention

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Phone {
    
}

by this we will say Phone will be applied at runtime.

Next we r going to add inside a validator pkg, a class -- PhoneValidator.java which will contain
our isvalid().
So for that this class will implement an interface ConstraintValidator.
It takes as input annotation name, also the field on which i am going to apply this annoatation,
what is its datatype.

so, from User.java-- it gets-- String type datatype.

 @Phone
    private String phone;

We r getting error, bcoz its an interface. So, Do quick fix on PhoneValidator,
Also this class will contain invalid() which is called when we apply,
@Phone annotation on a field.

So, PhoneValidator.java--

package com.itvedant.petstoreapp.validators;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

public class PhoneValidator implements ConstraintValidator<Phone,String> {

    @Override
    public boolean isValid(String arg0, ConstraintValidatorContext arg1) {
        // TODO Auto-generated method stub
        return false;
    }
    
}

Now split PhoneValidator.java and Phone.java up and down.

package com.itvedant.petstoreapp.validators;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

public class PhoneValidator implements ConstraintValidator<Phone,String> {

    @Override
    public boolean isValid(String arg0, ConstraintValidatorContext arg1) {
        
        //the total number of chars has to be 10.
        //[0-9] indicates any digit from 0 to 9. 
        boolean condition = arg0.length() == 10 && arg0.matches("[0-9]+");
        return condition;
    }
    
}


https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN-- 22:00-- day 46.

till now we have associated annotation with a validator.
Now we will tell annotator also who is validator.
So now goto phone.java--

package com.itvedant.petstoreapp.validators;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import jakarta.validation.Constraint;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneValidator.class)
public @interface Phone {
    
}


other than this there are certain default properties,
for the proper escalation of values.

so, there are few common properties which is common for every 
validator.

import jakarta.validation.Constraint;
import jakarta.validation.Payload;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneValidator.class)
public @interface Phone {
    String message() default "Invalid phone number";
}

now, if the user enterd phone number doesnt enter into validation,
then it will give this message.


So now just checking if our validator is working or not.
goto postman--

pos-- http://localhost:8080/users--send
{
    "firstName":"Harry",
    "lastName":"Potter",
    "email":"harry.potter@gmail.com",
    "phone":"1234567890"
} 

Now we will apply cross field validator on these 
properties.

User.java--
we will add 2 fields--
Password and confirmPassword.
Value of Password and ConfirmPassword should be same.

    @Phone
    private String phone;

    private String password;
    private String confirmpassword;
}


Cross field validator is applied to the class,
instead it is not applied to fields.

So we will do annotation on the class and not on the fields.

package com.itvedant.petstoreapp.validators;

import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;


//this annotation will be applied on class.
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface VerifyPassword{
    
}


Now this annotation on user will be applied on class level.
then we will give value of the 2 fields on which we 
will apply this annotaiton.
So, User.java---

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
@VerifyPassword
public class User {
    private Integer id;

So, USer.java--

package com.itvedant.petstoreapp.entities;

import org.hibernate.validator.constraints.Length;

import com.itvedant.petstoreapp.validators.Phone;
import com.itvedant.petstoreapp.validators.VerifyPassword;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
@VerifyPassword(field1="password",field2="confirmpassword")
public class User {
    private Integer id;

    @NotNull(message = "First Name cannot be null")
    @NotBlank(message = "First Name cannot be blank")
    private String firstName;
    @NotNull(message = "Last Name cannot be null")
    @NotBlank(message = "Last Name cannot be null")
    @Length(min=2,max=10,message="Lastname should have 2-5 characters.")
    private String lastName;
    @NotNull(message = "Email Name cannot be null")
    @NotBlank(message = "Email cannot be null")
    @Email
    private String email;
    @NotNull(message = "Phone Name cannot be null")
    @NotBlank(message = "Phone Name cannot be null")
    @Phone
    private String phone;

    private String password;
    private String confirmpassword;
}

now currently it is giving error.
So we will define field1 and field2 in VerifyPassword.java

//this annotation will be applied on class.
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface VerifyPassword{
    String field1();
    String field2();
}


now with message--


//this annotation will be applied on class.
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface VerifyPassword{
    String field1();
    String field2();
    String message() default "Password and Confirm Password mismatched";
}


Now creating isvalid() for the same.
So create new file--
VerifyPasswordValidator.java--

package com.itvedant.petstoreapp.validators;

import org.springframework.beans.BeanWrapperImpl;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

public class VerifyPasswordValidator
implements ConstraintValidator<VerifyPassword, Object> {
    //field will get password and field2 will get confirmpassword
    private String field1;
    private String field2;

    public void initialize(VerifyPassword constraintAnnotation){
        this.field1= constraintAnnotation.field1();
        this.field2= constraintAnnotation.field2();
    }

    @Override
    public boolean isValid(Object arg0, ConstraintValidatorContext arg1) {
        // to get the value from field1 and field2 write this code
        Object field1Value = new BeanWrapperImpl(arg0).getPropertyValue(field1);
        Object field2Value = new BeanWrapperImpl(arg0).getPropertyValue(field2);

        return field1Value.equals(field2Value);
    }
    
}

Now goto VerifyPassword.java----

package com.itvedant.petstoreapp.validators;

import java.lang.annotation.Target;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;


//this annotation will be applied on class.
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Constraint(validatedBy = VerifyPasswordValidator.class)
public @interface VerifyPassword{
    String field1();
    String field2();
    String message() default "Password and Confirm Password mismatched";

    Class <?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};

}


now goto Postman--

post-- http://localhost:8080/users--send

{
    "firstName":"Harry",
    "lastName":"Potter",
    "email":"harry.potter@gmail.com",
    "phone":"1234567890",
    "password":"abc",
    "confirmpassword":"abc"
}

day46-- 1:12--- https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

Now we will add and connect with db.
Start workbench--
connection name- Root
user name- root

create database petstore1012;

now we will use a tool, a starter called as  springjpa framework,
inside which hibernate framework has been added.
Here whatever entities we will create , they will automatically gets
added as table.
The hibernate will automatically generate hibernate create query looking at my entity.
and the table will get automatiaclly added into my db.

Now come to resources folder under main folder.This folder contains
application.properties for changing the port number of server.
Now we will use to configure our db.

clcik application.properties--- write--

spring.application.name=petstoreapp
spring.datasource.url=jdbc:mysql://localhost:3306/petstore1012
spring.datasource.username=root


then we need to add some starter files.
now 2 starters needed here are-- database related driver starter.
this depends on which db u r working.
if mysql then mysql, if postgres, then postgres.

2nd starter is spring data jpa.(java persistence api)
persist here means saving permanently.
This we need because we want 2 diff platforms to communicate.
JPA's main purpose is to use another framework- hibernate.
Now hibernate is ORM framework i.e. Object Relation Mapping.
Here, the tables are nothing but relations.
just like cols are called as attributes.
infact the rows are called as tuples.

So what we want is whenever we insert any obj, it should get inserted 
as rows and when i read any row, it should automatically gets converted 
into object.

Now all these things will be done by hibernate.
So how are we going to create hibernate queries?
Now lets suppose I have sb project , inside which we have entities. and there is a db.
clent req comes to sb project, which will goto a file called
as controller based on some url,
the controller will call a method of service.
Inside service we have map, and data is stored in map.
But now we dont want to use map to store our data,
instead we want to use db .

Now in our project we have 2 entities, User and product.
So in our db also we should have product table, and user table.
Now hibernate will automatically generate queries
So the component acts like a bridge betw springboot proj and db.
This bridge is called as repository And we have as many number of repositories,
as number of entities.
This repository is part of springjpa which allows to communicate with db.

Now reporsitory provides us with some built-in methods, some we can create.
These methods which are part of repository
 are called as query methods.

Some predefined query methods are like for insert
we have save method, for read we have findall(),
findby().
So from our service class, we will call save method on our repository.
i.e. post insert req came from url to controller, 
which got forwarded to service(). And service 
will fwd save() call to repositrory, and this repositroy
will automatically connect hibernate, here , in this part user
plays no role. i.e the repository can only connect with user framework.
Now the hibernate will look into that method call
and corresponding to that method cal, it will generate,
insert query which will be sent to db.

So what we have to do in our project , is to add repositories corresponding
to entities. 
i.e. User and product entities. 
For now we have different controller and services class for each entity.
and this is for understanding. But there is no compusion on controller
and service. U can have them common for diff entities.
But repositories should be diff for each entity.
These repositories contain query methods, which will
be escalated to hibernate. So, now the hibrnate will create
actual queries, which will go into my db.

Now since we will be connecting to mysql db,
so in pom.xml we will be adding mysql starter.

right click pom.xml-->add starter--> search mysql driver-->
so select mysql jdbc driver--> add yes,
also add spring data jpa--> add yes.

this got added in pom.xml file--

<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

now come to application.properties--

add--
spring.jpa.hibernate.ddl-auto=create
this will cretae table corresponding to entity in db.
but this has little problem,
1st time when we will run our project, this will
create tables repective to diff entities in class.
2nd time when will run, it wil run drop query on the 
previously created table. And will create a new value.
So, if u r usin create , keep that in mind.

So, if u dont want to cretae the table everytime, and
want to use old data, then,


spring.jpa.hibernate.ddl-auto=update

so 1st time  when hibernate will see, that there
is no table corresponding to db, then 1st time 
it will generate the create cmd.
but next time it will be update,
in case of any change in table it will alter.

then select all--this is to see how hibernate is generating query,
once, u get thoriugh then it will be alright if u will not set this.

spring.jpa.show-sql=true

now even if we keep this false, then also hibernate
will create query, its just u will not be able to see
how the hibernate query created.
We will show this query in terminal.

now we will do some changes in entities also.
because i want just by looking at the entity 
my hibernate should create a class.
currently my entity classes are normal java class.
I need to convert it into proper hibernate entity class,
so that my hibernae is able to understand this entity class,
is need to be converted into a table. 
Its fields should be cols, some field will be 
primary key, this class objects will be mapped to rows.
So we will make certain changes in our entity classes.

so come to java -> entities-->product.java


@Data
@Entity ------------------------------
public class Product {
    private Integer id;
    @NotNull(message = "Last Name cannot be null")
    @NotBlank(message = "Last Name cannot be null")

Now currently the table name in db will be same as 
entity name.
but lets suppose if u want to keep a diff table name 
in db and entity name in spring boot, then,

@Data
@Entity
//@Table(name="tblProduct") ----------

but currently we r keeping same name.

Now if u will start ur project, 
there is aproblem with import jakarta.persistence.Table;--
because for creating table in a db, it is imp
to create primary key.
So , over your id field, add annotation--

@Data
@Entity
//@Table(name="tblProduct")
public class Product {
    @Id --------------------- to tell that its a pk
    private Integer id;
    @NotNull(message = "Last Name cannot be null") 


Now earlier we putter, atomicgenerator with id.
Now what we want is it should be auto-generated
by autoincrement.
So,

@Data
@Entity
//@Table(name="tblProduct")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;
    @NotNull(message = "Last Name cannot be null")
    @NotBlank(message = "Last Name cannot be null")

Now run your project-- see how query got created.
Now goto mysql workbench, use db petstore1012;
show tables and u will see tables, product and product_seq got created.

in workbench--

create database petstore1012;
use petstore1012;
show tables;
desc product;
select * from product;

Now stop the project currently.
We will do same thing with user entity also.

@Data
@Entity
@VerifyPassword(field1="password",field2="confirmpassword")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;

Now here we donot want ConfirmPassword to be converted 
into column.

 private String password;
    @Transient
    // this will make sure that the col for confirmpwd doesnt get created in table.
    private String confirmpassword;
}

Now run project--

workbench--
show tables;
desc user;

Now after db connectiity, we will create 
their repository. 
so click petstoreapp-->new folder-->repositories.
add new file--ProductRepository.java

Now hibernate is a orm framework.
jpa is a part of my repository.
so repository handover input calls to jpa.
which will be handled by hibernate and generate
queries to interact with db.

So now we will create repositories, which
will contain methods that will be converted to query.
That is why we call these methods
as query methods, bcoz these methods will get converted
into queries ultimately.

Also we will use this repository in service.

No in our repositoy we will do basic crud operations.

ProductRepository.java--

package com.itvedant.petstoreapp.repositories;

import org.springframework.data.repository.CrudRepository;

import com.itvedant.petstoreapp.entities.Product;

public interface ProductRepository extends CrudRepository<Product, Integer>{
    
}

<Product, Integer>--indicates-- this repository is for product entity,
and the datatype of it primary key is integer.

Also, CrudReposiitory is a tool which provides
u with some predefined funtions, which will help us to interact with
the db.

Now create a new file-- UserRepository.java

package com.itvedant.petstoreapp.repositories;

import org.springframework.data.repository.CrudRepository;

import com.itvedant.petstoreapp.entities.User;

public interface UserRepository 
    extends CrudRepository<User, Integer>{
}


Now goto productservice.java--

now whatever repository we have created , it is also a type of
component. For eg, in spring core, component class
is used to implement IOC, i.e. obj of the component class
will be automatically created and placed in a container.
So controller,service, repository are type of component,
So, the object or the ref of these will be placed inside a cionatainer.

We just have to autowire these in our service class.

ProductService.java--


@Service
public class ProductService {

    @Autowired
    private ProductRepository repository;

Now 1st we will make changes in create method i.e. addProduct--
so, change the return type from String to Product.

    //Create
    public Product addProduct(Product newProduct){
        newProduct.setId(atomic.incrementAndGet());
        productMap.put(newProduct.getId(),newProduct);
        return "Product Added";
    }

Now we r getting error in ProductController.java class.
So goto ProductController.java-- and instead of String put ?.

 //create
    @PostMapping("/products")
    public ResponseEntity<?> addProduct(@RequestBody @Valid Product newProduct){

Now come to ProductService--

Now we need to write logic for addProduct.
Now addProduct() is geting called from my ProductController.

i.e in ProductService.java--
  //create
    @PostMapping("/products")
    public ResponseEntity<?> addProduct(@RequestBody @Valid Product newProduct){
        
        return ResponseEntity.status(HttpStatus.CREATED).body(this.service.addProduct(newProduct));
        //
    }
but this entire product value doesnot have any id value.

So in ProductService.java-- addProduct()--

 //Create
    public Product addProduct(Product newProduct){
        return this.repository.save(newProduct);
    }

so now this.repository will call the repository,
which will call hibernate. Now hibernate uses save
for creating insert query and also update query.
but currently my product object doesnot have any id.
Now since id value is missing,
this is an indicatin to my hibernate, that this is
an insert query.
 
Now run ur project--

post-- http://localhost:8080/products--send

{
    "name": "dog shoe red",
    "price": 299,
    "description":"red shoes for the pet dog"
}

See the o/p with id set.

Now from workbench-- select * from product;

{
    "name": "dog shoe green",
    "price": 299,
    "description":"green shoes for the pet dog"
}

select * from product;

{
    "name": "red neck band",
    "price": 299,
    "description":"red neck band for the pet dog"
}

So now our data is also getting addded permanently in our db.

So now our insert operation is done , now doing read all operation--

So, ProductService.java--
So currntly, getall is reading from map.
Which i dont want.

Now findAll() returns values in the form of an iterable.
So change the return type to Iterable.

 //Read all
    public Iterable<Product> getAll(){
        return this.repository.findAll();
    }
    
now as i insert from postman--

{
    "name": "green neck band",
    "price": 299,
    "description":"green neck band for the pet dog"
}

in the terminal u will see query getting generated.
Hibernate: insert into product (description,name,price,id) values (?,?,?,?)

Now if u will look ProductController,
getAll() is getting called when,
on /products, get method is coming.
So,

get--http://localhost:8080/products--send--
see all the db table data o/p.

Also, on terminal following query got generated--
select p1_0.id,p1_0.description,p1_0.name,p1_0.price from product p1_0

Now getByID-- PrSer.java--
findById(id)-- now this returns id of optional product.
so, if the findById finds Id in table, then
return that object or else, return Null,
bcoz by default it doesnot return Null . So--

//Read single
    public Product getById(Integer id){
        return this.repository.findById(id).orElse(null);
    }

http://localhost:8080/products/1-- get-- postman

on terminal--
Hibernate: select p1_0.id,p1_0.description,p1_0.name,p1_0.price from product p1_0 where p1_0.id=?

 //Read single
    public Product getById(Integer id){
        return this.repository.findById(id).orElse(null);
    }

And in ProductController.java--

 //read single
    @GetMapping("/products/{id}")
    public ResponseEntity<?> getProductByID (@PathVariable Integer id){
        Product foundProduct= this.service.getById(id); 
        // null is returned if getbyID() doesnt get requested id 
        if(foundProduct==null)
                return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body("Requested id product doesn't exist");
        else
                return ResponseEntity.ok(this.service.getById(id)); -----------------

        
    }

now doing with delete-- PS.java

//delete 
    public void deleteProduct(Integer id){
        this.repository.deleteById(id);
    }

    
http://localhost:8080/products/2--delete--send
204 No Content-- nothing got returned here.

terminal-- Hibernate: delete from product where id=?

goto db and check-- id 2 got deleted.

Now updating our last method--
for update also we will use save().
but with a difference.
In update 1st we will set the id.
becuse if set_id is there then ibernate generate update query,
or else hibernate generate insert query.

    //update 
    public Product updateProduct(Integer id,Product updatedProduct){
        updatedProduct.setId(id); --------- so we will not change this stmt.
	return this.repository.save(updatedProduct); --------
}

put-- http://localhost:8080/products/1-- send
change price to 499

db-- select * from product-- price updated

Hibernate: update product set description=?,name=?,price=? where id=?

And then we will apply same changes on our user.

And now since we r not using map stmt--
we can remove or comment them.

    //private Map<Integer,Product> productMap=new HashMap<>();
    //private AtomicInteger atomic = new AtomicInteger();

better delete them.

and said imports.

Now coming to UserService.java--

@Service
public class UserService {
    @Autowired
    private UserRepository repository;


addUser---

package com.itvedant.petstoreapp.services;



import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.itvedant.petstoreapp.entities.User;
import com.itvedant.petstoreapp.repositories.UserRepository;

@Service
public class UserService {
    @Autowired
    private UserRepository repository;

    //create
    public User addUser(User newUser){
        return this.repository.save(newUser);
    }

    //ReadAll
    public Iterable<User> getAll(){
        return this.repository.findAll();
    }

    //ReadOne
    public User getByID(Integer id){
        return this.repository.findById(id).orElse(null);
    }

    //Delete
    public void deleteUser(Integer id){
        this.repository.deleteById(id);
    }

    //Update
    public User updateUser(Integer id, User updatedUser){
        updatedUser.setId(id);
        return this.repository.save(updatedUser);
    }
}

http://localhost:8080/users--- post--- send
{
    "firstName":"Harry",
    "lastName":"Potter",
    "email":"harrypotter@gmail.com",
    "phone":1234123412,
    "password":"abc",
    "confirmpassword":"abc"
}



db-- select * from user;

https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN--
1:36--day 48

now get-- http://localhost:8080/users/1 -- send

delete--http://localhost:8080/users/1--send

Next is Data REST ---

So now come to ProductController.java
and comment this RestController also in UserController.java

Now what will be the effect of //RestController on our project?
Now since we disabled RestController our complete api got disabled.
So now if u will send any req from postman, it will not reach destination.

and from postman on any url u will get-- 404 error not found.

now till now we created every method,
which is not required.
It is recommended for any special task, but
for simple crud ops, u will not crete methods manually
for restapi.

i.e. the service() methods will be autogenerated.

what we have done till now is manual controller and service.
With DataRest there is no need of creating
controller class, service class.
The complete api will  be auto generated.
And this we will do with the help of a starter called DataREST 
starter. It is the part of springboot.
So to autogenerate restapis, it requires 2 things--
1. Entity class. Our rest api is dependent on our entity.
2. Repository. Because it provides query methods based on entity class.

Now in our case we have both entities and repositories for user and 
product class.

so now, pom.xml--add starter-- data rest--
(Rest repositories web)-- yes-- this will get added--

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-rest</artifactId>
		</dependency>

Now restart ur project--

get --http://localhost:8080/users-- send

RestController is still commented,
then too my api is getting generated.

now see http://localhost:8080 for how many apis
got created.

get-- http://localhost:8080/profile--

and u can see the profile apis .

http://localhost:8080/profile/products
u can see fields.
6 apis got created for product, get, delete,etc

http://localhost:8080/users--
here u will see url-- if u want to see individual link
for individual data if u want to see.

So now lets suppose we will create a different entity.
And see if its api gets created.

So  coming to entity class and we will create entity address.
Stop ur project--
so, entities-->new file Address.java-- 

package com.itvedant.petstoreapp.entities;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.Data;

@Entity
@Data
public class Address {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Integer id;

    private String city;
    private String state;
    private String country;
}


Now start ur project--
so correspondin to our entity, table will get created.
in terminal we can see hibernate generating this query.

do select * from address; -- workbench

now come to postman app- 
get-- http://localhost:8080-- 
u will there is no api for address.

http://localhost:8080/addresses-- giving error.

This is becoz for DataRest to work properly,
u need 2 stuff- 1. Entity Class, 2. Repository
bcoz repository contains query methods, and on these
query methods-- restapi is created.

So now goto repository package--
new file-- AddressRepository.java ---

convert it into an interface.

package com.itvedant.petstoreapp.repositories;

import org.springframework.data.repository.CrudRepository;

import com.itvedant.petstoreapp.entities.Address;

public interface AddressRepository extends CrudRepository<Address,Integer>{

    
} 


And now goto postman app--

post-- http://localhost:8080/addresses -- send

{
    "city":"Mumbai",
    "state":"Maharashtra",
    "country":"India"
}

51:45-----------49-- https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

post--- http://localhost:8080/users-- send
{
    "firstName": "Harry",
    "lastName": "Jerry",
    "email": "harryJerry@gmail.com",
    "phone": "8934123410",
    "password": "abc",
    "confirmpassword":"abc"
}

Now if i want to search , then 1 option is search by id.

get-- http://localhost:8080/users/2-- send

what if i want to search by name , by email,
for that we can create custom query.

repositories are like inventories consisiting of query methods.
So now we will create custom query methods.
We will create them.
query will be generated by hibernate only.

So lets suppose i want search by name.

So, come to UserRepository--

Now the query methods that we r going to create are very very case sensitive.
Also these methods have camel case.


public interface UserRepository 
    extends CrudRepository<User, Integer>{
    List<User> findByFirstName(String name); ---- this is our query method.
}

we can have many users with same name, so List will be returned.
List<User> findByFirstName(String name); name contains the name to be searched.

da49--1:10------https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

So our query method is-- UserRepository.java

public interface UserRepository 
    extends CrudRepository<User, Integer>{
    //custom query methods
    List<User> findByFirstName(String name);
}

Now, next we will see how to run this query.

postman-- get-- http://localhost:8080/users/search/findByFirstName?name=mike

And in the terminal- u can see terminal launching query.

Now go into ProductRepository---

package com.itvedant.petstoreapp.repositories;

import java.util.List;

import org.springframework.data.repository.CrudRepository;

import com.itvedant.petstoreapp.entities.Product;

public interface ProductRepository extends CrudRepository<Product, Integer>{
    //custom query methods
    List<Product> findByName(String name);
}


http://localhost:8080/products/search/findByName?name=red neck band-- get-- send

now for less than , greater than certain price value--

package com.itvedant.petstoreapp.repositories;

import java.util.List;

import org.springframework.data.repository.CrudRepository;

import com.itvedant.petstoreapp.entities.Product;

public interface ProductRepository extends CrudRepository<Product, Integer>{
    //custom query methods
    List<Product> findByName(String name);
    //List<Product> findByPrice(Double price);-- match for equal too
    List<Product> findByPriceGreaterThan(Double price);
    List<Product> findByPriceLessThan(Double price);
}


For list of query methods--
search on url-- query methods in spring data jpa
click on spring jpa query methods--- scroll down--
click jpa query methods

http://localhost:8080/products/search/findByPriceGreaterThan?price=200

    List<Product> findByPriceGreaterThan(Double price);
    List<Product> findByPriceLessThan(Double price);
    List<Product> findByPriceBetween(Double low, Double high);
}


http://localhost:8080/products/search/findByPriceBetween?low=300&high=500

pagination and sorting--
now sorting is in asce or desce order.

get-- http://localhost:8080/products--send--

then we r getting o/p by id like how we inserted.

now what if we want to do sorting by name,
description,price..for that we will need concept
of sorting and pagination.

http://localhost:8080/products----
now here u will get complete o/p present in a table.

What if i want to do something like i want 2 o/p 
on single page, another 2 on another page, etc.

Now to implement paging and sorting , we need to 
make changes in repository.

Now in repository, currently all the repositories are 
extending CrudRepository which provides crud operations.

Now with crud if we want to add paging and sorting too,
then instead of crud, we will use JPA repository.
ProductRepository---

public interface ProductRepository extends JpaRepository<Product, Integer>{
    //custom query methods
    List<Product> findByName(String name);

lly, on address.java and user.java.

day 50--26:14----https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

http://localhost:8080/products-- get-- send

this got added.

"page": {
        "size": 20,
        "totalElements": 11,
        "totalPages": 1,
        "number": 0
    }
}

this is indicating that the size of the current page
is by default 20, total elements that we r showing are 6,
total pages are 1,
and page number starts with 0.

now what if i want to see 2-2 records on ech page..

http://localhost:8080/products?size=2 -- get--- send

 "_links": {
        "first": {
            "href": "http://localhost:8080/products?page=0&size=2"
        },

http://localhost:8080/products?size=2&page=1--- now u will see 2 records 
in this page.

page indexing statrts with 0.

So if u will see--

"page": {
        "size": 2, -- total dispaly in each page.
        "totalElements": 11, -- total elements in product table
        "totalPages": 6, -- current page size
        "number": 1 --- this is the current page no.
    }
also, we r getting links to go on diff pages.

So this is paging,
next is sorting--

http://localhost:8080/products?sort=name--- get-- send

http://localhost:8080/products?sort=name,desc--get-- send

So we r just giving queries,
but in the background, hibernate is generating queries.

Next we want to do jp auditing.

Keeping a track, whoo added record,
who udated it, time when action was performed..

Now we r just mainiating date and time of updation 
and creation--
we will 1st eable jpa auditing.
So go to main class file-- 
i.e. PetstoreappApplication.java
in which ur main function is there--

package com.itvedant.petstoreapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@SpringBootApplication
@EnableJpaAuditing
public class PetstoreappApplication {

	public static void main(String[] args) {
		SpringApplication.run(PetstoreappApplication.class, args);
	}

}

Now coming to Product.java ----

Now we will enable jpa auditing at each entity lvel also,



@Data
@Entity
//@Table(name="tblProduct")
@EntityListeners(AuditingEntityListener.class)
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;


User.java--


@Data
@Entity
@VerifyPassword(field1="password",field2="confirmpassword")
@EntityListeners(AuditingEntityListener.class)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;

Address.java---

@Entity
@Data
@EntityListeners(AuditingEntityListener.class)
public class Address {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Integer id;

Now stop project execution.

Now in Product.java--- we need to add 2 fields---

 private Double price;
    private String description;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
}


Now start ur project and add a new product--

http://localhost:8080/products-- get-- send

if u will see o/p created at updated at-- null

now inserting some values-- 
http://localhost:8080/products-- post--send

    {
                "name": "red neck band",
                "price": 299.0,
                "description": "red neck band for the pet dog"
    }
now see upadted at and created at.

1:00 https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN
day 50

http://localhost:8080/products/154-- put-- send

Now stop ur project.
We will do same thing in User.java too.
and in Address.java too.

Next is projection.

So now we will create UserProjection.java 
inside entities package.

package com.itvedant.petstoreapp.entities;

import org.springframework.data.rest.core.config.Projection;

@Projection(name="userprojection",types = {User.class})
public interface UserProjection {
    // whichever field we want in our result,
    // we will create its getter method in this interface.
    String getFirstName();
    String getLastName();
    String getEmail();
    String getPhone();

}

this means, out of all the fields, i want to show
only these 4 fields of User. 

http://localhost:8080/users?projection=userprojection-- get-- send

package com.itvedant.petstoreapp.entities;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.rest.core.config.Projection;

@Projection(name="userprojection",types = {User.class})
public interface UserProjection {
    // whichever field we want in our result,
    // we will create its getter method in this interface.

    //closed projections-- field of the original class are mapped as it is.
    String getFirstName();
    String getLastName();
    String getEmail();
    String getPhone();
    //open projection-- we can create new fields using the values of the original field.
    @Value("#{target.firstName +' '+ target.lastName}")
    String getFullName();
}


http://localhost:8080/users?projection=userprojection-- get

Now excerpt , 1-to-1 relationship--

Now when we are writimg http://localhost:8080/users?projection=userprojection
then only my subset fields are coming.
What if i want to apply this subset by default.
i.e. on /users also we wil get subset only.

So come to UserRepository--->

package com.itvedant.petstoreapp.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
//import org.springframework.data.repository.CrudRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

import com.itvedant.petstoreapp.entities.User;
import com.itvedant.petstoreapp.entities.UserProjection;

import java.util.List;

@RepositoryRestResource(excerptProjection = UserProjection.class)
public interface UserRepository 
    extends JpaRepository<User, Integer>{
    //custom query methods
    List<User> findByFirstName(String name);
}

the excerpt proj is used to set the default projection,
for extracting all the user records.

get--http://localhost:8080/users-- send

now in the project explorer--click on UserProjection.java

right click-- rename --UserProjection1.java -ok--

Now click on entities-- new file--
name-- UserProjection2.java---

package com.itvedant.petstoreapp.entities;

import org.springframework.data.rest.core.config.Projection;

@Projection(name="userprojection2",types = {User.class})
public interface UserProjection2 {
    Integer getId();
    String getFirstName();
    String getLastName();
    

}


Now come to UserRepository and check if--follo code got 
updated or not.

import java.util.List;

@RepositoryRestResource(excerptProjection = UserProjection1.class)
public interface UserRepository 

UserProjection1 is our default projection.

http://localhost:8080/users?projection=userprojection2

So next topic that we will start is Relationship.

day 51-- 44:26--https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

relationships-- 1 entity is related to another entity.

types of relationship-- 3 types--
1-1
1-*
*-*

1 user can have only 1 addr.

stop the server before making changes.

package com.itvedant.petstoreapp.entities;

import org.hibernate.validator.constraints.Length;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import com.itvedant.petstoreapp.validators.Phone;
import com.itvedant.petstoreapp.validators.VerifyPassword;

import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Transient;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
@Entity
@VerifyPassword(field1="password",field2="confirmpassword")
@EntityListeners(AuditingEntityListener.class)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;

    @NotNull(message = "First Name cannot be null")
    @NotBlank(message = "First Name cannot be blank")
    private String firstName;
    @NotNull(message = "Last Name cannot be null")
    @NotBlank(message = "Last Name cannot be null")
    @Length(min=2,max=10,message="Lastname should have 2-5 characters.")
    private String lastName;
    @NotNull(message = "Email Name cannot be null")
    @NotBlank(message = "Email cannot be null")
    @Email
    private String email;
    @NotNull(message = "Phone Name cannot be null")
    @NotBlank(message = "Phone Name cannot be null")
    @Phone
    private String phone;

    private String password;
    @Transient
    // this will make sure that the col for confirmpwd doesnt get created in table.
    private String confirmpassword;

    // 1 user can have only 1 addr.  ----------------------------------------------
    // addr here is a relationship name.
    @OneToOne
    private Address addr;
}

Now in address.java---

    private String city;
    private String state;
    private String country;

    // 1 addr belongs to only 1 user.
    @OneToOne
    private User user;
}

Now in the User.java--
we want to add foreign key col , to refer to 
the id col of addr.
For this use @JoinColumn annotation.

    private String phone;

    private String password;
    @Transient
    // this will make sure that the col for confirmpwd doesnt get created in table.
    private String confirmpassword;

    // 1 user can have only 1 addr.
    // addr here is a relationship name.
    @OneToOne
    @JoinColumn(name="addr_id")
    private Address addr;
}

Now in address.java---

by default, spring boot will cretae 
the foreign key col that refers to the id of 
the User in the address table too.
To avoid this, we can use, mapped by property.

Address.java---

    private String city;
    private String state;
    private String country;

    // 1 addr belongs to only 1 user.
    @OneToOne(mappedBy = "addr")
    private User user;
}

Now we will starrt our project.
Now while the project is starting,
notice something on terminal--


 integration)
Hibernate: alter table user add column addr_id integer
Hibernate: alter table user drop index UK_rv9h6loo8jgv7c0qpusioorx7
Hibernate: alter table user add constraint UK_rv9h6loo8jgv7c0qpusioorx7 unique (addr_id)
Hibernate: alter table user add constraint FK56bchspm0w348fxhqd5a0lmj3 foreign key (addr_id) references address (id)

the unique constraint is applied because its a 1-to-1 relationship.
and then foreign key constraint also got applied.

https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN
1:10--day 51

http://localhost:8080/users--- get-- send

now in o/p u will see something called as--addr--
 "addr": {
                        "href": "http://localhost:8080/users/2/addr"
                    }

now currently we have not setup any user's address.

so currently if u will do something like--
http://localhost:8080/users/2/addr ------

u will get 404 addr.
The user does exist but its address doesnt exist.

if u will see from workbench too,

if u will do select * from user;

u will see-- addr_id col is there,
but it contain null.

so now we will do this settings.
So come to postman-- to establish relationship---
1st add more addresses in address--

http://localhost:8080/addresses-- post-- send

{
    "city": "Pune",
    "state": "Maharashtra",
    "country": "India"

}

{
    "city": "Nagpur",
    "state": "Maharashtra",
    "country": "India"

}

Now in postman-- new tab--

in 1 tab

http://localhost:8080/users/2/addr -- 

i.e. i want 2nd user addr.
currently it is giving 404.

now same url copy paste in another window.

now in 1tab put get request,
in another tab put put req.

now in put 1, come to headers part.
click on the key part and type--
so basically we r going to set url.

key-- Content-Type
value-- text/uri-list

next come to body part-- select raw--
and keep it text only.
in the body part type url---
http://localhost:8080/addresses/52 ---- send

-- now we r getting internal server error 
goto User.java-- comment verifyPassword.

now goto postman-- put-- http://localhost:8080/users/2/addr--send
u will get 204 no content.

now from workbench do select * from user;

u will see addr_id 52 for user id 2.

also, in postman-- http://localhost:8080/users/2/addr-- get--send

in o/p if u will see-- addr is set to 52.

So next fro many to 1, we will 
have Product and category entity.
And for product and order we will show many to many
entity.

So come to vs code-- 
stop project--

in entities folder-- create new class file--
Category.java--

package com.itvedant.petstoreapp.entities;

import java.time.Instant;

import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.Data;

@Entity
@Data
@EntityListeners(AuditingEntityListener.class)
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;

    private String name;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    
}


day 52-- https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN
--
now between user and address , we have 1-to-1 
relationship,
now this relationship should be reflected inour
tables also.
So for it to reflect, either of the two entities
will choose where in we will be creating foreign key col,
addr can contain fk of user or user can contain fk of
addr.
so currently, we have taken user table to contain,
fk of addr.

i.e.
    @OneToOne
    @JoinColumn(name="addr_id")
    private Address addr;
}

but currently, fk col is getting created 
in both addr and user.
So in order to stop spring boot from creating
fk col in addr also, so using mappedBy property.

so it is saying the relation addr is already 
created in user.  use this realtion only in addr,
instead of creating a new one.

So now 1 to many, many to 1,

1 category many products.
so, List<products> products

Now till now we have category entity,
but to perform crud operation, we need repository
also, so, repositories package--> new -->
CategoryRepository.java

package com.itvedant.petstoreapp.repositories;

import org.springframework.data.jpa.repository.JpaRepository;

import com.itvedant.petstoreapp.entities.Category;

public interface CategoryRepository extends JpaRepository<Category,Integer>{
    
}


now 1 category can have multiple products.
so, goto Category.java--

now while importing list-- make sure its 
from List.util

package com.itvedant.petstoreapp.entities;

import java.time.Instant;
import java.util.List;

import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import lombok.Data;

@Entity
@Data
@EntityListeners(AuditingEntityListener.class)
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;

    private String name;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;

    @OneToMany
    private List<Product> products;

    
}

so we r in category class, an we r saying,
1 category can be related to many products.
So when the object of category class will be
created , it can be mapped to many objects 
of product class.

next establishing many to 1 relationship 
from products end--

so goto Product.java---

 private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;

    @ManyToOne
    private Category category;
}


now relationship is established.
but where exactly, the conept of foreign key
will come into picture--
now 1 to many from categpry is many to 1 from product col.
So, whic evr side many-to-1 is, declare fk there.

in 1 to 1 u can choose,

https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN
day 52-- 
24:00

now there is no concept of obj in rdbms.

Product.java----

    @LastModifiedDate
    private Instant updatedAt;
    
    // 1 product can belong to many category
    @ManyToOne
    @JoinColumn(name = "category_id")
    private Category category;
}

in the mean time - in Category.java--

    @LastModifiedDate
    private Instant updatedAt;

    //1 category can belong to many products
    @OneToMany(mappedBy = "category")
    private List<Product> products;

    
}


So in category col , we donot have any fk,pk,
we only have relationship.

Now starting our project and seeing in db,
if this col gets created--

select * from product; -- category_id col is added
select * from category; -- emoty table


Now going to postman--
http://localhost:8080/products/103/category-- 404 o/p

because we have not created any category, and not done
category_mapping yet.

Now how to create categories-- So 1st close all the tabs,
and start a new tab/

localhost:8080 -- and u will see-- http://localhost:8080/categories{?page,size,sort}"
our entity name is category,
but our rest api takes plural form --so its categories.

http://localhost:8080/categories -- in the o/p -- "categories": []
becuase no category created yet.

Now creating few categories-- so,

post --  http://localhost:8080/categories -- send

{
    "name":"neck band"
}

--
{
    "name":"food"
}

--

lly create for shoes and toys.

http://localhost:8080/categories-- get--
see 4 categories got created.

Next we r going to do category mapping.

http://localhost:8080/products/1-- get-- send

now my category is neck band category.

http://localhost:8080/categories -- get-- neckband category 
is 1.

http://localhost:8080/categories/1 -- get -- so this is 
the mapping that we want.

So come to products table, whose category
we want to set--
http://localhost:8080/products/1/category -- put

body-- raw-- text--

http://localhost:8080/categories/1 -- in the body section

so this is like i want to set a category of product 1
with the help of rest api of category 1.

Dont send the req yet.

Now come to headers--
key--Content-Type   value-- text/uri-list

now do send --- 204 no content

now open a new tab--

copy this url--
http://localhost:8080/products/1/category

-- and paste in new tab-- send-- now u will not get error.

infact the product 1 category, neck band is reflected.

but if i will search for other products for 
which we have not set category , we will
get 404 error.

next we will establish many to many relationship 
between products and orders.

so vs code-- stop project

 come to entities-- create entity--
Orders.java--  

package com.itvedant.petstoreapp.entities;

import java.time.Instant;
import java.time.LocalDate;

import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.Data;

@Entity
@Data
@EntityListeners(AuditingEntityListener.class)
public class Orders {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;
    private LocalDate orderDate;
    private LocalDate shippedDate;

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;

    
    
}


now our entity is Orders
now when restapi will go to create url for it,
it will do something like-- orderses -- which we
donot want.
So we will do customized url--

so come to repositories-- new file--
OrdersRepository.java---

package com.itvedant.petstoreapp.repositories;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;


import com.itvedant.petstoreapp.entities.Orders;

// we r creating custom rest api url here, bcoz if we dont do it,
// the default url for orders will be orderses, which doesnt seem logical
@RepositoryRestResource(collectionResourceRel = "orders", path="orders")
public interface OrdersRepository 
extends JpaRepository<Orders,Integer>{
    
}


Now start project-- orders table will get created now.

orders table got created.

next in postman app-- 

http://localhost:8080-------- just put localhost to see our 
api for order got created.

next we will establish relationship--

many to many--

List<Orders> orders -- List<Product> products

now 1st stop project execution--

come to entity Product.java--


    @ManyToMany
    private List<Orders> orders;
}

lly for order entity-- Orders.java

 private Instant updatedAt;

    @ManyToMany
    private List<Product> products;
    
}

Now we will create a 3rd table-- product_orders.
And it will have 2 cols-- product_id and orders_id

so now choose any products or orders entity.

so product.java---

 private Instant updatedAt;
    
    // 1 product can belong to many category
    @ManyToOne
    @JoinColumn(name = "category_id")
    private Category category;

    @ManyToMany
    // in case of many to many, we will create seperate table,
    //in which we will create 2 join cols.
    //one for product table referring id of the product
    //second for orders table referring id of the orders.
    @JoinTable(name = "product_orders",
                joinColumns = @JoinColumn(name = "product_id",
                referencedColumnName = "id"),
                inverseJoinColumns = @JoinColumn(name = "orders_id",
                referencedColumnName = "id"))
    private List<Orders> orders;
}

now go to Orders--

    @LastModifiedDate
    private Instant updatedAt;

    @ManyToMany(mappedBy = "orders")
    private List<Product> products;
    
}


day 53--- 
spring security----------


http://localhost:8080/products-- get-- send

now do -- http://localhost:8080/products/1/orders -- get -- send

now there are no orders created yet.
So post--

http://localhost:8080/orders

{
    "orderDate":"2023-02-03",
    "shippedDate":"2023-02-04"
}

--
{
    "orderDate":"2023-02-23",
    "shippedDate":"2023-02-24"
}

add 2-3 more orders.

http://localhost:8080/orders-- get--send

now lets suppose 1 product is part of order no. 1 
and order no. 2 also.

http://localhost:8080/products/1/orders--get--send

i.e. who all have palced order for this product..
http://localhost:8080/products/1/orders -- put
header
Content-Type    text/uri-list -- 
body-- text--

http://localhost:8080/orders/1
http://localhost:8080/orders/2

--send

now see in ur workbench-- select * from product_orders;

lly,
put -- http://localhost:8080/products/3/orders--

body-- text--

http://localhost:8080/orders/1
http://localhost:8080/orders/2

-- send

and see in backend-- added

day--53-- 38:00--
https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

Now when the /users, /products etc
req is coming to the controller, 
controller is forwarding req to backend db,
and we r getting all the data stored in the table.

i.e. there is no restriction.

So we can achieve these restrictions by using security.
Security comprise of 2 things--
authentication and authorization.

Authentication is to verify identity,

So between req and controller, we have our security
which applies different filters,
Now 1st filter is our authentication.
Here we can have role based authentication too.

So in springboot-- 
authentication we can do with username/pwd
authorization we can do  by role based methods.

So, for this, 
we need to add security starter to our project.

pom.xml  file-- security-- proceed-- yes
so, security added--

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>


now start ur project--
see in terminal-- somrthing like--

Using generated security password: 4c94d41d-740b-489a-ab19-60239722410e

next in postman-- right click on any tab-- close all the tabs

now create a neew tab-- and try to access-- 
get--http://localhost:8080/orders-- send 

401 unauthorized-- this error comes, when the user 
is unauthenticated.

so now, any url u put, everything is restricted.

so now we need to authorize ourself, then only we can
access db.

so in postman-- goto authorization tab--
select basic auth-- 

http://localhost:8080/orders-- get-- send

username-- user
pwd - this is givenin terminal, paste tht

59:37-- https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN
-- spring security

now the thing here is, the password change,
everytime project is restarted.

So, 2nd method for authentication--

application.properties file--


spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

spring.security.user.name=admin
spring.security.user.password=admin@123

now when u will start ur project,
the default pwd will not come.

so now in postman put same un and pwd.

now everything is accessible with un and pwd.
Whatif i want to share certain things in my project
with user who doesnt know un and pwd.

lets suppose, i want to make /products
public--

so goto main package-- i.e. click petstoreapp

SecurityConfiguration.java
package com.itvedant.petstoreapp;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain configure(HttpSecurity http) throws Exception{
        http.authorizeHttpRequests()
            .requestMatchers("/products")
            .permitAll()
            .anyRequest()
            .authenticated()
            .and()
            .httpBasic();
            
        return http.build();
    }
}


http.build() creates object of SecurityFilterChain

So in SecurityFilterChain-- we r basically setting
security and permiting all req on /products.
but for any other req, we r doing basic authentication.

now going to postman app and checking--

so from postman, remove un and pwd,
and give type no auth only.

then get-- 
http://localhost:8080/products-- send


http://localhost:8080/products/1-- get-- send
i.e. we r accessing product 1, so this is not accessible.

so for making, sub path also accessible,

So, change--

 http.authorizeHttpRequests()
            .requestMatchers("/products/**") ----
            .permitAll()
            .anyRequest()

So now http://localhost:8080/products/1-- get--send--

Now get is allowed,
But when we r doing post-- http://localhost:8080/products

{
    "name": "red neck band",
    "price": 299.0,
    "description": "red neck band for the pet dog"
}

--send--- errror

so even if all the permissions given, still there are restrictions.

now csrf-- cross site erport forgery---
security configuration is not allowing us
so, 1st we will disable it,
csrf--

@Bean
    public SecurityFilterChain configure(HttpSecurity http) throws Exception{
        http.csrf().disable()  ---------------
            .authorizeHttpRequests()
            .requestMatchers("/products/**")
            .permitAll()

so now -- http://localhost:8080/products--post--send

{
    "name": "red neck band",
    "price": 299.0,
    "description": "red neck band for the pet dog"
}

its going.

We can also do -- delete-- http://localhost:8080/products/53--send

but whatif i want to restrict delete.

   @Bean
    public SecurityFilterChain configure(HttpSecurity http) throws Exception{
        http.csrf().disable()
            .authorizeHttpRequests()
            //.requestMatchers("/products/**")
            .requestMatchers(HttpMethod.GET,"/products/**")
            .permitAll()
            .requestMatchers(HttpMethod.POST,"/products/**")
            .anyRequest()

so now we can do get get,post but bot del.

day 54-----https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

So when the req comes,
it interacts with Basuc Authentication Filter,
which interact with authentication manager which will
stop to check for valid user.

Now authentication mgr, interacts with 
User details interface
and 2nd pwd encoder.

User details has info about already existing user.
and it tries to verify.
If the user details exist, then pwd is checked.
Password encoder encodes plain text, and tried to 
match if inputted pwd match with already stored one.

Now if the Authentication mgr gices success,
then it gives success to Basic Auth Filter 
which forwards the req to basic authentication filter.

but if auth mgr gives error i.e. un or pwd match
is not success, then auth mgr gives null and error
to basic auth filter, which gives 401 error.

So coming to pet store project--

application properties.java

1st we will encrypt our pwd,

            .httpBasic();

        return http.build();
    }

    //the pwd will be needed to encode and save pwd in encoded format while registering
    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
}

-- SecurityConfiguaration.java--

package com.itvedant.petstoreapp;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain configure(HttpSecurity http) throws Exception{
        http.csrf().disable()
            .authorizeHttpRequests()
            //.requestMatchers("/products/**")
            .requestMatchers(HttpMethod.GET,"/products/**")
            .permitAll()
            .requestMatchers(HttpMethod.POST,"/products/**")
	    .permitAll()
            .anyRequest()
            .authenticated()
            .and()
            .httpBasic();

        return http.build();
    }

    //the pwd will be needed to encode and save pwd in encoded format while registering
    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
//UserDetailService : Interface that is used by Authentication Provider
// to retrieve the user details object, based on the username that the user
//has used to login.
//UserDetails : This interface contains the info about the user like,
// username,pwd,roles etc which will be returned to the UserDetailService
// so that the user can be authenticated and authorized

@Bean
public UserDetailsService registerUsers(){
    UserDetails user1; // import userdetails.user
    user1 = User.withUsername("harry")
                .password(passwordEncoder().encode("1234"))
                .roles("HR")
                .build();

    UserDetails user2; // import userdetails.user
    user2 = User.withUsername("mike")
                .password(passwordEncoder().encode("1234"))
                .roles("HR")
                .build();

    UserDetails user3; // import userdetails.user
    user3 = User.withUsername("scott")
                .password(passwordEncoder().encode("1234"))
                .roles("IT")
                .build();

    UserDetails user4; // import userdetails.user
    user4 = User.withUsername("dan")
                            .password(passwordEncoder().encode("1234"))
                            .roles("IT")
                            .build();

    // now registering all users with user Detail service
    return new InMemoryUserDetailsManager(user1,user2,user3,user4);
}

}

Now come to postman app-- 

44:27---------- https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

day54

get--http://localhost:8080/products--send -- working ok.
get--http://localhost:8080/users--send--error
so,gto authorization--instead of no auth, put basic auth.
user-- admin, pwd-- admin@123--- send --error

instead, put user- harry and pwd--1234-- get --send--ok

so now we can access by users.

Now doing role based changes--

package com.itvedant.petstoreapp;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain configure(HttpSecurity http) throws Exception{
        http.csrf(csrf -> csrf.disable())
                .authorizeHttpRequests()
                //.requestMatchers("/products/**")
                .requestMatchers(HttpMethod.GET, "/products/**")
                .permitAll()
                .requestMatchers(HttpMethod.POST, "/products/**")
                .permitAll()
                .requestMatchers("/users/**") ----------------------------
                .hasRole("HR") -------------------------------------------
                .requestMatchers("/orders") ---------------------------
                .hasRole("IT") -------------------------------------------
                .anyRequest()
                .authenticated()
                .and()
                .httpBasic();

        return http.build();
    }

    //the pwd will be needed to encode and save pwd in encoded format while registering
    @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
//UserDetailService : Interface that is used by Authentication Provider
// to retrieve the user details object, based on the username that the user
//has used to login.
//UserDetails : This interface contains the info about the user like,
// username,pwd,roles etc which will be returned to the UserDetailService
// so that the user can be authenticated and authorized

@Bean
public UserDetailsService registerUsers(){
    UserDetails user1; // import userdetails.user
    user1 = User.withUsername("harry")
                .password(passwordEncoder().encode("1234"))
                .roles("HR")
                .build();

    UserDetails user2; // import userdetails.user
    user2 = User.withUsername("mike")
                .password(passwordEncoder().encode("1234"))
                .roles("HR")
                .build();

    UserDetails user3; // import userdetails.user
    user3 = User.withUsername("scott")
                .password(passwordEncoder().encode("1234"))
                .roles("IT")
                .build();

    UserDetails user4; // import userdetails.user
    user4 = User.withUsername("dan")
                            .password(passwordEncoder().encode("1234"))
                            .roles("IT")
                            .build();

    // now registering all users with user Detail service
    //InMemoryUserDetailsManager implements UserDetailsService and is used to store
    //user details in the memory.But this is used only when we have small no. of users
    //interacting with the application.
    //If there are more users, then we will implement authentication using database.
    return new InMemoryUserDetailsManager(user1,user2,user3,user4);
}

}

http://localhost:8080/users--get--
basic auth -- harry, 1234-- send

now harry is of hr dept, so it will work.

but if u will try with scott, then error
--403 forbidden

http://localhost:8080/products/search/findByPriceBetween?low=300&high=500
--get-- send

http://localhost:8080/products/search/findByPriceGreaterThan?price=200--
send

its all fine.


these are the methods that we have
created in ProductRepository.

Now , lets say i want to bring restriction
on method level.

lets say FindByName by HR,
findPriceGreterThan by IT

This is method level authorization.

So vscode--SecurityConfiguration.java--

import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity --------------------------
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain configure(HttpSecurity http) throws Exception{
        http.csrf(csrf -> csrf.disable())
                .authorizeHttpRequests()
                //.requestMatchers("/products/**")
                .requestMatchers(HttpMethod.GET, "/products/**")
                .permitAll()
                .requestMatchers(HttpMethod.POST, "/products/**")
                .permitAll()

Now there are 3 ways to do method security.
1. PreAuthorized
2. RolesAllowed
3. Secured.
All these are annotations that can be applied on methods.

So, 1st enableing PreAuthorized--


@Configuration
@EnableMethodSecurity(
    prePostEnabled = true
)
public class SecurityConfiguration {
    @Bean

Next goto ProductRepository.java--
and on the method--


public interface ProductRepository extends JpaRepository<Product, Integer>{
    //custom query methods
    @PreAuthorize("hasRole('HR')") ---------
    List<Product> findByName(String name);
    //List<Product> findByPrice(Double price);-- match for equal too

get--http://localhost:8080/products/search/findByName?name=red neck band
send
error

scott is giving error but not Harry.

In the 2nd technique-- we say-- 
jsr250Enabled = true

SecurityCOnfiguration.java--

@Configuration
@EnableMethodSecurity(
    prePostEnabled = true,
    jsr250Enabled = true
)
public class SecurityConfiguration {
    @Bean

--now in ProductRepository.java--

 @PreAuthorize("hasRole('HR')")
    List<Product> findByName(String name);
    //List<Product> findByPrice(Double price);-- match for equal too
    @RolesAllowed("IT") ---------------------
    List<Product> findByPriceGreaterThan(Double price);


http://localhost:8080/products/search/findByPriceGreaterThan?price=200--
scott can access, harry cannot

Now instead of basic auth,
if we will do no auth , then too we will get error.
--no authentication error.

3rd--

SC.java--

@Configuration
@EnableMethodSecurity(
    prePostEnabled = true,
    jsr250Enabled = true,
    securedEnabled = true
)
public class SecurityConfiguration {
    @Bean

PR.java--

  @PreAuthorize("hasRole('HR')")
    List<Product> findByName(String name);
    //List<Product> findByPrice(Double price);-- match for equal too
    @RolesAllowed("IT")
    List<Product> findByPriceGreaterThan(Double price);
    @Secured("ROLE_HR")
    List<Product> findByPriceLessThan(Double price);

so in secured , don't directly write HR,
instead write -- ROLE_HR

--http://localhost:8080/products/search/findByPriceLessThan?price=200
--get-- send

scott not working, harry working

Next, we have a user entity.

It also has email and pwd, which can
be of use for us.

So, we will do few changes.
like, email should be unique.
also i want username as email,
currently, pwd is getting saved in normal text form.
instead, in encoded password format.

1:31--day 54--https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

User.java----- 

Come to db -- do,
select * from user; --
-- see o/p is stored in normal text format.

truncate user table.-- 
truncate table user;
then add unique constraint--

alter table user modify email varchar(255) unique; 

so now user table is empty.

now come to user.java--

 @NotNull(message = "Email Name cannot be null")
    @NotBlank(message = "Email cannot be null")
    @Email
    @Column(unique = true)  -----------------
    private String email;
    @NotNull(message = "Phone Name cannot be null")
    @NotBlank(message = "Phone Name cannot be null")
    @Phone
    private String phone;
 

Now create a new file under java-->controllers--
AuthController.java---

package com.itvedant.petstoreapp.controllers;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.itvedant.petstoreapp.entities.User;

@RestController
public class AuthController {
    @PostMapping("/register")
    public ResponseEntity<?> register(@RequestBody User user){
        return ResponseEntity.ok("done");
    }
}


Now the pwd that we have in User.java,
we will encode it.And for that we will manually
create api and encode it.So for that we created AuthController.java


So now we will see registration and login through db.
So, email id and encoded pwd will be saved in a table inside db.

Also, every user will have associated role with it.
So currently our user has only 1 role.

So. in User.java we will add 1 more field--


    private String password;

    private String roles; -------------

this field will be used for authorization process.
Now since a single user can have many roles assoicated with him.
So, instead of creating a single String, we will keep this as a list.

 private String password;

    private List<String> roles;----------------

So now 1 user can belong to multiple roles.

Also, corresponding to these roles a new table will be created.
So,here since the field is of collection types,
in db,the field has to be mapped in a seperate table
with id of the user as the foreign key.

So 2 col table will be there, 1 will be the id of the user,
and 2nd the role to which it belongs.

So we r doing this for user authorization.

So 1 st we need to register user onto db.
then store encoded pwd and also attach role to it.
So, we need to annotate this role field--

    private String password;

    @ElementCollection
    private List<String> roles;------------------

Next run ur projet and see if new table is getting created.

u will notice , a new table got created--

Hibernate: create table user_roles (user_id integer not null, roles varchar(255)) engine=InnoDB
Hibernate: alter table user_roles add constraint FK55itppkw3i07do3h7qoclqd4k foreign key (user_id) references user (id)

So come to workbecnch--
use petstore1012;
show tables;

select * from user;
select * from user_roles;

Now corresponding to auth class, we will create service too--S,

services pkg--AuthService.java--

package com.itvedant.petstoreapp.services;

import org.springframework.stereotype.Service;

@Service
public class AuthService {
    
}


Next we r going to autowire this to AuthController.java--


@RestController
public class AuthController {

    @Autowired ----------------------------
    private AuthService service; ----------

Now adding method for registration process
in AuthService.java--

So we already have UserRepository.java which gives us 
methods for saving,updating deleting, etc,
So for inserting a user,
we will create insert method, and use save method 
of our UserRepository.

So autowire UserRepositroy--

 @Autowired
    private UserRepository repository;
    public String register(User user){
        
    }

Now here , we need to add encodede pwd.
And we already have bean for that
in SecurityConfiguartion.java
So we will autoconfigure this.

So 1st we get the user password,
then convert it into encoded format,
next we set encoded pwd for the user.
then save it in db.


package com.itvedant.petstoreapp.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import com.itvedant.petstoreapp.entities.User;
import com.itvedant.petstoreapp.repositories.UserRepository;

@Service
public class AuthService {

    @Autowired
    private UserRepository repository;

    @Autowired
    private BCryptPasswordEncoder encoder;
    public String register(User user){
        String originalPassword = user.getPassword();
        String encodedPassword = encoder.encode(originalPassword);
        user.setPassword(encodedPassword);
        repository.save(user);
        return "User Registered Successfully.";
    }
    
}

Next come to AuthController.java---


    @Autowired
    private AuthService service;

    @PostMapping("/register")
    public ResponseEntity<?> register(@RequestBody User user){
        return ResponseEntity.ok(this.service.register(user)); ------------
    }
}


Start project--

go to postman--
cretae a new tab--
get--http://localhost:8080/register-- send
 
-- 401 unauthorized 

So goto Authorization-- basic Auth-- un--scott, pwd--1234
-- send

405-- method not allowed

Now, the registration process should be open to all.
anyone can register, login should be constrained.

So to handle this, we will make changes in security configurations--
So, SecurityConfiguration.java--

        http.csrf(csrf -> csrf.disable())
                .authorizeHttpRequests()
                //.requestMatchers("/products/**")
                .requestMatchers("/register") ----------
                .permitAll() ---------------------------
                .requestMatchers(HttpMethod.GET, "/products/**")
                .permitAll()

Next coming to postman app and checking if its valid--

Post--http://localhost:8080/register--send
authorization-- no auth-- 
body-- adding some data-- so raw-- json--

{
    "firstName" : "harry",
    "lastName" : "potter",
    "email" : "harry.potter@gmail.com",
    "password" : "1234",
    "phone" : "1234512345",
    "roles" : ["ROLE_HR","ROLE_ADMIN"]
}

-- send--
msg-- User Registerd Successfully.

So now we can perform get request on this user--

get-- http://localhost:8080/users--
now we will do authentication for get user--
so, Authorization-- basic Auth -- un-- harry, pwd-- 1234
-- send-- 
200 ok

select * from user_roles;-- workbench

Now our registration process is done.
U can register different user.
 
post-- http://localhost:8080/register
body-- json--

{
    "firstName" : "mike",
    "lastName" : "spencer",
    "email" : "mike.spencer@gmail.com",
    "password" : "1234",
    "phone" : "1234512345",
    "roles" : ["ROLE_IT","ROLE_ADMIN"]
}

-- send

next going to login process--
the login process should be managed by 
authenticatiionManager.

i.e. when request is sent to /users,
1st user should be authenticated
by authentication manager.
Now authentication manager needs 2 stuff--
1. UserDetailsService
2.PasswordEncoder

Now using registration process, we have
already saved userDetails into db.

So when the user will come and give
un and pwd, UserDetailsService will check
for the user in DB and it is supposed to return,
un,pwd and roles.
And if it doesnt return anything,
then 401 error is returned.
But if the user does exist, then it goes to Pwd Encoder,
If they both pwds matchi.e. UserDetails pwd and Password Encoder pwd,
then go to authorization manager, which will authorize roles.

So 2 things to focus here is UserDetailsService,
PasswordEncoder

Now we already have user class,
which has username, pwd,roles,
so converting this user class into
object of userDetails.

i.e. by rule of java--

class A implements B{}
B b = new A();
so even though object is of child class,
still parent class reference is accessible.

So come to User.java---

@Data
@Entity
//@VerifyPassword(field1="password",field2="confirmpassword")
@EntityListeners(AuditingEntityListener.class)
public class User implements UserDetails{ -------------------
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)


Next,u would be getting this light bulb.
So click on that lightbulb-- add the unimplemented funcs--

Now becoz of this interface,
there will be multiple functions which will get included
in this class.

Now we will set them individually.

1st setting the 4 boolean methods--
For all the 4 return true;

@Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}

next username we will set as email--

    @Override
    public String getUsername() {
        return this.email;
    }

next we r creating a field of the same type,
as that of getAuthorities--

  @JoinColumn(name="addr_id")
    private Address addr;
    private Collection<? extends GrantedAuthority> authorities; ----

this is to setup roles.
but i dont want any col to be created for this in my db.

    @JoinColumn(name="addr_id")
    private Address addr;
    @Transient ----------------
    private Collection<? extends GrantedAuthority> authorities;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {

so--
 @Transient
    private Collection<? extends GrantedAuthority> authorities;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return this.authorities; ---------
    }

    @Override

So this is the user object for doing authentication
and authorization.

Next,we said, UserDeatils type object will be returned.
But who will return this object-

Next we will create a service class with whom Authorization Service 
class manger will interact.

So, services-- MyUserDetailsService.java--
MyUserDetailsService.java---

package com.itvedant.petstoreapp.services;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service ------
public class MyUserDetailsService implements UserDetailsService{ -------

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'loadUserByUsername'");
    }
    
}

Now this loadUserByUsername says,
give me the object of UserDetails,
Authentication manager is going to get the
username, go and check the db, if username
exists or not, and return me that.

So now we will apply logic--

import com.itvedant.petstoreapp.repositories.UserRepository;

@Service
public class MyUserDetailsService implements UserDetailsService{

    @Autowired ----------------------------
    private UserRepository repository; ----

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {


And in our UserRepository we will add method--

    extends JpaRepository<User, Integer>{
    //custom query methods
    List<User> findByFirstName(String name);
    User findByEmail(String email); ------------
}

U can do split down--
 
then going into MyUserDetailsService.java--

now for else part, we need to set authorities--

package com.itvedant.petstoreapp.services;

import java.util.ArrayList;
import java.util.Collection;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import com.itvedant.petstoreapp.entities.User;
import com.itvedant.petstoreapp.repositories.UserRepository;

import jakarta.transaction.Transactional;

@Service
public class MyUserDetailsService implements UserDetailsService{

    @Autowired
    private UserRepository repository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User findUser = repository.findByEmail(username);
        if(findUser == null){
            throw new UsernameNotFoundException("Username does not exists");
        }
        else{
            Collection<GrantedAuthority> authorities = new ArrayList<>();
            for(String role: findUser.getRoles()){
                authorities.add(new SimpleGrantedAuthority(role));
            }

            User user = new User();
            user.setAuthorities(authorities);
            user.setEmail(findUser.getEmail());
            user.setPassword(findUser.getPassword());
            return user; //sent this user to authentication provider
        }
    }
    
}


Next the last thing that we need to update
is SecurityConfiguration.
We will cretae 1 bean for authentication manager.

 @Bean
    public BCryptPasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Autowired
    private MyUserDetailsService service;

    @Bean
    public DaoAuthenticationProvider daoAuthenticationProvider(){
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setPasswordEncoder(this.passwordEncoder());
        provider.setUserDetailsService(service);
        return provider;
}

Then in the config() do the samll change--

                .and()
                .httpBasic()
                .and() -------------
                .authenticationProvider(this.daoAuthenticationProvider());-------

        return http.build();

Next goto postman---

get--http://localhost:8080/users--
autho-- basic auth-- un-- harry.potter@gmail.com , 
pwd-- 1234

Day 56--File upload--
https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN


So, till now what we have done--
to implement authentication, authorization process,
based on the user existing in the db,
1st we need to do registration process.
So to do that, we created 1 api on authcontroller,
called as /register,
which inturn will call the AuthService register method,
. So in authService registration method, the logic is--
we just encodeed our pwd, 
do authorization off for register--
post--http://localhost:8080/register-- send

{
    "firstName" : "bob",
    "lastName" : "brother",
    "email" : "bob.brother@gmail.com",
    "password" : "1234",
    "phone" : "1234512345",
    "roles" : ["ROLE_IT","ROLE_ADMIN"]
}


So our inbuilt authentication provider needs 2 stuff,
encoder and user details service.
this user details service is used to load the user,
based on user names, and if that user exist,
then it returns the obj of user details,
So in the login process what we did, 
we converted our normal user class into a user details class.
where, we defined our username which is our email id.
then we have another property for roles,
this is for the authorization process.
Then we created MyUserDetailsService , which contains
1 single method, So here we have a repository,
With the help of this repository, we r going into our db,
and checking if the user exists with the provided useername,
i.e. the email address, and we will set its properties,
and we will send this user, to the authentication provider,
so that the authentication provider can match the pwd,
. This authentication Provider is present inside SecurityConfiguration,
i.e. DaoAuthenticationProvider.
This will need 2 things- pwd encoder and userDetailsService.

So,  by doing this we r implementing the login process,

So now try to login-- IT roles people can see--
http://localhost:8080/orders
HR people can see--
http://localhost:8080/users

Next is file upload and download--
So when we upload file in a server, every file has 
a url associated with it.

So do select * from product;

Now for all these products, i have some images,
which i will upload in folder of my project,
and in our db, we will have the url of the image,
which we will use to download the image.

So this is the process we will follow for uploading and downloading.
So a folder will be there on which the uploaded file will be saved,
and can be downloaded from. So we will not tell,
this folder location , instead a download link will be provided.

So for this, we need to make changes in application.properties file.
So while uploading a file-- the file will come as a part of request
i.e. request+file.
Where as download process is response+file.

So 1st we need to cretae a folder.
So, in our main folder-->resources -->
highlight resources folder and click on new flder--
-- name it uploads.

Next come to application.properties--
the file can be huge from mb's and gb's.

our file is going to be inpoarts and in parts only ,
it will be saved in our hard disk.

So, these properties are called as multipart properties.

#multipart properties--
spring.servlet.multipart.enabled=true
spring.servlet.multipart.file-size-threshold=2KB

so when the file gets uploaded in the server,
it doest get actually saved in the harddisk of that server.
rather , 1st , the file will be going in the ram memory,
and from ram memory, u want 2KB to be uploaded into the harddisk.
This is because ram memory is faster than harddisk.

spring.servlet.multipart.max-file-size=200KB
spring.servlet.multipart.max-request-size=215MB

here 215 because upload=req+file. 
So additional 15 MB for req.

Next is file storage property--
i.e. the path of folder to upload files.

file.upload-dir=D:\learning\aj\SpringBoot\petstoreapp\src\main\resources\uploads
and convert all the single backslashes into double backslashes.

file.upload-dir=D:\\learning\\aj\\SpringBoot\\petstoreapp\\src\\main\\resources\\uploads

Next,
creating api--
so inside java-- controller--new file--
FileController.java--

package com.itvedant.petstoreapp.controllers;

import org.springframework.web.bind.annotation.RestController;

@RestController
public class FileController {
    
}


Next creating a service-- so, services--new file--FileService.java

u can split widows between these 2 files--

@RestController
public class FileController {
    @Autowired
    private FileService service;

next cretaing api's so-- 1st api is--

So, fileController.java--

package com.itvedant.petstoreapp.controllers;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.itvedant.petstoreapp.services.FileService;
import org.springframework.web.bind.annotation.GetMapping;


@RestController
public class FileController {
    @Autowired
    private FileService service;

    @PutMapping("/products/{id}/upload")
    public ResponseEntity<?> upload(@PathVariable Integer id, @RequestParam("file") MultipartFile file){
        return ResponseEntity.ok("done");
    }    
   
    @GetMapping("/products/download/{filename}")
    public ResponseEntity<?> download(@PathVariable String filename){
        return ResponseEntity.ok("Done");

    }
    
}


Now the thing is , the path that we have defined 
of our upload folder, we cannot acces it directly.
So come to FileService.java--

@Service
public class FileService {
    private final Path --- now many Path options are there, so take, java.nio.file
So,

@Service
public class FileService {
    private final Path rootLocation;
    
}
 its giving error bcoz we have not defined it yet.
So now we will create constructor,
Also, in application.properties, spring.servlet
are the  predefined properties of springboot.
But, file.upload_dir is not predefined.

So bcoz of this we will create pojo class.
i.e. we need to declare a class defining this property.

So, click on petstoreapp package--
create a new file-- FileStorageProperties.java--

Next 1st we need to define FileStorageProperties
as a properties file, so for that , we need to annotate it.
@ConfigurationProperties
then ain application.properties--
file.upload-dir----- prefix is file-- So,
@ConfigurationProperties(prefix = "file")

So,
package com.itvedant.petstoreapp;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "file")
public class FileStorageProperties {
    private String uploadDir;
}


And since we want its getter setter methd, we
will add lambork methods.
Because when we will set the property,
we will call setter().
And while reading we will use getter().
So, annotate with @Data

import lombok.Data;

@ConfigurationProperties(prefix = "file")
@Data
public class FileStorageProperties {
    private String uploadDir;
}


Next 1 more setting u need to do--
inmain file i.e. PetstoreApplication.java--

@SpringBootApplication
@EnableJpaAuditing
@EnableConfigurationProperties({FileStorageProperties.class}) -------
public class PetstoreappApplication {

	public static void main(String[] args) {
		SpringApplication.run(PetstoreappApplication.class, args);
	}

}



}


This change we have done to read the upload-dir property.

Next coming to FileService.java--

Here 1st we will do dependency injection.

package com.itvedant.petstoreapp.services;

import java.nio.file.Path;
import java.nio.file.Paths;

import org.springframework.stereotype.Service;

import com.itvedant.petstoreapp.FileStorageProperties;

@Service
public class FileService {
    // this variable will contain the path of the folder 
    // where the files has to be uploaded and downloaded
    private final Path rootLocation;

    //this is constructor based injection
    public FileService(FileStorageProperties properties){
        // here we r initializing the value for the rootLocation
        this.rootLocation = Paths.get(properties.getUploadDir());
    }

}

Next creating 2 functions with the help of which,
we r going to do actual upload and download.

So from our controller,
we r going to receive id and the file,

So our FileService.java--

package com.itvedant.petstoreapp.services;

import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

import org.apache.tomcat.util.http.fileupload.FileUpload;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.server.ResponseStatusException;

import com.itvedant.petstoreapp.FileStorageProperties;

@Service
public class FileService {
    // this variable will contain the path of the folder 
    // where the files has to be uploaded and downloaded
    private final Path rootLocation;

    //this is constructor based injection
    public FileService(FileStorageProperties properties){
        // here we r initializing the value for the rootLocation
        this.rootLocation = Paths.get(properties.getUploadDir());
    }

public String fileUpload(Integer id, MultipartFile file){
    try{
        // so here the file which is coming with the req, we will read that file
        // using InputStream
        // and then write the same in the uploads folder
        // so basically we will copy the req file and paste it in uploads folder
        // so 1st we need to specify destination's file path.
        // so destinationFile specify's the name of the file on the upload's folder.
        // It should be same as the file coming in request. 
        Path destinationFile = this.rootLocation.resolve(file.getOriginalFilename());

        // here setting the inputstream to read the file coming in the request.
        InputStream inputStream = file.getInputStream();
        // now since getInputStream is giving an exception, hence enclosing the entire code in try catch.

        // after try catch, now we r ready to copy th file and write it in destination location.
        Files.copy(inputStream,destinationFile,StandardCopyOption.REPLACE_EXISTING);
        return "File Uploaded Successfully";
    
    }
    catch(Exception e){
        throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR,
        "Server facing some issue in uploading the file");
    }

}


}


So next, trying file uploading part--
u can search for 1st product on browser--- 
lets suppose-- green neck band--
save that image-- in some folder.

Next, start service and  come to postman--
put-- http://localhost:8080/products/1/upload

now, authorization-- no
body-- form-data -- 
key--file-- next just hover right of file and 
u will get dropdown list-- select file from there--
-- send---

Now, we have kept put method disabled in FileController.java--
So, instead of PutMapping do PostMapping--

   private FileService service;

    @PostMapping("/products/{id}/upload") ------------
    public ResponseEntity<?> upload(@PathVariable Integer id, @RequestParam("file") MultipartFile file){
        return ResponseEntity.ok("done");
    } 

So post--http://localhost:8080/products/1/upload--
send-- o/p done.

Next instead of done in above file--

    private FileService service;

    @PostMapping("/products/{id}/upload")
    public ResponseEntity<?> upload(@PathVariable Integer id, @RequestParam("file") MultipartFile file){
        return ResponseEntity.ok(this.service.fileUpload(id, file)); --------
    }    


Next check in the upload folder--
u can see the file.

https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN--
day 56-- file upload/download,frontend creation
from start.

Till now we have just uploaded our file.
we have copied the file into request folder.
And this file is associated with a particular product id,
And i want to upload its image url, 
so that when i want to download the file,
the image url can be used for download of
that product only.

So if we want to associate this file with particular product,
so for that, we will create an image url and using that image url,
we can download that fiel.

So Product.java-- we will add one field--

                referencedColumnName = "id"))
    private List<Orders> orders;

    private String imageUrl; ---------
}

So in this field we will save the download url for the image.


9:00-- day 56 --https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

So now lets suppose i want to attach image with the particular product,
then, we need to create an imagge url,
using which, we can download the file only for that product.

So we have defined imageurl for ,
attaching the uploaded file and also for downloading 
purpose.


Next come to FileService.java--
Now till now, in fileservice, we r reading the file from original
location, and we r using copy func to copy this file,
from original location to destination folder,

Now, i want this process to happen when the id i'm passing,
is existing. If id doesnot exist then this file upload should not happen.
Becoz along with product, we need to update product image also.
, by using which that image can be downloaded.

so, fileService.java--
inside try block--
Product foundProduct = this.
now because we will use prioduct repository,
we need to autowire product repository for 
executing our select cmd.,

    public FileService(FileStorageProperties properties){
        // here we r initializing the value for the rootLocation
        this.rootLocation = Paths.get(properties.getUploadDir());
    }

@Autowired
private ProductRepository repository;

public String fileUpload(Integer id, MultipartFile file){
    	Product foundProduct = this.repository.findById(id).orElse(null); -------------- now if the product id exist, it will return the object of that product id. Otherwise null.
        
	try{
        // so here the file which is coming with the req, we will read that file

So now,
FileService.java---

package com.itvedant.petstoreapp.services;

import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.server.ResponseStatusException;

import com.itvedant.petstoreapp.FileStorageProperties;
import com.itvedant.petstoreapp.entities.Product;
import com.itvedant.petstoreapp.repositories.ProductRepository;

@Service
public class FileService {
    // this variable will contain the path of the folder 
    // where the files has to be uploaded and downloaded
    private final Path rootLocation;

    //this is constructor based injection
    public FileService(FileStorageProperties properties){
        // here we r initializing the value for the rootLocation
        this.rootLocation = Paths.get(properties.getUploadDir());
    }

@Autowired
private ProductRepository repository;

public String fileUpload(Integer id, MultipartFile file){
    Product foundProduct = this.repository.findById(id).orElse(null);
    try{
        if(foundProduct==null){ ---------------------------------------- put earlier written code in else part.
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                            "Product with this Id doesnot exist.");       
        }
        else{
            // so here the file which is coming with the req, we will read that file
            // using InputStream
            // and then write the same in the uploads folder
            // so basically we will copy the req file and paste it in uploads folder
            // so 1st we need to specify destination's file path.
            // so destinationFile specify's the name of the file on the upload's folder.
            // It should be same as the file coming in request. 
            Path destinationFile = this.rootLocation.resolve(file.getOriginalFilename());

            // here setting the inputstream to read the file coming in the request.
            InputStream inputStream = file.getInputStream();
            // now since getInputStream is giving an exception, hence enclosing the entire code in try catch.

            // after try catch, now we r ready to copy th file and write it in destination location.
            Files.copy(inputStream,destinationFile,StandardCopyOption.REPLACE_EXISTING);
            return "File Uploaded Successfully";
        }
    
    }
    catch(Exception e){
        throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR,
        "Server facing some issue in uploading the file");
    }

}


}

Now how to update the imageurl--
So 1st we will copy the file which user is 
sending in request, then we can change.
So we will do this before return stmt.

so for that we, need localhost path
i.e. localhost:8080,
this we get from ServletComponent
21:15-------56-https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

// after try catch, now we r ready to copy th file and write it in destination location.
            Files.copy(inputStream,destinationFile,StandardCopyOption.REPLACE_EXISTING);

            //ServletUriComponentsBuilder.fromCurrentContextPath() gives--
            //http://localhost:8080
            String imageUrl = ServletUriComponentsBuilder.fromCurrentContextPath()-------

so after this, whichever path u want to create, u can create.
So,

 @Autowired
    private ProductRepository repository;

    public String fileUpload(Integer id, MultipartFile file){
        //First we are checking if the product with id provided exists in the
        //database or not because we will do uploading only for existing products
        Product foundProduct = this.repository.findById(id).orElse(null);
        try{            
            if(foundProduct == null)
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, 
                                                "Product with ID does not exists");
            else{
                //File which is coming along with the request we will read that file
                //using InputStream
                //and then write the file in the uploads folder
                //basically we copy the request file and paste it in the uploads folder

                //This statement is specifying what should be the name of the file in the
                //uploads folder. It should be same as that of the request file
                Path destinationFile = this.rootLocation.resolve(file.getOriginalFilename());

                //setting the inputstream to read the file coming in the request
                InputStream inputStream = file.getInputStream();

                //now we will copy the file and write in the destination location
                Files.copy(inputStream, destinationFile, StandardCopyOption.REPLACE_EXISTING);
                
                //ServletUriComponentsBuilder.fromCurrentContextPath() ==>
                //will give http://localhost:8080
                @SuppressWarnings("null")
                String imageUrl = ServletUriComponentsBuilder.fromCurrentContextPath()
                                        .path("/products/download/")
                                        .path(file.getOriginalFilename())
                                        .toUriString();

                //we will update imageUrl for the product
                foundProduct.setImageUrl(imageUrl);
                //saving in the database
                this.repository.save(foundProduct);
                
                return "File Uploaded Successfully";
            }
        }
        catch(Exception e){
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR,
                            "Server facing some issue in uploading the file");
        }
    }

    
Next run project.
get-- http://localhost:8080/products -- send

now see, for every product 1 field got created --
imageurl.

Now lets suppose i want to upload image for produict
id 1.

post-- http://localhost:8080/products/1/upload--

Next writing code for file download--
so,
public Resource--- now this resource is from,org.springFramework.core.io

//import org.springframework.core.io.Resource;
    public Resource fileDownload(String fileName){
        Path filePath = rootLocation.resolve(fileName);   --- path is from java.nio.file
   	// now resolve actually go inside root location and see if that file exist or not.
        try{
            Resource downloadedFile = new UrlResource(filePath.toUri()); //---- here we r trying to read the file
	    // so file is a type of a resource which we will be reading.
            return downloadedFile;
        }
        catch(Exception e){
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, 
                                                "File Cannot be Downloaded");
        }
    }
}



Next making changes in FileController.java--

 @PostMapping("/products/{id}/upload")
    public ResponseEntity<?> upload(@PathVariable Integer id, @RequestParam("file") MultipartFile file){
        return ResponseEntity.ok(this.service.fileUpload(id, file));
    }    
   
    @GetMapping("/products/download/{fileName}") ----------------
    public ResponseEntity<?> download(@PathVariable String fileName){
        Resource resource = this.service.fileDownload(fileName);
        return ResponseEntity.ok()
        .header(HttpHeaders.CONTENT_DISPOSITION,
        "attachment; filename=\"" + fileName + "\"")
                             .body(resource);

    }
    
}


so in the .header , we r saying file is returned
as part of an attachment, from httpheaders from 
org.springFramework.http.
content disposition says that its an attchment.

So make sure--
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
are there.

Next open postman--
get--http://localhost:8080/products--send

then click on the image-url--

get-- http://localhost:8080/products/download/dog%20shoes%20red.jpg--send

u will see some binary o/p.

Now get req u can do form browser.
So paste this url on browser--  u will see file is
getting downloaded.

Next creating a frontend---
So come to vs code---file--new window

in the background springbot folder will be opened.

Now in the new window-- file-- open folder--
on path D:\learning\aj\SpringBoot--
petstoreappfrontend---select folder

Now just select the folder name-- new file--
index.html--- type html:5 and u will get abbreviation.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glitter Pet Store</title>
    <link href="main.css" rel="stylesheet"> ---- add after main.css file is cretaed
</head>
<body>
    <header>
        <h1>Glitter PetStore</h1>
        <h3>Best products for your beloved Pets.</h3>
    </header>
    <div id="content">
        Product data will apppear here.
    </div>
</body>
</html>



Next create another file--

header{
    text-align: center;
    background-color: greenyellow;
    color: navy;
    padding: 20px;
}

h3{
    font-style: italic;
}

table{
    width: 100%;
    margin-top: 10px;
    border-collapse: collapse;
}

table,th,td{
    border: 1px solid black;
}

th,td{
    padding: 10px;
}

.price,.name{
    text-align: center;
}

.name,.description{
    text-transform: capitalize;
}

Now to run this html page-- add an extension--
live server-- install it.

then right click on index.html-- open with live server--

then create a new file-- main.js--

function fetchData(){
    alert("testing the function call");
}

then in index.html---

    <title>Glitter Pet Store</title>
    <link href="main.css" rel="stylesheet">
    <script src="main.js"></script> ------------
</head>
<body onload="fetchData()"> ------------
    <header>
        <h1>Glitter PetStore</h1>

day 57-- https://drive.google.com/drive/folders/1SgUXKhGtGAf20LFpV4cRRg8-3-cFLwoN

Frontend creation,HTTP client API

Now run the backend part and in the mean time
open the front end part.

So in the front end, the fetchData() is called when 
the body is loaded.

right click on index.html-- open with live server.
The pop up says the function is getting called.

Start xampp and start backend.

browser--http://localhost:8080/products -- we can do get req from browser.
So we will fetch this data from backend and show it in front end.

So we will take help of public rest apis.

Search public rest apis on browser--
open the one with postman symbol-- Animals-- Cat Facts--
we have this url--https://cat-fact.herokuapp.com/facts/ run it-- 

u can see the data in json format.

Do pretty print--- and u will see cats related facts.

Now if we want to read this,
then in the java script there is a method called
fetch method by which we can do it.

so come to fetchData()--

function fetchData(){
    fetch("https://cat-fact.herokuapp.com/facts/")
    .then(data => data.json())
    .then(data => alert(data));
}

Now in the live server-- in the alert box,
we will see object,object,object....

Now, if we will put our products url , then--

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json())
    .then(data => alert(data));
}

now on live server, we r not getting this.
Why bcoz-- when we will inspect live server--
in the console-- we will get error--
this isss bcoz the port numbers are different.
1 is 8080, another 5500--

So in our springboot, we have disabled the requ coming from another server.
To enable it we will need to enable cross origin.

So, in the backend vs code--
ProductRepository.java---

import jakarta.annotation.security.RolesAllowed;

@CrossOrigin(origins = "*",allowCredentials = "false") --- u can even mention like localhost:5500, etc. We r enabling for everyone
public interface ProductRepository extends JpaRepository<Product, Integer>{
    //custom query methods
    @PreAuthorize("hasRole('HR')")


So, if we want to see inside object data,

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json())
    .then(data => alert(JSON.stringify(data)));
}

or,

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json())
    .then(data => console.log(data)); 
}

this is giving.

but we want to present this data on html.

this will also be allowed just by adding cross origin 
on ProductRepository.java--

import jakarta.annotation.security.RolesAllowed;

@CrossOrigin(origins = "*") --------
public interface ProductRepository extends JpaRepository<Product, Integer>{


Now , we r getting complete pages and othe o/p on console.
If we only want embedded , then--

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json())
    .then(data => console.log(data._embedded.products)); --------
}

so this will only give product objects.


Now in the js -- when we have multiple lines of code,
enclose the code  in {}.
So if its a single line code, write it directly.
Or else, enclose in {} and then write codes.

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json())
    .then(data => {
        for( let p of data._embedded.products){
            console.log(p)
        }
    });
    
}

so see, in console, individual product objects r 
getting printed.

if i will do --
console.log(p.name)-- then product name is printed,
lly with price.

or, 
console.log(p.name + " " + p.price) 

=> {
        for( let p of data._embedded.products){
            console.log(p.name)
        }
    }

so this part is actually arrow func or anonymous func,
and because it has more than 1 stmt,
thats why we r enclosing it within {}.

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json()) 
    // here we r extracting just the json data from the response
    // and putting into data
    // in the next then, we r passing input data to extract product info 
    .then(data => {
        for( let p of data._embedded.products){
            console.log(p.name)
        }
    });
    
}

next we will see how to display on html page--

So ,

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json()) 
    // here we r extracting just the json data from the response
    // and putting into data
    // in the next then, we r passing input data to extract product info 
    .then(data => {
        let div = document.getElementById('content') -----
        div.innerHTML = "Some HTML Content" ---------------
        for( let p of data._embedded.products){
            console.log(p.name)
        }
    });
    
}


Next go to http://127.0.0.1:5500/index.html and u will see.

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json()) 
    // here we r extracting just the json data from the response
    // and putting into data
    // in the next then, we r passing input data to extract product info 
    .then(data => {
        let div = document.getElementById('content')
        output = ' '
        output += '<table>'
        output += '<tr>'
        output += '<th>Name</th>'
        output += '<th>Price</th>'
        output += '<th>Description</th>'
        output += '</tr>'
        div.innerHTML = "Some HTML Content"
        for( let p of data._embedded.products){
            console.log(p.name)
        }
        output += '</table>'
        div.innerHTML = output
    });
    
}

this gave us our table.

For adding border and all, u can do changes in css--


table{
    width: 100%;
    margin-top: 10px;
    border-collapse: collapse;
}

table,th,td{
    border: 1px solid black;
}

th,td{
    padding: 10px;
}

--

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json()) 
    // here we r extracting just the json data from the response
    // and putting into data
    // in the next then, we r passing input data to extract product info 
    .then(data => {
        let div = document.getElementById('content')
        output = ' '
        output += '<table>'
        output += '<tr>'
        output += '<th>Name</th>'
        output += '<th>Price</th>'
        output += '<th>Description</th>'
        output += '</tr>'
        div.innerHTML = "Some HTML Content"
        for( let p of data._embedded.products){
            //console.log(p.name)
            output += '<tr>'
            output += '<td>' + p.name + '</td>'
            output += '<td>' + p.price + '</td>'
            output += '<td>' + p.description + '</td>'
            output += '</tr>'
        }
        output += '</table>'
        div.innerHTML = output
    });
    
}

in main.css--

.price,.name{
    text-align: center;
}

.name,.description{
    text-transform: capitalize;
}

and in main.js--

function fetchData(){
    fetch("http://localhost:8080/products")
    .then(data => data.json()) 
    // here we r extracting just the json data from the response
    // and putting into data
    // in the next then, we r passing input data to extract product info 
    .then(data => {
        let div = document.getElementById('content')
        output = ' '
        output += '<table>'
        output += '<tr>'
        output += '<th>Name</th>'
        output += '<th>Price</th>'
        output += '<th>Description</th>'
        output += '</tr>'
        div.innerHTML = "Some HTML Content"
        for( let p of data._embedded.products){
            //console.log(p.name)
            output += '<tr>'
            output += '<td class="name">' + p.name + '</td>'
            output += '<td class="price">' + p.price + '</td>'
            output += '<td class="description">' + p.description + '</td>'
            output += '</tr>'
        }
        output += '</table>'
        div.innerHTML = output
    });
    
}

Next we will create normal core java project 
to get access to rest api.


So, either of front end or back end u can take.

So, lets take front end vs code only--
view--cmd pallete-- cretae java project--
no build tools--select the project location --
then click on select the project location

give the name to the project --  httpclientdemo

Now close the front end window.

So now we will work on core java.

we will work on src folder of core java.

Now http client api comprises of 3 major classes
and methods to send the req to the url and get back the response.

HttpRequest will create the req object and here, we will mention the 
url to which req is to be sent.

HttpClient -- will send the req to the url and get 
the response from that url.

HttpResponse -- It is the response that will be received 
by the HttpClient object.

app.java---

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

public class App {
    public static void main(String[] args) throws Exception {
        String url = "https://www.google.co.in/";
        HttpRequest request = HttpRequest.newBuilder()
        .GET()
        .uri(URI.create(url))
        .build();

        HttpClient client = HttpClient.newBuilder().build();

        HttpResponse<String> response = client
                    .send(request, HttpResponse.BodyHandlers.ofString());
                    
        System.out.println(response.body());
    }
}

So here, in HttpRequest we r creating req
HttpClient will send this req,
And when we r sending the req,
we want to capture the response in string format.
So,
HttpResponse<String> response = client
                    .send(request, HttpResponse.BodyHandlers.ofString());
response will come when client will send the req,
and reponse is received, HttpResponse, in string format.

So now run the program--we got entire page.

So now, rather than google, if we will put 
public static void main(String[] args) throws Exception {
        //String url = "https://www.google.co.in/";
        String url = "http://localhost:8080/products"; --------- for this make sure springboot project is running.
        HttpRequest request = HttpRequest.newBuilder()
        .GET()

then,
we got product list in our terminal.


to read the json data, for that there is no
predefined library in java. So we need to 
download the library--
search-- json simple 1.1.1 jar download--
download from java2s--
http://www.java2s.com/Code/Jar/j/Downloadjsonsimple111jar.htm
-- keep the folder

unzip that file--

now copy the jar file into ur project folder.
i.e. D:\learning\aj\SpringBoot

then come vs code-- on th down left,
java project-- referenced libraries-- click +
and add the extracted jar file.

So, json-simple-1.1.1.jar file is added.

day 58--
so now we will use preexisting api of Currency Conversion,

Now, the response is a json data.
So for parsing the json data and reading it,
we need the jar file.

So now we will open our browser with already existing api,

NOrmally we send the url by postman app.
but through http client demo, we sent the url ourself,

Now we cannot read the json data so we need json api,
for parsing and reading json data.

So 1st we r trying to fetch data through existing api.

So goto browser and search for public rest apis.

select by postman.

 
  //String url = "http://localhost:8080/products";
        String url = "https://cat-fact.herokuapp.com/facts";  --------
        HttpRequest request = HttpRequest.newBuilder()
        .GET()
run it.
Now lets suppose we want to extract only facts.
Now we want to see fatcs which are present
in list.

in the list u have status,id,etc.

So 1 st cretae json parser object.
Now on accessing the url, we r first 
getting json array inside which we have data.

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

public class App {
    public static void main(String[] args) throws Exception {
        //String url = "https://www.google.co.in/";
        //String url = "http://localhost:8080/products";
        String url = "https://cat-fact.herokuapp.com/facts";
        HttpRequest request = HttpRequest.newBuilder()
        .GET()
        .uri(URI.create(url))
        .build();

        HttpClient client = HttpClient.newBuilder().build();

        HttpResponse<String> response = client
                    .send(request, HttpResponse.BodyHandlers.ofString());
                    
        //System.out.println(response.body());

        JSONParser parser = new JSONParser();
        JSONArray factArray = (JSONArray)parser.parse(response.body());

        for(Object fact : factArray){
            System.out.println("fact "+fact);
        }
    }
}

So here jsonObjectis collection of facts.

now, lets suppose from these facts i only want
the text part. So, 1st convert fact into JSONobject
and then get text.

  JSONArray factArray = (JSONArray)parser.parse(response.body());

        for(Object fact : factArray){
            System.out.println("fact : " + ((JSONObject)fact).get("text")); ---------
        }
    }


So response query is giving data in {} as json array.
Now inside this json array there is jsn object.
Inside object we have text field which cntains facts
that we want to access.
So, we used parser for parsing the array,
which parses each and every object to get the 
text field which contains facts.

If u want to see status , then u --

 for(Object fact : factArray){
            System.out.println("fact : " + ((JSONObject)fact).get("status")); ------
            System.out.println("fact : " + ((JSONObject)fact).get("text"));
        }


So now for currency converter--

browser search-- currency converter--

https://www.exchangerate-api.com/

documentation-- api endpoints-- standard response--

GET https://v6.exchangerate-api.com/v6/YOUR-API-KEY/latest/USD---
this will give usd rate.

For using this api,
1st create access key.
So, click on get free key--

sign in and get the link.

and u will get the access key.

parinita@itvedant.com
pwd-- 123456

Once the account is activated,
u will get api access key.

Next creaet a new file-- CurrencyConverter.java--

copy paste main func from app.java--


import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

public class CurrencyConverter {
    public static void main(String[] args) throws Exception {
        String url = "https://v6.exchangerate-api.com/v6/"https://v6.exchangerate-api.com/v6/0ee79ca9df3a350b4616675d/latest/USD";/latest/USD";
        
        HttpRequest request = HttpRequest.newBuilder()
        .GET()
        .uri(URI.create(url))
        .build();

        HttpClient client = HttpClient.newBuilder().build();

        HttpResponse<String> response = client
                    .send(request, HttpResponse.BodyHandlers.ofString());
                    
        System.out.println(response.body());

       
    }

    
    
}

Now instead of usd if u will do eur, then it will gve
europe conversion rate.

Next doing some changes--

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

public class CurrencyConverter {
    public static void main(String[] args) throws Exception {
        System.out.println("Welcome to Currency Cnverter");
        System.out.println("Select the currency code of the currency to be converted into INR ");
        String[] currencyCode = {"USD","EUR","GBP","JPY"};
        for(int i=0; i<currencyCode.length;i++){
            System.out.println(i+1 + " . "+currencyCode[i]);
        }
        String url = "https://v6.exchangerate-api.com/v6/0ee79ca9df3a350b4616675d/latest/USD";
        HttpRequest request = HttpRequest.newBuilder()
        .GET()
        .uri(URI.create(url))
        .build();

        HttpClient client = HttpClient.newBuilder().build();

        HttpResponse<String> response = client
                    .send(request, HttpResponse.BodyHandlers.ofString());
                    
        System.out.println(response.body());

       
    }

    
    
}

run and see.

Next we want to make it user driven--

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.Scanner;

public class CurrencyConverter {
    public static void main(String[] args) throws Exception {
        System.out.println("Welcome to Currency Cnverter");
        System.out.println("Select the currency code of the currency to be converted into INR ");
        String[] currencyCode = {"USD","EUR","GBP","JPY"};
        for(int i=0; i<currencyCode.length;i++){
            System.out.println(i+1 + " . "+currencyCode[i]);
        }
        System.out.println("Enter your Choice : ");
        Scanner sc = new Scanner(System.in);
        int choice=sc.nextInt();

        if(choice>=1 && choice<=6){
            String url = "https://v6.exchangerate-api.com/v6/0ee79ca9df3a350b4616675d/latest/USD";
            HttpRequest request = HttpRequest.newBuilder()
            .GET()
            .uri(URI.create(url))
            .build();

            HttpClient client = HttpClient.newBuilder().build();

            HttpResponse<String> response = client
                        .send(request, HttpResponse.BodyHandlers.ofString());
                        
            System.out.println(response.body());
        }
        else{
            System.out.println("Enter correct choice. ");
        }

       
    }

    
    
}

So now i want to update my url accordingly--


        if(choice>=1 && choice<=6){
            String url = "https://v6.exchangerate-api.com/v6/0ee79ca9df3a350b4616675d/latest/"+currencyCode[choice-1];---------
            HttpRequest request = HttpRequest.newBuilder()
            .GET()
            .uri(URI.create(url))
            .build();


Now the o/p that we r getting is of single json object.
So we will use parser to extract the information.

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.Scanner;

import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

public class CurrencyConverter {
    public static void main(String[] args) throws Exception{
        System.out.println("Welcome to Currency Converter");
        System.out.println("Select the currency code of the currency to be converted into INR: ");

        String[] currencyCode = {"USD","EUR","GBP","JPY","KRW","CNY"};

        for(int i = 0; i <currencyCode.length; i++){
            System.out.println(i+1 + ". " + currencyCode[i]);
        }

        System.out.print("Enter your choice: ");
        Scanner sc = new Scanner(System.in);
        int choice = sc.nextInt();

        if(choice >= 1 && choice <= 6){

            System.out.print("Enter the amount of this currency that you have: ");
            float amount = sc.nextFloat();

            String url = "https://v6.exchangerate-api.com/v6/a64dec9a4f8f3ac3c6286020/latest/" 
                                + currencyCode[choice-1];

            HttpRequest request = HttpRequest.newBuilder()
                                            .GET()
                                            .uri(URI.create(url))
                                            .build();

            HttpClient client = HttpClient.newBuilder().build();

            HttpResponse<String> response = client.send(request, 
                                HttpResponse.BodyHandlers.ofString());

            // System.out.println(response.body());
            JSONParser parser = new JSONParser();

            JSONObject obj = (JSONObject)parser.parse(response.body());
            JSONObject conversionRate = (JSONObject)obj.get("conversion_rates");
            System.out.println("Amount in " + currencyCode[choice-1] + ": " + amount);
            System.out.println("Converted Amount in INR: " + amount * (double)conversionRate.get("INR"));
        }
        else{
            System.out.println("Retry.... Wrong Choice Selected!!!");
        }
    }
}

Now testing--
creating test cases,
System testing,
Unit testing.

So we will do unit testing where individual
function or api i.e. single unit will be tesed.

So  creating a new project in spring boot--

view--cmd paletter--spring initializer--
select ver for string, java,
com.itvedant--testingdemo--
jar--
dependencies--spring web and dev tools--
select the folder where u want to create poject.

next -- open folder and open testingdemo.

goto test\java\com----



next src--main--jaav--testingdemo.java--
now this class is already annotated with SpringBootTest
It is used to mark a class
containing multiple test cases.


day 59--------- Unit testing--
17:00

package com.itvedant.testingdemo;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TestingdemoApplicationTests {

	@Test
	void contextLoads() {
		System.out.println("Welcome to unit testing");
	}

}

then to start the testing part--

now to run-- terminal--by default power shell opens up,
we want cmd shell terminal--
$.\mvnw test

Next in test-->testingdemo.java-- only create 
new file-- calculator.java--



now if suppose they are not matching

i.e. in Calculator.java--

package com.itvedant.testingdemo;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class Calculator {
    public int add(int a, int b){
        return a+b;
    }


    
}

in testingdemoApplicationTesting.java--

assert integer values are there--

package com.itvedant.testingdemo;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TestingdemoApplicationTests {

	@Test
	void contextLoads() {
		System.out.println("Welcome to unit testing");
	}

	@Test
    void testAdd(){
        Calculator c = new Calculator();
        int actualResult = c.add(2,4);
        int expectedResult = 7;
        assertEquals(expectedResult,actualResult);
    }

  

}



Now in this testingdemo only create a new class--
Calculator.java

now in the pom.xml, there is this starter file already 
added, we have few jar files like junit which are
already incorporated for testing.
So the junit contains some set of assert functions,
which can be used to match the acttual values 
with the predicted values.


cmd to run is--- .\mvnw test

So next creating an api for calculation
for addition ,* etc.

So we will use a diiferent api then petstoreapi.

So come to pom.xml, we need to add few starter files first.
right click-- add starters-- lombok for getter setter methods,
then for db connectivity-- mysql driver, and spring data jpa.
Also since we r not creating restapi's manually,
so, data rest-- i.e. rest repositroy-- because
of this we donot need to create controller or
service class.

-- proceed-- yes.

main -- 
come to application.properties-- 

spring.application.name=testingdemo

spring.datasource.url=jdbc:mysql://localhost:3600/petstore1012 --- this is the name of the db.
spring.datasource.username=root

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

Next cretaing entities----
so, java-- main-- Create new file-- Student.java ----

package com.itvedant.testingdemo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import lombok.Data;

@Entity
@Data
public class Student {
    @Id
    private Integer id;
    private String name;
    private Integer age;
    private Float marks;    
}

next creating StudentRepository.java --

package com.itvedant.testingdemo;

import org.springframework.data.jpa.repository.JpaRepository;

public class StudentRepository
         extends JpaRepository<Student,Integer> {
    
}


next creating test cases--

So, in the testingdemo, create a  new class called -- TestStudent.java--

Since we will be using many test cases, so annotate with @SpringBootTest

So next we will inject repository first.
Because repository contains read(),insert(),delete(),etc
And then we r going to autowire it.

And the we will cretae a dummy student object inside funct TestInsert.








5. @Service - 
6. @Repository - 

So IOC basically means, the lifecycle of ur beans is basically controlled by Springboot

Dependency Injection (DI)

DI is used to get the reference of the objects inside the container.

The container is containing the object. To use this object we will inject the reference(address) of the object and give it to a reference variable using DI 

DI is implemented using @AutoWired annotation

@SpringBootApplication

This annotation is enabling the features of the following three annotations:

1. @EnableAutoConfiguration - Start the auto configation in the spring boot project

2. @Configuration - this class can also contain some bean methods

3. @ComponentScan - this annotation tells spring boot about the package which has to be scanned to find the Component/Configuration class so that these class objects can be created and placed inside the container

----------------------------------------------
MVC Based Application in Spring Boot

M - Model

V - View - is something that the client will recieve as the response which will be rendered in the browser of the client.

C - Controller - front warrior - whenever a request is received it is handled first by the controller. In the controller we specify that which view has to returned to the client as the response.

---------------------------------------------
Request - Response Model

Request - Will originate from the browser and will contain the URL on the basis of which the controller will decide about the view that will returned as the response

Response - Will be generated by the application and is send back to the client who has requested for it

---------------------------------------------
URL Mapping 

Each method in the controller class will be mapped with a URL pattern. These controller method will return the name of the view file and will be send back as response

URL mapping over the method will be done using @RequestMapping

---------------------------------------------
Convention

1. Class Name ===> PascalCase ==> Each word of the class name should start with first letter capital

2. Variable/Method ===> camelCase ==> First word will be completely in lowercase and from second word onward we follow PascalCase

3. Package Name ===> smallcase ===> very word will be in lowercase

4. Constants (Final Variable) ===> UPPERCASE ==> Final variable name will be in uppercase

5. URL ===> smallcase ===> very word will be in lowercase

----------------------------------------------
Spring Devtool Starter

This starter is used to restart the application execution after every change made in the application source code or structure. It is also used to get the live result of the project.

-----------------------------------------------
In the Spring Boot Project
1. Entity Classes ==> Define the type of the resource. For example object of a class in the resource but what should each object consist or the properties of the object are defined in the class

2. Controller Classes ==> The focus of the controller class should be on reading the request and returning the response. The transition from request to response is done by writing some business logic which should not be included in the controller class

3. Service Classes ==> The focus of the service class is to provide the service/help to the controller class by providing the business logic 

###############################################################################################################################################

In spring mvc





















































 








 





































